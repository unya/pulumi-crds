// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha1

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// XBackendTrafficPolicy defines the configuration for how traffic to a
// target backend should be handled.
type XBackendTrafficPolicyType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta           `pulumi:"metadata"`
	Spec     *XBackendTrafficPolicySpec   `pulumi:"spec"`
	Status   *XBackendTrafficPolicyStatus `pulumi:"status"`
}

// XBackendTrafficPolicyTypeInput is an input type that accepts XBackendTrafficPolicyTypeArgs and XBackendTrafficPolicyTypeOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyTypeInput` via:
//
//	XBackendTrafficPolicyTypeArgs{...}
type XBackendTrafficPolicyTypeInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyTypeOutput() XBackendTrafficPolicyTypeOutput
	ToXBackendTrafficPolicyTypeOutputWithContext(context.Context) XBackendTrafficPolicyTypeOutput
}

// XBackendTrafficPolicy defines the configuration for how traffic to a
// target backend should be handled.
type XBackendTrafficPolicyTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput           `pulumi:"metadata"`
	Spec     XBackendTrafficPolicySpecPtrInput   `pulumi:"spec"`
	Status   XBackendTrafficPolicyStatusPtrInput `pulumi:"status"`
}

func (XBackendTrafficPolicyTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyType)(nil)).Elem()
}

func (i XBackendTrafficPolicyTypeArgs) ToXBackendTrafficPolicyTypeOutput() XBackendTrafficPolicyTypeOutput {
	return i.ToXBackendTrafficPolicyTypeOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyTypeArgs) ToXBackendTrafficPolicyTypeOutputWithContext(ctx context.Context) XBackendTrafficPolicyTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyTypeOutput)
}

// XBackendTrafficPolicyTypeArrayInput is an input type that accepts XBackendTrafficPolicyTypeArray and XBackendTrafficPolicyTypeArrayOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyTypeArrayInput` via:
//
//	XBackendTrafficPolicyTypeArray{ XBackendTrafficPolicyTypeArgs{...} }
type XBackendTrafficPolicyTypeArrayInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyTypeArrayOutput() XBackendTrafficPolicyTypeArrayOutput
	ToXBackendTrafficPolicyTypeArrayOutputWithContext(context.Context) XBackendTrafficPolicyTypeArrayOutput
}

type XBackendTrafficPolicyTypeArray []XBackendTrafficPolicyTypeInput

func (XBackendTrafficPolicyTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XBackendTrafficPolicyType)(nil)).Elem()
}

func (i XBackendTrafficPolicyTypeArray) ToXBackendTrafficPolicyTypeArrayOutput() XBackendTrafficPolicyTypeArrayOutput {
	return i.ToXBackendTrafficPolicyTypeArrayOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyTypeArray) ToXBackendTrafficPolicyTypeArrayOutputWithContext(ctx context.Context) XBackendTrafficPolicyTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyTypeArrayOutput)
}

// XBackendTrafficPolicy defines the configuration for how traffic to a
// target backend should be handled.
type XBackendTrafficPolicyTypeOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyType)(nil)).Elem()
}

func (o XBackendTrafficPolicyTypeOutput) ToXBackendTrafficPolicyTypeOutput() XBackendTrafficPolicyTypeOutput {
	return o
}

func (o XBackendTrafficPolicyTypeOutput) ToXBackendTrafficPolicyTypeOutputWithContext(ctx context.Context) XBackendTrafficPolicyTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o XBackendTrafficPolicyTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o XBackendTrafficPolicyTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o XBackendTrafficPolicyTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o XBackendTrafficPolicyTypeOutput) Spec() XBackendTrafficPolicySpecPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyType) *XBackendTrafficPolicySpec { return v.Spec }).(XBackendTrafficPolicySpecPtrOutput)
}

func (o XBackendTrafficPolicyTypeOutput) Status() XBackendTrafficPolicyStatusPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyType) *XBackendTrafficPolicyStatus { return v.Status }).(XBackendTrafficPolicyStatusPtrOutput)
}

type XBackendTrafficPolicyTypeArrayOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XBackendTrafficPolicyType)(nil)).Elem()
}

func (o XBackendTrafficPolicyTypeArrayOutput) ToXBackendTrafficPolicyTypeArrayOutput() XBackendTrafficPolicyTypeArrayOutput {
	return o
}

func (o XBackendTrafficPolicyTypeArrayOutput) ToXBackendTrafficPolicyTypeArrayOutputWithContext(ctx context.Context) XBackendTrafficPolicyTypeArrayOutput {
	return o
}

func (o XBackendTrafficPolicyTypeArrayOutput) Index(i pulumi.IntInput) XBackendTrafficPolicyTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XBackendTrafficPolicyType {
		return vs[0].([]XBackendTrafficPolicyType)[vs[1].(int)]
	}).(XBackendTrafficPolicyTypeOutput)
}

// XBackendTrafficPolicyList is a list of XBackendTrafficPolicy
type XBackendTrafficPolicyListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of xbackendtrafficpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []XBackendTrafficPolicyType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// XBackendTrafficPolicyListTypeInput is an input type that accepts XBackendTrafficPolicyListTypeArgs and XBackendTrafficPolicyListTypeOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyListTypeInput` via:
//
//	XBackendTrafficPolicyListTypeArgs{...}
type XBackendTrafficPolicyListTypeInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyListTypeOutput() XBackendTrafficPolicyListTypeOutput
	ToXBackendTrafficPolicyListTypeOutputWithContext(context.Context) XBackendTrafficPolicyListTypeOutput
}

// XBackendTrafficPolicyList is a list of XBackendTrafficPolicy
type XBackendTrafficPolicyListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of xbackendtrafficpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items XBackendTrafficPolicyTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (XBackendTrafficPolicyListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyListType)(nil)).Elem()
}

func (i XBackendTrafficPolicyListTypeArgs) ToXBackendTrafficPolicyListTypeOutput() XBackendTrafficPolicyListTypeOutput {
	return i.ToXBackendTrafficPolicyListTypeOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyListTypeArgs) ToXBackendTrafficPolicyListTypeOutputWithContext(ctx context.Context) XBackendTrafficPolicyListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyListTypeOutput)
}

// XBackendTrafficPolicyList is a list of XBackendTrafficPolicy
type XBackendTrafficPolicyListTypeOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyListType)(nil)).Elem()
}

func (o XBackendTrafficPolicyListTypeOutput) ToXBackendTrafficPolicyListTypeOutput() XBackendTrafficPolicyListTypeOutput {
	return o
}

func (o XBackendTrafficPolicyListTypeOutput) ToXBackendTrafficPolicyListTypeOutputWithContext(ctx context.Context) XBackendTrafficPolicyListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o XBackendTrafficPolicyListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of xbackendtrafficpolicies. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o XBackendTrafficPolicyListTypeOutput) Items() XBackendTrafficPolicyTypeArrayOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyListType) []XBackendTrafficPolicyType { return v.Items }).(XBackendTrafficPolicyTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o XBackendTrafficPolicyListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o XBackendTrafficPolicyListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// XBackendTrafficPolicy defines the configuration for how traffic to a
// target backend should be handled.
type XBackendTrafficPolicyPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch           `pulumi:"metadata"`
	Spec     *XBackendTrafficPolicySpecPatch   `pulumi:"spec"`
	Status   *XBackendTrafficPolicyStatusPatch `pulumi:"status"`
}

// XBackendTrafficPolicyPatchTypeInput is an input type that accepts XBackendTrafficPolicyPatchTypeArgs and XBackendTrafficPolicyPatchTypeOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyPatchTypeInput` via:
//
//	XBackendTrafficPolicyPatchTypeArgs{...}
type XBackendTrafficPolicyPatchTypeInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyPatchTypeOutput() XBackendTrafficPolicyPatchTypeOutput
	ToXBackendTrafficPolicyPatchTypeOutputWithContext(context.Context) XBackendTrafficPolicyPatchTypeOutput
}

// XBackendTrafficPolicy defines the configuration for how traffic to a
// target backend should be handled.
type XBackendTrafficPolicyPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput           `pulumi:"metadata"`
	Spec     XBackendTrafficPolicySpecPatchPtrInput   `pulumi:"spec"`
	Status   XBackendTrafficPolicyStatusPatchPtrInput `pulumi:"status"`
}

func (XBackendTrafficPolicyPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyPatchType)(nil)).Elem()
}

func (i XBackendTrafficPolicyPatchTypeArgs) ToXBackendTrafficPolicyPatchTypeOutput() XBackendTrafficPolicyPatchTypeOutput {
	return i.ToXBackendTrafficPolicyPatchTypeOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyPatchTypeArgs) ToXBackendTrafficPolicyPatchTypeOutputWithContext(ctx context.Context) XBackendTrafficPolicyPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyPatchTypeOutput)
}

// XBackendTrafficPolicy defines the configuration for how traffic to a
// target backend should be handled.
type XBackendTrafficPolicyPatchTypeOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyPatchType)(nil)).Elem()
}

func (o XBackendTrafficPolicyPatchTypeOutput) ToXBackendTrafficPolicyPatchTypeOutput() XBackendTrafficPolicyPatchTypeOutput {
	return o
}

func (o XBackendTrafficPolicyPatchTypeOutput) ToXBackendTrafficPolicyPatchTypeOutputWithContext(ctx context.Context) XBackendTrafficPolicyPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o XBackendTrafficPolicyPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o XBackendTrafficPolicyPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o XBackendTrafficPolicyPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o XBackendTrafficPolicyPatchTypeOutput) Spec() XBackendTrafficPolicySpecPatchPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyPatchType) *XBackendTrafficPolicySpecPatch { return v.Spec }).(XBackendTrafficPolicySpecPatchPtrOutput)
}

func (o XBackendTrafficPolicyPatchTypeOutput) Status() XBackendTrafficPolicyStatusPatchPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyPatchType) *XBackendTrafficPolicyStatusPatch { return v.Status }).(XBackendTrafficPolicyStatusPatchPtrOutput)
}

// Spec defines the desired state of BackendTrafficPolicy.
type XBackendTrafficPolicySpec struct {
	RetryConstraint    *XBackendTrafficPolicySpecRetryConstraint    `pulumi:"retryConstraint"`
	SessionPersistence *XBackendTrafficPolicySpecSessionPersistence `pulumi:"sessionPersistence"`
	// TargetRefs identifies API object(s) to apply this policy to.
	// Currently, Backends (A grouping of like endpoints such as Service,
	// ServiceImport, or any implementation-specific backendRef) are the only
	// valid API target references.
	//
	// Currently, a TargetRef can not be scoped to a specific port on a
	// Service.
	TargetRefs []XBackendTrafficPolicySpecTargetRefs `pulumi:"targetRefs"`
}

// XBackendTrafficPolicySpecInput is an input type that accepts XBackendTrafficPolicySpecArgs and XBackendTrafficPolicySpecOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecInput` via:
//
//	XBackendTrafficPolicySpecArgs{...}
type XBackendTrafficPolicySpecInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecOutput() XBackendTrafficPolicySpecOutput
	ToXBackendTrafficPolicySpecOutputWithContext(context.Context) XBackendTrafficPolicySpecOutput
}

// Spec defines the desired state of BackendTrafficPolicy.
type XBackendTrafficPolicySpecArgs struct {
	RetryConstraint    XBackendTrafficPolicySpecRetryConstraintPtrInput    `pulumi:"retryConstraint"`
	SessionPersistence XBackendTrafficPolicySpecSessionPersistencePtrInput `pulumi:"sessionPersistence"`
	// TargetRefs identifies API object(s) to apply this policy to.
	// Currently, Backends (A grouping of like endpoints such as Service,
	// ServiceImport, or any implementation-specific backendRef) are the only
	// valid API target references.
	//
	// Currently, a TargetRef can not be scoped to a specific port on a
	// Service.
	TargetRefs XBackendTrafficPolicySpecTargetRefsArrayInput `pulumi:"targetRefs"`
}

func (XBackendTrafficPolicySpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpec)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecArgs) ToXBackendTrafficPolicySpecOutput() XBackendTrafficPolicySpecOutput {
	return i.ToXBackendTrafficPolicySpecOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecArgs) ToXBackendTrafficPolicySpecOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecOutput)
}

func (i XBackendTrafficPolicySpecArgs) ToXBackendTrafficPolicySpecPtrOutput() XBackendTrafficPolicySpecPtrOutput {
	return i.ToXBackendTrafficPolicySpecPtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecArgs) ToXBackendTrafficPolicySpecPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecOutput).ToXBackendTrafficPolicySpecPtrOutputWithContext(ctx)
}

// XBackendTrafficPolicySpecPtrInput is an input type that accepts XBackendTrafficPolicySpecArgs, XBackendTrafficPolicySpecPtr and XBackendTrafficPolicySpecPtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecPtrInput` via:
//
//	        XBackendTrafficPolicySpecArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicySpecPtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecPtrOutput() XBackendTrafficPolicySpecPtrOutput
	ToXBackendTrafficPolicySpecPtrOutputWithContext(context.Context) XBackendTrafficPolicySpecPtrOutput
}

type xbackendTrafficPolicySpecPtrType XBackendTrafficPolicySpecArgs

func XBackendTrafficPolicySpecPtr(v *XBackendTrafficPolicySpecArgs) XBackendTrafficPolicySpecPtrInput {
	return (*xbackendTrafficPolicySpecPtrType)(v)
}

func (*xbackendTrafficPolicySpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpec)(nil)).Elem()
}

func (i *xbackendTrafficPolicySpecPtrType) ToXBackendTrafficPolicySpecPtrOutput() XBackendTrafficPolicySpecPtrOutput {
	return i.ToXBackendTrafficPolicySpecPtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicySpecPtrType) ToXBackendTrafficPolicySpecPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecPtrOutput)
}

// Spec defines the desired state of BackendTrafficPolicy.
type XBackendTrafficPolicySpecOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpec)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecOutput) ToXBackendTrafficPolicySpecOutput() XBackendTrafficPolicySpecOutput {
	return o
}

func (o XBackendTrafficPolicySpecOutput) ToXBackendTrafficPolicySpecOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecOutput {
	return o
}

func (o XBackendTrafficPolicySpecOutput) ToXBackendTrafficPolicySpecPtrOutput() XBackendTrafficPolicySpecPtrOutput {
	return o.ToXBackendTrafficPolicySpecPtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicySpecOutput) ToXBackendTrafficPolicySpecPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicySpec) *XBackendTrafficPolicySpec {
		return &v
	}).(XBackendTrafficPolicySpecPtrOutput)
}

func (o XBackendTrafficPolicySpecOutput) RetryConstraint() XBackendTrafficPolicySpecRetryConstraintPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpec) *XBackendTrafficPolicySpecRetryConstraint { return v.RetryConstraint }).(XBackendTrafficPolicySpecRetryConstraintPtrOutput)
}

func (o XBackendTrafficPolicySpecOutput) SessionPersistence() XBackendTrafficPolicySpecSessionPersistencePtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpec) *XBackendTrafficPolicySpecSessionPersistence {
		return v.SessionPersistence
	}).(XBackendTrafficPolicySpecSessionPersistencePtrOutput)
}

// TargetRefs identifies API object(s) to apply this policy to.
// Currently, Backends (A grouping of like endpoints such as Service,
// ServiceImport, or any implementation-specific backendRef) are the only
// valid API target references.
//
// Currently, a TargetRef can not be scoped to a specific port on a
// Service.
func (o XBackendTrafficPolicySpecOutput) TargetRefs() XBackendTrafficPolicySpecTargetRefsArrayOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpec) []XBackendTrafficPolicySpecTargetRefs { return v.TargetRefs }).(XBackendTrafficPolicySpecTargetRefsArrayOutput)
}

type XBackendTrafficPolicySpecPtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpec)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecPtrOutput) ToXBackendTrafficPolicySpecPtrOutput() XBackendTrafficPolicySpecPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecPtrOutput) ToXBackendTrafficPolicySpecPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecPtrOutput) Elem() XBackendTrafficPolicySpecOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpec) XBackendTrafficPolicySpec {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicySpec
		return ret
	}).(XBackendTrafficPolicySpecOutput)
}

func (o XBackendTrafficPolicySpecPtrOutput) RetryConstraint() XBackendTrafficPolicySpecRetryConstraintPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpec) *XBackendTrafficPolicySpecRetryConstraint {
		if v == nil {
			return nil
		}
		return v.RetryConstraint
	}).(XBackendTrafficPolicySpecRetryConstraintPtrOutput)
}

func (o XBackendTrafficPolicySpecPtrOutput) SessionPersistence() XBackendTrafficPolicySpecSessionPersistencePtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpec) *XBackendTrafficPolicySpecSessionPersistence {
		if v == nil {
			return nil
		}
		return v.SessionPersistence
	}).(XBackendTrafficPolicySpecSessionPersistencePtrOutput)
}

// TargetRefs identifies API object(s) to apply this policy to.
// Currently, Backends (A grouping of like endpoints such as Service,
// ServiceImport, or any implementation-specific backendRef) are the only
// valid API target references.
//
// Currently, a TargetRef can not be scoped to a specific port on a
// Service.
func (o XBackendTrafficPolicySpecPtrOutput) TargetRefs() XBackendTrafficPolicySpecTargetRefsArrayOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpec) []XBackendTrafficPolicySpecTargetRefs {
		if v == nil {
			return nil
		}
		return v.TargetRefs
	}).(XBackendTrafficPolicySpecTargetRefsArrayOutput)
}

// Spec defines the desired state of BackendTrafficPolicy.
type XBackendTrafficPolicySpecPatch struct {
	RetryConstraint    *XBackendTrafficPolicySpecRetryConstraintPatch    `pulumi:"retryConstraint"`
	SessionPersistence *XBackendTrafficPolicySpecSessionPersistencePatch `pulumi:"sessionPersistence"`
	// TargetRefs identifies API object(s) to apply this policy to.
	// Currently, Backends (A grouping of like endpoints such as Service,
	// ServiceImport, or any implementation-specific backendRef) are the only
	// valid API target references.
	//
	// Currently, a TargetRef can not be scoped to a specific port on a
	// Service.
	TargetRefs []XBackendTrafficPolicySpecTargetRefsPatch `pulumi:"targetRefs"`
}

// XBackendTrafficPolicySpecPatchInput is an input type that accepts XBackendTrafficPolicySpecPatchArgs and XBackendTrafficPolicySpecPatchOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecPatchInput` via:
//
//	XBackendTrafficPolicySpecPatchArgs{...}
type XBackendTrafficPolicySpecPatchInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecPatchOutput() XBackendTrafficPolicySpecPatchOutput
	ToXBackendTrafficPolicySpecPatchOutputWithContext(context.Context) XBackendTrafficPolicySpecPatchOutput
}

// Spec defines the desired state of BackendTrafficPolicy.
type XBackendTrafficPolicySpecPatchArgs struct {
	RetryConstraint    XBackendTrafficPolicySpecRetryConstraintPatchPtrInput    `pulumi:"retryConstraint"`
	SessionPersistence XBackendTrafficPolicySpecSessionPersistencePatchPtrInput `pulumi:"sessionPersistence"`
	// TargetRefs identifies API object(s) to apply this policy to.
	// Currently, Backends (A grouping of like endpoints such as Service,
	// ServiceImport, or any implementation-specific backendRef) are the only
	// valid API target references.
	//
	// Currently, a TargetRef can not be scoped to a specific port on a
	// Service.
	TargetRefs XBackendTrafficPolicySpecTargetRefsPatchArrayInput `pulumi:"targetRefs"`
}

func (XBackendTrafficPolicySpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecPatch)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecPatchArgs) ToXBackendTrafficPolicySpecPatchOutput() XBackendTrafficPolicySpecPatchOutput {
	return i.ToXBackendTrafficPolicySpecPatchOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecPatchArgs) ToXBackendTrafficPolicySpecPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecPatchOutput)
}

func (i XBackendTrafficPolicySpecPatchArgs) ToXBackendTrafficPolicySpecPatchPtrOutput() XBackendTrafficPolicySpecPatchPtrOutput {
	return i.ToXBackendTrafficPolicySpecPatchPtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecPatchArgs) ToXBackendTrafficPolicySpecPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecPatchOutput).ToXBackendTrafficPolicySpecPatchPtrOutputWithContext(ctx)
}

// XBackendTrafficPolicySpecPatchPtrInput is an input type that accepts XBackendTrafficPolicySpecPatchArgs, XBackendTrafficPolicySpecPatchPtr and XBackendTrafficPolicySpecPatchPtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecPatchPtrInput` via:
//
//	        XBackendTrafficPolicySpecPatchArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicySpecPatchPtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecPatchPtrOutput() XBackendTrafficPolicySpecPatchPtrOutput
	ToXBackendTrafficPolicySpecPatchPtrOutputWithContext(context.Context) XBackendTrafficPolicySpecPatchPtrOutput
}

type xbackendTrafficPolicySpecPatchPtrType XBackendTrafficPolicySpecPatchArgs

func XBackendTrafficPolicySpecPatchPtr(v *XBackendTrafficPolicySpecPatchArgs) XBackendTrafficPolicySpecPatchPtrInput {
	return (*xbackendTrafficPolicySpecPatchPtrType)(v)
}

func (*xbackendTrafficPolicySpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecPatch)(nil)).Elem()
}

func (i *xbackendTrafficPolicySpecPatchPtrType) ToXBackendTrafficPolicySpecPatchPtrOutput() XBackendTrafficPolicySpecPatchPtrOutput {
	return i.ToXBackendTrafficPolicySpecPatchPtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicySpecPatchPtrType) ToXBackendTrafficPolicySpecPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecPatchPtrOutput)
}

// Spec defines the desired state of BackendTrafficPolicy.
type XBackendTrafficPolicySpecPatchOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecPatchOutput) ToXBackendTrafficPolicySpecPatchOutput() XBackendTrafficPolicySpecPatchOutput {
	return o
}

func (o XBackendTrafficPolicySpecPatchOutput) ToXBackendTrafficPolicySpecPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecPatchOutput {
	return o
}

func (o XBackendTrafficPolicySpecPatchOutput) ToXBackendTrafficPolicySpecPatchPtrOutput() XBackendTrafficPolicySpecPatchPtrOutput {
	return o.ToXBackendTrafficPolicySpecPatchPtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicySpecPatchOutput) ToXBackendTrafficPolicySpecPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicySpecPatch) *XBackendTrafficPolicySpecPatch {
		return &v
	}).(XBackendTrafficPolicySpecPatchPtrOutput)
}

func (o XBackendTrafficPolicySpecPatchOutput) RetryConstraint() XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecPatch) *XBackendTrafficPolicySpecRetryConstraintPatch {
		return v.RetryConstraint
	}).(XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput)
}

func (o XBackendTrafficPolicySpecPatchOutput) SessionPersistence() XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecPatch) *XBackendTrafficPolicySpecSessionPersistencePatch {
		return v.SessionPersistence
	}).(XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput)
}

// TargetRefs identifies API object(s) to apply this policy to.
// Currently, Backends (A grouping of like endpoints such as Service,
// ServiceImport, or any implementation-specific backendRef) are the only
// valid API target references.
//
// Currently, a TargetRef can not be scoped to a specific port on a
// Service.
func (o XBackendTrafficPolicySpecPatchOutput) TargetRefs() XBackendTrafficPolicySpecTargetRefsPatchArrayOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecPatch) []XBackendTrafficPolicySpecTargetRefsPatch { return v.TargetRefs }).(XBackendTrafficPolicySpecTargetRefsPatchArrayOutput)
}

type XBackendTrafficPolicySpecPatchPtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecPatchPtrOutput) ToXBackendTrafficPolicySpecPatchPtrOutput() XBackendTrafficPolicySpecPatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecPatchPtrOutput) ToXBackendTrafficPolicySpecPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecPatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecPatchPtrOutput) Elem() XBackendTrafficPolicySpecPatchOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecPatch) XBackendTrafficPolicySpecPatch {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicySpecPatch
		return ret
	}).(XBackendTrafficPolicySpecPatchOutput)
}

func (o XBackendTrafficPolicySpecPatchPtrOutput) RetryConstraint() XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecPatch) *XBackendTrafficPolicySpecRetryConstraintPatch {
		if v == nil {
			return nil
		}
		return v.RetryConstraint
	}).(XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput)
}

func (o XBackendTrafficPolicySpecPatchPtrOutput) SessionPersistence() XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecPatch) *XBackendTrafficPolicySpecSessionPersistencePatch {
		if v == nil {
			return nil
		}
		return v.SessionPersistence
	}).(XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput)
}

// TargetRefs identifies API object(s) to apply this policy to.
// Currently, Backends (A grouping of like endpoints such as Service,
// ServiceImport, or any implementation-specific backendRef) are the only
// valid API target references.
//
// Currently, a TargetRef can not be scoped to a specific port on a
// Service.
func (o XBackendTrafficPolicySpecPatchPtrOutput) TargetRefs() XBackendTrafficPolicySpecTargetRefsPatchArrayOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecPatch) []XBackendTrafficPolicySpecTargetRefsPatch {
		if v == nil {
			return nil
		}
		return v.TargetRefs
	}).(XBackendTrafficPolicySpecTargetRefsPatchArrayOutput)
}

// RetryConstraint defines the configuration for when to allow or prevent
// further retries to a target backend, by dynamically calculating a 'retry
// budget'. This budget is calculated based on the percentage of incoming
// traffic composed of retries over a given time interval. Once the budget
// is exceeded, additional retries will be rejected.
//
// For example, if the retry budget interval is 10 seconds, there have been
// 1000 active requests in the past 10 seconds, and the allowed percentage
// of requests that can be retried is 20% (the default), then 200 of those
// requests may be composed of retries. Active requests will only be
// considered for the duration of the interval when calculating the retry
// budget. Retrying the same original request multiple times within the
// retry budget interval will lead to each retry being counted towards
// calculating the budget.
//
// Configuring a RetryConstraint in BackendTrafficPolicy is compatible with
// HTTPRoute Retry settings for each HTTPRouteRule that targets the same
// backend. While the HTTPRouteRule Retry stanza can specify whether a
// request will be retried, and the number of retry attempts each client
// may perform, RetryConstraint helps prevent cascading failures such as
// retry storms during periods of consistent failures.
//
// After the retry budget has been exceeded, additional retries to the
// backend MUST return a 503 response to the client.
//
// Additional configurations for defining a constraint on retries MAY be
// defined in the future.
//
// Support: Extended
type XBackendTrafficPolicySpecRetryConstraint struct {
	Budget       *XBackendTrafficPolicySpecRetryConstraintBudget       `pulumi:"budget"`
	MinRetryRate *XBackendTrafficPolicySpecRetryConstraintMinRetryRate `pulumi:"minRetryRate"`
}

// XBackendTrafficPolicySpecRetryConstraintInput is an input type that accepts XBackendTrafficPolicySpecRetryConstraintArgs and XBackendTrafficPolicySpecRetryConstraintOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecRetryConstraintInput` via:
//
//	XBackendTrafficPolicySpecRetryConstraintArgs{...}
type XBackendTrafficPolicySpecRetryConstraintInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecRetryConstraintOutput() XBackendTrafficPolicySpecRetryConstraintOutput
	ToXBackendTrafficPolicySpecRetryConstraintOutputWithContext(context.Context) XBackendTrafficPolicySpecRetryConstraintOutput
}

// RetryConstraint defines the configuration for when to allow or prevent
// further retries to a target backend, by dynamically calculating a 'retry
// budget'. This budget is calculated based on the percentage of incoming
// traffic composed of retries over a given time interval. Once the budget
// is exceeded, additional retries will be rejected.
//
// For example, if the retry budget interval is 10 seconds, there have been
// 1000 active requests in the past 10 seconds, and the allowed percentage
// of requests that can be retried is 20% (the default), then 200 of those
// requests may be composed of retries. Active requests will only be
// considered for the duration of the interval when calculating the retry
// budget. Retrying the same original request multiple times within the
// retry budget interval will lead to each retry being counted towards
// calculating the budget.
//
// Configuring a RetryConstraint in BackendTrafficPolicy is compatible with
// HTTPRoute Retry settings for each HTTPRouteRule that targets the same
// backend. While the HTTPRouteRule Retry stanza can specify whether a
// request will be retried, and the number of retry attempts each client
// may perform, RetryConstraint helps prevent cascading failures such as
// retry storms during periods of consistent failures.
//
// After the retry budget has been exceeded, additional retries to the
// backend MUST return a 503 response to the client.
//
// Additional configurations for defining a constraint on retries MAY be
// defined in the future.
//
// Support: Extended
type XBackendTrafficPolicySpecRetryConstraintArgs struct {
	Budget       XBackendTrafficPolicySpecRetryConstraintBudgetPtrInput       `pulumi:"budget"`
	MinRetryRate XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrInput `pulumi:"minRetryRate"`
}

func (XBackendTrafficPolicySpecRetryConstraintArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraint)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecRetryConstraintArgs) ToXBackendTrafficPolicySpecRetryConstraintOutput() XBackendTrafficPolicySpecRetryConstraintOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecRetryConstraintArgs) ToXBackendTrafficPolicySpecRetryConstraintOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintOutput)
}

func (i XBackendTrafficPolicySpecRetryConstraintArgs) ToXBackendTrafficPolicySpecRetryConstraintPtrOutput() XBackendTrafficPolicySpecRetryConstraintPtrOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintPtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecRetryConstraintArgs) ToXBackendTrafficPolicySpecRetryConstraintPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintOutput).ToXBackendTrafficPolicySpecRetryConstraintPtrOutputWithContext(ctx)
}

// XBackendTrafficPolicySpecRetryConstraintPtrInput is an input type that accepts XBackendTrafficPolicySpecRetryConstraintArgs, XBackendTrafficPolicySpecRetryConstraintPtr and XBackendTrafficPolicySpecRetryConstraintPtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecRetryConstraintPtrInput` via:
//
//	        XBackendTrafficPolicySpecRetryConstraintArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicySpecRetryConstraintPtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecRetryConstraintPtrOutput() XBackendTrafficPolicySpecRetryConstraintPtrOutput
	ToXBackendTrafficPolicySpecRetryConstraintPtrOutputWithContext(context.Context) XBackendTrafficPolicySpecRetryConstraintPtrOutput
}

type xbackendTrafficPolicySpecRetryConstraintPtrType XBackendTrafficPolicySpecRetryConstraintArgs

func XBackendTrafficPolicySpecRetryConstraintPtr(v *XBackendTrafficPolicySpecRetryConstraintArgs) XBackendTrafficPolicySpecRetryConstraintPtrInput {
	return (*xbackendTrafficPolicySpecRetryConstraintPtrType)(v)
}

func (*xbackendTrafficPolicySpecRetryConstraintPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecRetryConstraint)(nil)).Elem()
}

func (i *xbackendTrafficPolicySpecRetryConstraintPtrType) ToXBackendTrafficPolicySpecRetryConstraintPtrOutput() XBackendTrafficPolicySpecRetryConstraintPtrOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintPtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicySpecRetryConstraintPtrType) ToXBackendTrafficPolicySpecRetryConstraintPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintPtrOutput)
}

// RetryConstraint defines the configuration for when to allow or prevent
// further retries to a target backend, by dynamically calculating a 'retry
// budget'. This budget is calculated based on the percentage of incoming
// traffic composed of retries over a given time interval. Once the budget
// is exceeded, additional retries will be rejected.
//
// For example, if the retry budget interval is 10 seconds, there have been
// 1000 active requests in the past 10 seconds, and the allowed percentage
// of requests that can be retried is 20% (the default), then 200 of those
// requests may be composed of retries. Active requests will only be
// considered for the duration of the interval when calculating the retry
// budget. Retrying the same original request multiple times within the
// retry budget interval will lead to each retry being counted towards
// calculating the budget.
//
// Configuring a RetryConstraint in BackendTrafficPolicy is compatible with
// HTTPRoute Retry settings for each HTTPRouteRule that targets the same
// backend. While the HTTPRouteRule Retry stanza can specify whether a
// request will be retried, and the number of retry attempts each client
// may perform, RetryConstraint helps prevent cascading failures such as
// retry storms during periods of consistent failures.
//
// After the retry budget has been exceeded, additional retries to the
// backend MUST return a 503 response to the client.
//
// Additional configurations for defining a constraint on retries MAY be
// defined in the future.
//
// Support: Extended
type XBackendTrafficPolicySpecRetryConstraintOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecRetryConstraintOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraint)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecRetryConstraintOutput) ToXBackendTrafficPolicySpecRetryConstraintOutput() XBackendTrafficPolicySpecRetryConstraintOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintOutput) ToXBackendTrafficPolicySpecRetryConstraintOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintOutput) ToXBackendTrafficPolicySpecRetryConstraintPtrOutput() XBackendTrafficPolicySpecRetryConstraintPtrOutput {
	return o.ToXBackendTrafficPolicySpecRetryConstraintPtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicySpecRetryConstraintOutput) ToXBackendTrafficPolicySpecRetryConstraintPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicySpecRetryConstraint) *XBackendTrafficPolicySpecRetryConstraint {
		return &v
	}).(XBackendTrafficPolicySpecRetryConstraintPtrOutput)
}

func (o XBackendTrafficPolicySpecRetryConstraintOutput) Budget() XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecRetryConstraint) *XBackendTrafficPolicySpecRetryConstraintBudget {
		return v.Budget
	}).(XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput)
}

func (o XBackendTrafficPolicySpecRetryConstraintOutput) MinRetryRate() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecRetryConstraint) *XBackendTrafficPolicySpecRetryConstraintMinRetryRate {
		return v.MinRetryRate
	}).(XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput)
}

type XBackendTrafficPolicySpecRetryConstraintPtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecRetryConstraintPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecRetryConstraint)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecRetryConstraintPtrOutput) ToXBackendTrafficPolicySpecRetryConstraintPtrOutput() XBackendTrafficPolicySpecRetryConstraintPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintPtrOutput) ToXBackendTrafficPolicySpecRetryConstraintPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintPtrOutput) Elem() XBackendTrafficPolicySpecRetryConstraintOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraint) XBackendTrafficPolicySpecRetryConstraint {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicySpecRetryConstraint
		return ret
	}).(XBackendTrafficPolicySpecRetryConstraintOutput)
}

func (o XBackendTrafficPolicySpecRetryConstraintPtrOutput) Budget() XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraint) *XBackendTrafficPolicySpecRetryConstraintBudget {
		if v == nil {
			return nil
		}
		return v.Budget
	}).(XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput)
}

func (o XBackendTrafficPolicySpecRetryConstraintPtrOutput) MinRetryRate() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraint) *XBackendTrafficPolicySpecRetryConstraintMinRetryRate {
		if v == nil {
			return nil
		}
		return v.MinRetryRate
	}).(XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput)
}

// Budget holds the details of the retry budget configuration.
type XBackendTrafficPolicySpecRetryConstraintBudget struct {
	// Interval defines the duration in which requests will be considered
	// for calculating the budget for retries.
	//
	// Support: Extended
	Interval *string `pulumi:"interval"`
	// Percent defines the maximum percentage of active requests that may
	// be made up of retries.
	//
	// Support: Extended
	Percent *int `pulumi:"percent"`
}

// XBackendTrafficPolicySpecRetryConstraintBudgetInput is an input type that accepts XBackendTrafficPolicySpecRetryConstraintBudgetArgs and XBackendTrafficPolicySpecRetryConstraintBudgetOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecRetryConstraintBudgetInput` via:
//
//	XBackendTrafficPolicySpecRetryConstraintBudgetArgs{...}
type XBackendTrafficPolicySpecRetryConstraintBudgetInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecRetryConstraintBudgetOutput() XBackendTrafficPolicySpecRetryConstraintBudgetOutput
	ToXBackendTrafficPolicySpecRetryConstraintBudgetOutputWithContext(context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetOutput
}

// Budget holds the details of the retry budget configuration.
type XBackendTrafficPolicySpecRetryConstraintBudgetArgs struct {
	// Interval defines the duration in which requests will be considered
	// for calculating the budget for retries.
	//
	// Support: Extended
	Interval pulumi.StringPtrInput `pulumi:"interval"`
	// Percent defines the maximum percentage of active requests that may
	// be made up of retries.
	//
	// Support: Extended
	Percent pulumi.IntPtrInput `pulumi:"percent"`
}

func (XBackendTrafficPolicySpecRetryConstraintBudgetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintBudget)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecRetryConstraintBudgetArgs) ToXBackendTrafficPolicySpecRetryConstraintBudgetOutput() XBackendTrafficPolicySpecRetryConstraintBudgetOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintBudgetOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecRetryConstraintBudgetArgs) ToXBackendTrafficPolicySpecRetryConstraintBudgetOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintBudgetOutput)
}

func (i XBackendTrafficPolicySpecRetryConstraintBudgetArgs) ToXBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput() XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintBudgetPtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecRetryConstraintBudgetArgs) ToXBackendTrafficPolicySpecRetryConstraintBudgetPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintBudgetOutput).ToXBackendTrafficPolicySpecRetryConstraintBudgetPtrOutputWithContext(ctx)
}

// XBackendTrafficPolicySpecRetryConstraintBudgetPtrInput is an input type that accepts XBackendTrafficPolicySpecRetryConstraintBudgetArgs, XBackendTrafficPolicySpecRetryConstraintBudgetPtr and XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecRetryConstraintBudgetPtrInput` via:
//
//	        XBackendTrafficPolicySpecRetryConstraintBudgetArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicySpecRetryConstraintBudgetPtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput() XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput
	ToXBackendTrafficPolicySpecRetryConstraintBudgetPtrOutputWithContext(context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput
}

type xbackendTrafficPolicySpecRetryConstraintBudgetPtrType XBackendTrafficPolicySpecRetryConstraintBudgetArgs

func XBackendTrafficPolicySpecRetryConstraintBudgetPtr(v *XBackendTrafficPolicySpecRetryConstraintBudgetArgs) XBackendTrafficPolicySpecRetryConstraintBudgetPtrInput {
	return (*xbackendTrafficPolicySpecRetryConstraintBudgetPtrType)(v)
}

func (*xbackendTrafficPolicySpecRetryConstraintBudgetPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecRetryConstraintBudget)(nil)).Elem()
}

func (i *xbackendTrafficPolicySpecRetryConstraintBudgetPtrType) ToXBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput() XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintBudgetPtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicySpecRetryConstraintBudgetPtrType) ToXBackendTrafficPolicySpecRetryConstraintBudgetPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput)
}

// Budget holds the details of the retry budget configuration.
type XBackendTrafficPolicySpecRetryConstraintBudgetOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecRetryConstraintBudgetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintBudget)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecRetryConstraintBudgetOutput) ToXBackendTrafficPolicySpecRetryConstraintBudgetOutput() XBackendTrafficPolicySpecRetryConstraintBudgetOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintBudgetOutput) ToXBackendTrafficPolicySpecRetryConstraintBudgetOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintBudgetOutput) ToXBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput() XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput {
	return o.ToXBackendTrafficPolicySpecRetryConstraintBudgetPtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicySpecRetryConstraintBudgetOutput) ToXBackendTrafficPolicySpecRetryConstraintBudgetPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicySpecRetryConstraintBudget) *XBackendTrafficPolicySpecRetryConstraintBudget {
		return &v
	}).(XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput)
}

// Interval defines the duration in which requests will be considered
// for calculating the budget for retries.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintBudgetOutput) Interval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecRetryConstraintBudget) *string { return v.Interval }).(pulumi.StringPtrOutput)
}

// Percent defines the maximum percentage of active requests that may
// be made up of retries.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintBudgetOutput) Percent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecRetryConstraintBudget) *int { return v.Percent }).(pulumi.IntPtrOutput)
}

type XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecRetryConstraintBudget)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput) ToXBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput() XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput) ToXBackendTrafficPolicySpecRetryConstraintBudgetPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput) Elem() XBackendTrafficPolicySpecRetryConstraintBudgetOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintBudget) XBackendTrafficPolicySpecRetryConstraintBudget {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicySpecRetryConstraintBudget
		return ret
	}).(XBackendTrafficPolicySpecRetryConstraintBudgetOutput)
}

// Interval defines the duration in which requests will be considered
// for calculating the budget for retries.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput) Interval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintBudget) *string {
		if v == nil {
			return nil
		}
		return v.Interval
	}).(pulumi.StringPtrOutput)
}

// Percent defines the maximum percentage of active requests that may
// be made up of retries.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput) Percent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintBudget) *int {
		if v == nil {
			return nil
		}
		return v.Percent
	}).(pulumi.IntPtrOutput)
}

// Budget holds the details of the retry budget configuration.
type XBackendTrafficPolicySpecRetryConstraintBudgetPatch struct {
	// Interval defines the duration in which requests will be considered
	// for calculating the budget for retries.
	//
	// Support: Extended
	Interval *string `pulumi:"interval"`
	// Percent defines the maximum percentage of active requests that may
	// be made up of retries.
	//
	// Support: Extended
	Percent *int `pulumi:"percent"`
}

// XBackendTrafficPolicySpecRetryConstraintBudgetPatchInput is an input type that accepts XBackendTrafficPolicySpecRetryConstraintBudgetPatchArgs and XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecRetryConstraintBudgetPatchInput` via:
//
//	XBackendTrafficPolicySpecRetryConstraintBudgetPatchArgs{...}
type XBackendTrafficPolicySpecRetryConstraintBudgetPatchInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput() XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput
	ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchOutputWithContext(context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput
}

// Budget holds the details of the retry budget configuration.
type XBackendTrafficPolicySpecRetryConstraintBudgetPatchArgs struct {
	// Interval defines the duration in which requests will be considered
	// for calculating the budget for retries.
	//
	// Support: Extended
	Interval pulumi.StringPtrInput `pulumi:"interval"`
	// Percent defines the maximum percentage of active requests that may
	// be made up of retries.
	//
	// Support: Extended
	Percent pulumi.IntPtrInput `pulumi:"percent"`
}

func (XBackendTrafficPolicySpecRetryConstraintBudgetPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintBudgetPatch)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecRetryConstraintBudgetPatchArgs) ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput() XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecRetryConstraintBudgetPatchArgs) ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput)
}

func (i XBackendTrafficPolicySpecRetryConstraintBudgetPatchArgs) ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecRetryConstraintBudgetPatchArgs) ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput).ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutputWithContext(ctx)
}

// XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrInput is an input type that accepts XBackendTrafficPolicySpecRetryConstraintBudgetPatchArgs, XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtr and XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrInput` via:
//
//	        XBackendTrafficPolicySpecRetryConstraintBudgetPatchArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput
	ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutputWithContext(context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput
}

type xbackendTrafficPolicySpecRetryConstraintBudgetPatchPtrType XBackendTrafficPolicySpecRetryConstraintBudgetPatchArgs

func XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtr(v *XBackendTrafficPolicySpecRetryConstraintBudgetPatchArgs) XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrInput {
	return (*xbackendTrafficPolicySpecRetryConstraintBudgetPatchPtrType)(v)
}

func (*xbackendTrafficPolicySpecRetryConstraintBudgetPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecRetryConstraintBudgetPatch)(nil)).Elem()
}

func (i *xbackendTrafficPolicySpecRetryConstraintBudgetPatchPtrType) ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicySpecRetryConstraintBudgetPatchPtrType) ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput)
}

// Budget holds the details of the retry budget configuration.
type XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintBudgetPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput) ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput() XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput) ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput) ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput {
	return o.ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput) ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicySpecRetryConstraintBudgetPatch) *XBackendTrafficPolicySpecRetryConstraintBudgetPatch {
		return &v
	}).(XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput)
}

// Interval defines the duration in which requests will be considered
// for calculating the budget for retries.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput) Interval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecRetryConstraintBudgetPatch) *string { return v.Interval }).(pulumi.StringPtrOutput)
}

// Percent defines the maximum percentage of active requests that may
// be made up of retries.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput) Percent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecRetryConstraintBudgetPatch) *int { return v.Percent }).(pulumi.IntPtrOutput)
}

type XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecRetryConstraintBudgetPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput) ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput) ToXBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput) Elem() XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintBudgetPatch) XBackendTrafficPolicySpecRetryConstraintBudgetPatch {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicySpecRetryConstraintBudgetPatch
		return ret
	}).(XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput)
}

// Interval defines the duration in which requests will be considered
// for calculating the budget for retries.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput) Interval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintBudgetPatch) *string {
		if v == nil {
			return nil
		}
		return v.Interval
	}).(pulumi.StringPtrOutput)
}

// Percent defines the maximum percentage of active requests that may
// be made up of retries.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput) Percent() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintBudgetPatch) *int {
		if v == nil {
			return nil
		}
		return v.Percent
	}).(pulumi.IntPtrOutput)
}

// MinRetryRate defines the minimum rate of retries that will be allowable
// over a specified duration of time.
//
// The effective overall minimum rate of retries targeting the backend
// service may be much higher, as there can be any number of clients which
// are applying this setting locally.
//
// This ensures that requests can still be retried during periods of low
// traffic, where the budget for retries may be calculated as a very low
// value.
//
// Support: Extended
type XBackendTrafficPolicySpecRetryConstraintMinRetryRate struct {
	// Count specifies the number of requests per time interval.
	//
	// Support: Extended
	Count *int `pulumi:"count"`
	// Interval specifies the divisor of the rate of requests, the amount of
	// time during which the given count of requests occur.
	//
	// Support: Extended
	Interval *string `pulumi:"interval"`
}

// XBackendTrafficPolicySpecRetryConstraintMinRetryRateInput is an input type that accepts XBackendTrafficPolicySpecRetryConstraintMinRetryRateArgs and XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecRetryConstraintMinRetryRateInput` via:
//
//	XBackendTrafficPolicySpecRetryConstraintMinRetryRateArgs{...}
type XBackendTrafficPolicySpecRetryConstraintMinRetryRateInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput
	ToXBackendTrafficPolicySpecRetryConstraintMinRetryRateOutputWithContext(context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput
}

// MinRetryRate defines the minimum rate of retries that will be allowable
// over a specified duration of time.
//
// The effective overall minimum rate of retries targeting the backend
// service may be much higher, as there can be any number of clients which
// are applying this setting locally.
//
// This ensures that requests can still be retried during periods of low
// traffic, where the budget for retries may be calculated as a very low
// value.
//
// Support: Extended
type XBackendTrafficPolicySpecRetryConstraintMinRetryRateArgs struct {
	// Count specifies the number of requests per time interval.
	//
	// Support: Extended
	Count pulumi.IntPtrInput `pulumi:"count"`
	// Interval specifies the divisor of the rate of requests, the amount of
	// time during which the given count of requests occur.
	//
	// Support: Extended
	Interval pulumi.StringPtrInput `pulumi:"interval"`
}

func (XBackendTrafficPolicySpecRetryConstraintMinRetryRateArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintMinRetryRate)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecRetryConstraintMinRetryRateArgs) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintMinRetryRateOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecRetryConstraintMinRetryRateArgs) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRateOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput)
}

func (i XBackendTrafficPolicySpecRetryConstraintMinRetryRateArgs) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecRetryConstraintMinRetryRateArgs) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput).ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutputWithContext(ctx)
}

// XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrInput is an input type that accepts XBackendTrafficPolicySpecRetryConstraintMinRetryRateArgs, XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtr and XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrInput` via:
//
//	        XBackendTrafficPolicySpecRetryConstraintMinRetryRateArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput
	ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutputWithContext(context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput
}

type xbackendTrafficPolicySpecRetryConstraintMinRetryRatePtrType XBackendTrafficPolicySpecRetryConstraintMinRetryRateArgs

func XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtr(v *XBackendTrafficPolicySpecRetryConstraintMinRetryRateArgs) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrInput {
	return (*xbackendTrafficPolicySpecRetryConstraintMinRetryRatePtrType)(v)
}

func (*xbackendTrafficPolicySpecRetryConstraintMinRetryRatePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecRetryConstraintMinRetryRate)(nil)).Elem()
}

func (i *xbackendTrafficPolicySpecRetryConstraintMinRetryRatePtrType) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicySpecRetryConstraintMinRetryRatePtrType) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput)
}

// MinRetryRate defines the minimum rate of retries that will be allowable
// over a specified duration of time.
//
// The effective overall minimum rate of retries targeting the backend
// service may be much higher, as there can be any number of clients which
// are applying this setting locally.
//
// This ensures that requests can still be retried during periods of low
// traffic, where the budget for retries may be calculated as a very low
// value.
//
// Support: Extended
type XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintMinRetryRate)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRateOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput {
	return o.ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicySpecRetryConstraintMinRetryRate) *XBackendTrafficPolicySpecRetryConstraintMinRetryRate {
		return &v
	}).(XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput)
}

// Count specifies the number of requests per time interval.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecRetryConstraintMinRetryRate) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// Interval specifies the divisor of the rate of requests, the amount of
// time during which the given count of requests occur.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput) Interval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecRetryConstraintMinRetryRate) *string { return v.Interval }).(pulumi.StringPtrOutput)
}

type XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecRetryConstraintMinRetryRate)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput) Elem() XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintMinRetryRate) XBackendTrafficPolicySpecRetryConstraintMinRetryRate {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicySpecRetryConstraintMinRetryRate
		return ret
	}).(XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput)
}

// Count specifies the number of requests per time interval.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintMinRetryRate) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

// Interval specifies the divisor of the rate of requests, the amount of
// time during which the given count of requests occur.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput) Interval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintMinRetryRate) *string {
		if v == nil {
			return nil
		}
		return v.Interval
	}).(pulumi.StringPtrOutput)
}

// MinRetryRate defines the minimum rate of retries that will be allowable
// over a specified duration of time.
//
// The effective overall minimum rate of retries targeting the backend
// service may be much higher, as there can be any number of clients which
// are applying this setting locally.
//
// This ensures that requests can still be retried during periods of low
// traffic, where the budget for retries may be calculated as a very low
// value.
//
// Support: Extended
type XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch struct {
	// Count specifies the number of requests per time interval.
	//
	// Support: Extended
	Count *int `pulumi:"count"`
	// Interval specifies the divisor of the rate of requests, the amount of
	// time during which the given count of requests occur.
	//
	// Support: Extended
	Interval *string `pulumi:"interval"`
}

// XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchInput is an input type that accepts XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchArgs and XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchInput` via:
//
//	XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchArgs{...}
type XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput
	ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutputWithContext(context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput
}

// MinRetryRate defines the minimum rate of retries that will be allowable
// over a specified duration of time.
//
// The effective overall minimum rate of retries targeting the backend
// service may be much higher, as there can be any number of clients which
// are applying this setting locally.
//
// This ensures that requests can still be retried during periods of low
// traffic, where the budget for retries may be calculated as a very low
// value.
//
// Support: Extended
type XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchArgs struct {
	// Count specifies the number of requests per time interval.
	//
	// Support: Extended
	Count pulumi.IntPtrInput `pulumi:"count"`
	// Interval specifies the divisor of the rate of requests, the amount of
	// time during which the given count of requests occur.
	//
	// Support: Extended
	Interval pulumi.StringPtrInput `pulumi:"interval"`
}

func (XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchArgs) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchArgs) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput)
}

func (i XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchArgs) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchArgs) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput).ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutputWithContext(ctx)
}

// XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrInput is an input type that accepts XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchArgs, XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtr and XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrInput` via:
//
//	        XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput
	ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutputWithContext(context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput
}

type xbackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrType XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchArgs

func XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtr(v *XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchArgs) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrInput {
	return (*xbackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrType)(v)
}

func (*xbackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch)(nil)).Elem()
}

func (i *xbackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrType) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrType) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput)
}

// MinRetryRate defines the minimum rate of retries that will be allowable
// over a specified duration of time.
//
// The effective overall minimum rate of retries targeting the backend
// service may be much higher, as there can be any number of clients which
// are applying this setting locally.
//
// This ensures that requests can still be retried during periods of low
// traffic, where the budget for retries may be calculated as a very low
// value.
//
// Support: Extended
type XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput {
	return o.ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch) *XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch {
		return &v
	}).(XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput)
}

// Count specifies the number of requests per time interval.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch) *int { return v.Count }).(pulumi.IntPtrOutput)
}

// Interval specifies the divisor of the rate of requests, the amount of
// time during which the given count of requests occur.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput) Interval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch) *string { return v.Interval }).(pulumi.StringPtrOutput)
}

type XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput) ToXBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput) Elem() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch) XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch
		return ret
	}).(XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput)
}

// Count specifies the number of requests per time interval.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput) Count() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch) *int {
		if v == nil {
			return nil
		}
		return v.Count
	}).(pulumi.IntPtrOutput)
}

// Interval specifies the divisor of the rate of requests, the amount of
// time during which the given count of requests occur.
//
// Support: Extended
func (o XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput) Interval() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch) *string {
		if v == nil {
			return nil
		}
		return v.Interval
	}).(pulumi.StringPtrOutput)
}

// RetryConstraint defines the configuration for when to allow or prevent
// further retries to a target backend, by dynamically calculating a 'retry
// budget'. This budget is calculated based on the percentage of incoming
// traffic composed of retries over a given time interval. Once the budget
// is exceeded, additional retries will be rejected.
//
// For example, if the retry budget interval is 10 seconds, there have been
// 1000 active requests in the past 10 seconds, and the allowed percentage
// of requests that can be retried is 20% (the default), then 200 of those
// requests may be composed of retries. Active requests will only be
// considered for the duration of the interval when calculating the retry
// budget. Retrying the same original request multiple times within the
// retry budget interval will lead to each retry being counted towards
// calculating the budget.
//
// Configuring a RetryConstraint in BackendTrafficPolicy is compatible with
// HTTPRoute Retry settings for each HTTPRouteRule that targets the same
// backend. While the HTTPRouteRule Retry stanza can specify whether a
// request will be retried, and the number of retry attempts each client
// may perform, RetryConstraint helps prevent cascading failures such as
// retry storms during periods of consistent failures.
//
// After the retry budget has been exceeded, additional retries to the
// backend MUST return a 503 response to the client.
//
// Additional configurations for defining a constraint on retries MAY be
// defined in the future.
//
// Support: Extended
type XBackendTrafficPolicySpecRetryConstraintPatch struct {
	Budget       *XBackendTrafficPolicySpecRetryConstraintBudgetPatch       `pulumi:"budget"`
	MinRetryRate *XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch `pulumi:"minRetryRate"`
}

// XBackendTrafficPolicySpecRetryConstraintPatchInput is an input type that accepts XBackendTrafficPolicySpecRetryConstraintPatchArgs and XBackendTrafficPolicySpecRetryConstraintPatchOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecRetryConstraintPatchInput` via:
//
//	XBackendTrafficPolicySpecRetryConstraintPatchArgs{...}
type XBackendTrafficPolicySpecRetryConstraintPatchInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecRetryConstraintPatchOutput() XBackendTrafficPolicySpecRetryConstraintPatchOutput
	ToXBackendTrafficPolicySpecRetryConstraintPatchOutputWithContext(context.Context) XBackendTrafficPolicySpecRetryConstraintPatchOutput
}

// RetryConstraint defines the configuration for when to allow or prevent
// further retries to a target backend, by dynamically calculating a 'retry
// budget'. This budget is calculated based on the percentage of incoming
// traffic composed of retries over a given time interval. Once the budget
// is exceeded, additional retries will be rejected.
//
// For example, if the retry budget interval is 10 seconds, there have been
// 1000 active requests in the past 10 seconds, and the allowed percentage
// of requests that can be retried is 20% (the default), then 200 of those
// requests may be composed of retries. Active requests will only be
// considered for the duration of the interval when calculating the retry
// budget. Retrying the same original request multiple times within the
// retry budget interval will lead to each retry being counted towards
// calculating the budget.
//
// Configuring a RetryConstraint in BackendTrafficPolicy is compatible with
// HTTPRoute Retry settings for each HTTPRouteRule that targets the same
// backend. While the HTTPRouteRule Retry stanza can specify whether a
// request will be retried, and the number of retry attempts each client
// may perform, RetryConstraint helps prevent cascading failures such as
// retry storms during periods of consistent failures.
//
// After the retry budget has been exceeded, additional retries to the
// backend MUST return a 503 response to the client.
//
// Additional configurations for defining a constraint on retries MAY be
// defined in the future.
//
// Support: Extended
type XBackendTrafficPolicySpecRetryConstraintPatchArgs struct {
	Budget       XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrInput       `pulumi:"budget"`
	MinRetryRate XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrInput `pulumi:"minRetryRate"`
}

func (XBackendTrafficPolicySpecRetryConstraintPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintPatch)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecRetryConstraintPatchArgs) ToXBackendTrafficPolicySpecRetryConstraintPatchOutput() XBackendTrafficPolicySpecRetryConstraintPatchOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintPatchOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecRetryConstraintPatchArgs) ToXBackendTrafficPolicySpecRetryConstraintPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintPatchOutput)
}

func (i XBackendTrafficPolicySpecRetryConstraintPatchArgs) ToXBackendTrafficPolicySpecRetryConstraintPatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintPatchPtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecRetryConstraintPatchArgs) ToXBackendTrafficPolicySpecRetryConstraintPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintPatchOutput).ToXBackendTrafficPolicySpecRetryConstraintPatchPtrOutputWithContext(ctx)
}

// XBackendTrafficPolicySpecRetryConstraintPatchPtrInput is an input type that accepts XBackendTrafficPolicySpecRetryConstraintPatchArgs, XBackendTrafficPolicySpecRetryConstraintPatchPtr and XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecRetryConstraintPatchPtrInput` via:
//
//	        XBackendTrafficPolicySpecRetryConstraintPatchArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicySpecRetryConstraintPatchPtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecRetryConstraintPatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput
	ToXBackendTrafficPolicySpecRetryConstraintPatchPtrOutputWithContext(context.Context) XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput
}

type xbackendTrafficPolicySpecRetryConstraintPatchPtrType XBackendTrafficPolicySpecRetryConstraintPatchArgs

func XBackendTrafficPolicySpecRetryConstraintPatchPtr(v *XBackendTrafficPolicySpecRetryConstraintPatchArgs) XBackendTrafficPolicySpecRetryConstraintPatchPtrInput {
	return (*xbackendTrafficPolicySpecRetryConstraintPatchPtrType)(v)
}

func (*xbackendTrafficPolicySpecRetryConstraintPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecRetryConstraintPatch)(nil)).Elem()
}

func (i *xbackendTrafficPolicySpecRetryConstraintPatchPtrType) ToXBackendTrafficPolicySpecRetryConstraintPatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput {
	return i.ToXBackendTrafficPolicySpecRetryConstraintPatchPtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicySpecRetryConstraintPatchPtrType) ToXBackendTrafficPolicySpecRetryConstraintPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput)
}

// RetryConstraint defines the configuration for when to allow or prevent
// further retries to a target backend, by dynamically calculating a 'retry
// budget'. This budget is calculated based on the percentage of incoming
// traffic composed of retries over a given time interval. Once the budget
// is exceeded, additional retries will be rejected.
//
// For example, if the retry budget interval is 10 seconds, there have been
// 1000 active requests in the past 10 seconds, and the allowed percentage
// of requests that can be retried is 20% (the default), then 200 of those
// requests may be composed of retries. Active requests will only be
// considered for the duration of the interval when calculating the retry
// budget. Retrying the same original request multiple times within the
// retry budget interval will lead to each retry being counted towards
// calculating the budget.
//
// Configuring a RetryConstraint in BackendTrafficPolicy is compatible with
// HTTPRoute Retry settings for each HTTPRouteRule that targets the same
// backend. While the HTTPRouteRule Retry stanza can specify whether a
// request will be retried, and the number of retry attempts each client
// may perform, RetryConstraint helps prevent cascading failures such as
// retry storms during periods of consistent failures.
//
// After the retry budget has been exceeded, additional retries to the
// backend MUST return a 503 response to the client.
//
// Additional configurations for defining a constraint on retries MAY be
// defined in the future.
//
// Support: Extended
type XBackendTrafficPolicySpecRetryConstraintPatchOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecRetryConstraintPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecRetryConstraintPatchOutput) ToXBackendTrafficPolicySpecRetryConstraintPatchOutput() XBackendTrafficPolicySpecRetryConstraintPatchOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintPatchOutput) ToXBackendTrafficPolicySpecRetryConstraintPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintPatchOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintPatchOutput) ToXBackendTrafficPolicySpecRetryConstraintPatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput {
	return o.ToXBackendTrafficPolicySpecRetryConstraintPatchPtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicySpecRetryConstraintPatchOutput) ToXBackendTrafficPolicySpecRetryConstraintPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicySpecRetryConstraintPatch) *XBackendTrafficPolicySpecRetryConstraintPatch {
		return &v
	}).(XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput)
}

func (o XBackendTrafficPolicySpecRetryConstraintPatchOutput) Budget() XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecRetryConstraintPatch) *XBackendTrafficPolicySpecRetryConstraintBudgetPatch {
		return v.Budget
	}).(XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput)
}

func (o XBackendTrafficPolicySpecRetryConstraintPatchOutput) MinRetryRate() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecRetryConstraintPatch) *XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch {
		return v.MinRetryRate
	}).(XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput)
}

type XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecRetryConstraintPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput) ToXBackendTrafficPolicySpecRetryConstraintPatchPtrOutput() XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput) ToXBackendTrafficPolicySpecRetryConstraintPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput) Elem() XBackendTrafficPolicySpecRetryConstraintPatchOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintPatch) XBackendTrafficPolicySpecRetryConstraintPatch {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicySpecRetryConstraintPatch
		return ret
	}).(XBackendTrafficPolicySpecRetryConstraintPatchOutput)
}

func (o XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput) Budget() XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintPatch) *XBackendTrafficPolicySpecRetryConstraintBudgetPatch {
		if v == nil {
			return nil
		}
		return v.Budget
	}).(XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput)
}

func (o XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput) MinRetryRate() XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecRetryConstraintPatch) *XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatch {
		if v == nil {
			return nil
		}
		return v.MinRetryRate
	}).(XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput)
}

// SessionPersistence defines and configures session persistence
// for the backend.
//
// Support: Extended
type XBackendTrafficPolicySpecSessionPersistence struct {
	// AbsoluteTimeout defines the absolute timeout of the persistent
	// session. Once the AbsoluteTimeout duration has elapsed, the
	// session becomes invalid.
	//
	// Support: Extended
	AbsoluteTimeout *string                                                  `pulumi:"absoluteTimeout"`
	CookieConfig    *XBackendTrafficPolicySpecSessionPersistenceCookieConfig `pulumi:"cookieConfig"`
	// IdleTimeout defines the idle timeout of the persistent session.
	// Once the session has been idle for more than the specified
	// IdleTimeout duration, the session becomes invalid.
	//
	// Support: Extended
	IdleTimeout *string `pulumi:"idleTimeout"`
	// SessionName defines the name of the persistent session token
	// which may be reflected in the cookie or the header. Users
	// should avoid reusing session names to prevent unintended
	// consequences, such as rejection or unpredictable behavior.
	//
	// Support: Implementation-specific
	SessionName *string `pulumi:"sessionName"`
	// Type defines the type of session persistence such as through
	// the use a header or cookie. Defaults to cookie based session
	// persistence.
	//
	// Support: Core for "Cookie" type
	//
	// Support: Extended for "Header" type
	Type *string `pulumi:"type"`
}

// XBackendTrafficPolicySpecSessionPersistenceInput is an input type that accepts XBackendTrafficPolicySpecSessionPersistenceArgs and XBackendTrafficPolicySpecSessionPersistenceOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecSessionPersistenceInput` via:
//
//	XBackendTrafficPolicySpecSessionPersistenceArgs{...}
type XBackendTrafficPolicySpecSessionPersistenceInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecSessionPersistenceOutput() XBackendTrafficPolicySpecSessionPersistenceOutput
	ToXBackendTrafficPolicySpecSessionPersistenceOutputWithContext(context.Context) XBackendTrafficPolicySpecSessionPersistenceOutput
}

// SessionPersistence defines and configures session persistence
// for the backend.
//
// Support: Extended
type XBackendTrafficPolicySpecSessionPersistenceArgs struct {
	// AbsoluteTimeout defines the absolute timeout of the persistent
	// session. Once the AbsoluteTimeout duration has elapsed, the
	// session becomes invalid.
	//
	// Support: Extended
	AbsoluteTimeout pulumi.StringPtrInput                                           `pulumi:"absoluteTimeout"`
	CookieConfig    XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrInput `pulumi:"cookieConfig"`
	// IdleTimeout defines the idle timeout of the persistent session.
	// Once the session has been idle for more than the specified
	// IdleTimeout duration, the session becomes invalid.
	//
	// Support: Extended
	IdleTimeout pulumi.StringPtrInput `pulumi:"idleTimeout"`
	// SessionName defines the name of the persistent session token
	// which may be reflected in the cookie or the header. Users
	// should avoid reusing session names to prevent unintended
	// consequences, such as rejection or unpredictable behavior.
	//
	// Support: Implementation-specific
	SessionName pulumi.StringPtrInput `pulumi:"sessionName"`
	// Type defines the type of session persistence such as through
	// the use a header or cookie. Defaults to cookie based session
	// persistence.
	//
	// Support: Core for "Cookie" type
	//
	// Support: Extended for "Header" type
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (XBackendTrafficPolicySpecSessionPersistenceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistence)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecSessionPersistenceArgs) ToXBackendTrafficPolicySpecSessionPersistenceOutput() XBackendTrafficPolicySpecSessionPersistenceOutput {
	return i.ToXBackendTrafficPolicySpecSessionPersistenceOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecSessionPersistenceArgs) ToXBackendTrafficPolicySpecSessionPersistenceOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistenceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecSessionPersistenceOutput)
}

func (i XBackendTrafficPolicySpecSessionPersistenceArgs) ToXBackendTrafficPolicySpecSessionPersistencePtrOutput() XBackendTrafficPolicySpecSessionPersistencePtrOutput {
	return i.ToXBackendTrafficPolicySpecSessionPersistencePtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecSessionPersistenceArgs) ToXBackendTrafficPolicySpecSessionPersistencePtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecSessionPersistenceOutput).ToXBackendTrafficPolicySpecSessionPersistencePtrOutputWithContext(ctx)
}

// XBackendTrafficPolicySpecSessionPersistencePtrInput is an input type that accepts XBackendTrafficPolicySpecSessionPersistenceArgs, XBackendTrafficPolicySpecSessionPersistencePtr and XBackendTrafficPolicySpecSessionPersistencePtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecSessionPersistencePtrInput` via:
//
//	        XBackendTrafficPolicySpecSessionPersistenceArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicySpecSessionPersistencePtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecSessionPersistencePtrOutput() XBackendTrafficPolicySpecSessionPersistencePtrOutput
	ToXBackendTrafficPolicySpecSessionPersistencePtrOutputWithContext(context.Context) XBackendTrafficPolicySpecSessionPersistencePtrOutput
}

type xbackendTrafficPolicySpecSessionPersistencePtrType XBackendTrafficPolicySpecSessionPersistenceArgs

func XBackendTrafficPolicySpecSessionPersistencePtr(v *XBackendTrafficPolicySpecSessionPersistenceArgs) XBackendTrafficPolicySpecSessionPersistencePtrInput {
	return (*xbackendTrafficPolicySpecSessionPersistencePtrType)(v)
}

func (*xbackendTrafficPolicySpecSessionPersistencePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecSessionPersistence)(nil)).Elem()
}

func (i *xbackendTrafficPolicySpecSessionPersistencePtrType) ToXBackendTrafficPolicySpecSessionPersistencePtrOutput() XBackendTrafficPolicySpecSessionPersistencePtrOutput {
	return i.ToXBackendTrafficPolicySpecSessionPersistencePtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicySpecSessionPersistencePtrType) ToXBackendTrafficPolicySpecSessionPersistencePtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistencePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecSessionPersistencePtrOutput)
}

// SessionPersistence defines and configures session persistence
// for the backend.
//
// Support: Extended
type XBackendTrafficPolicySpecSessionPersistenceOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecSessionPersistenceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistence)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecSessionPersistenceOutput) ToXBackendTrafficPolicySpecSessionPersistenceOutput() XBackendTrafficPolicySpecSessionPersistenceOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistenceOutput) ToXBackendTrafficPolicySpecSessionPersistenceOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistenceOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistenceOutput) ToXBackendTrafficPolicySpecSessionPersistencePtrOutput() XBackendTrafficPolicySpecSessionPersistencePtrOutput {
	return o.ToXBackendTrafficPolicySpecSessionPersistencePtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicySpecSessionPersistenceOutput) ToXBackendTrafficPolicySpecSessionPersistencePtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistencePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicySpecSessionPersistence) *XBackendTrafficPolicySpecSessionPersistence {
		return &v
	}).(XBackendTrafficPolicySpecSessionPersistencePtrOutput)
}

// AbsoluteTimeout defines the absolute timeout of the persistent
// session. Once the AbsoluteTimeout duration has elapsed, the
// session becomes invalid.
//
// Support: Extended
func (o XBackendTrafficPolicySpecSessionPersistenceOutput) AbsoluteTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecSessionPersistence) *string { return v.AbsoluteTimeout }).(pulumi.StringPtrOutput)
}

func (o XBackendTrafficPolicySpecSessionPersistenceOutput) CookieConfig() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecSessionPersistence) *XBackendTrafficPolicySpecSessionPersistenceCookieConfig {
		return v.CookieConfig
	}).(XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput)
}

// IdleTimeout defines the idle timeout of the persistent session.
// Once the session has been idle for more than the specified
// IdleTimeout duration, the session becomes invalid.
//
// Support: Extended
func (o XBackendTrafficPolicySpecSessionPersistenceOutput) IdleTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecSessionPersistence) *string { return v.IdleTimeout }).(pulumi.StringPtrOutput)
}

// SessionName defines the name of the persistent session token
// which may be reflected in the cookie or the header. Users
// should avoid reusing session names to prevent unintended
// consequences, such as rejection or unpredictable behavior.
//
// Support: Implementation-specific
func (o XBackendTrafficPolicySpecSessionPersistenceOutput) SessionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecSessionPersistence) *string { return v.SessionName }).(pulumi.StringPtrOutput)
}

// Type defines the type of session persistence such as through
// the use a header or cookie. Defaults to cookie based session
// persistence.
//
// Support: Core for "Cookie" type
//
// Support: Extended for "Header" type
func (o XBackendTrafficPolicySpecSessionPersistenceOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecSessionPersistence) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type XBackendTrafficPolicySpecSessionPersistencePtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecSessionPersistencePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecSessionPersistence)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecSessionPersistencePtrOutput) ToXBackendTrafficPolicySpecSessionPersistencePtrOutput() XBackendTrafficPolicySpecSessionPersistencePtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistencePtrOutput) ToXBackendTrafficPolicySpecSessionPersistencePtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistencePtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistencePtrOutput) Elem() XBackendTrafficPolicySpecSessionPersistenceOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistence) XBackendTrafficPolicySpecSessionPersistence {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicySpecSessionPersistence
		return ret
	}).(XBackendTrafficPolicySpecSessionPersistenceOutput)
}

// AbsoluteTimeout defines the absolute timeout of the persistent
// session. Once the AbsoluteTimeout duration has elapsed, the
// session becomes invalid.
//
// Support: Extended
func (o XBackendTrafficPolicySpecSessionPersistencePtrOutput) AbsoluteTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistence) *string {
		if v == nil {
			return nil
		}
		return v.AbsoluteTimeout
	}).(pulumi.StringPtrOutput)
}

func (o XBackendTrafficPolicySpecSessionPersistencePtrOutput) CookieConfig() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistence) *XBackendTrafficPolicySpecSessionPersistenceCookieConfig {
		if v == nil {
			return nil
		}
		return v.CookieConfig
	}).(XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput)
}

// IdleTimeout defines the idle timeout of the persistent session.
// Once the session has been idle for more than the specified
// IdleTimeout duration, the session becomes invalid.
//
// Support: Extended
func (o XBackendTrafficPolicySpecSessionPersistencePtrOutput) IdleTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistence) *string {
		if v == nil {
			return nil
		}
		return v.IdleTimeout
	}).(pulumi.StringPtrOutput)
}

// SessionName defines the name of the persistent session token
// which may be reflected in the cookie or the header. Users
// should avoid reusing session names to prevent unintended
// consequences, such as rejection or unpredictable behavior.
//
// Support: Implementation-specific
func (o XBackendTrafficPolicySpecSessionPersistencePtrOutput) SessionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistence) *string {
		if v == nil {
			return nil
		}
		return v.SessionName
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of session persistence such as through
// the use a header or cookie. Defaults to cookie based session
// persistence.
//
// Support: Core for "Cookie" type
//
// Support: Extended for "Header" type
func (o XBackendTrafficPolicySpecSessionPersistencePtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistence) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// CookieConfig provides configuration settings that are specific
// to cookie-based session persistence.
//
// Support: Core
type XBackendTrafficPolicySpecSessionPersistenceCookieConfig struct {
	// LifetimeType specifies whether the cookie has a permanent or
	// session-based lifetime. A permanent cookie persists until its
	// specified expiry time, defined by the Expires or Max-Age cookie
	// attributes, while a session cookie is deleted when the current
	// session ends.
	//
	// When set to "Permanent", AbsoluteTimeout indicates the
	// cookie's lifetime via the Expires or Max-Age cookie attributes
	// and is required.
	//
	// When set to "Session", AbsoluteTimeout indicates the
	// absolute lifetime of the cookie tracked by the gateway and
	// is optional.
	//
	// Defaults to "Session".
	//
	// Support: Core for "Session" type
	//
	// Support: Extended for "Permanent" type
	LifetimeType *string `pulumi:"lifetimeType"`
}

// XBackendTrafficPolicySpecSessionPersistenceCookieConfigInput is an input type that accepts XBackendTrafficPolicySpecSessionPersistenceCookieConfigArgs and XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecSessionPersistenceCookieConfigInput` via:
//
//	XBackendTrafficPolicySpecSessionPersistenceCookieConfigArgs{...}
type XBackendTrafficPolicySpecSessionPersistenceCookieConfigInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput
	ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigOutputWithContext(context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput
}

// CookieConfig provides configuration settings that are specific
// to cookie-based session persistence.
//
// Support: Core
type XBackendTrafficPolicySpecSessionPersistenceCookieConfigArgs struct {
	// LifetimeType specifies whether the cookie has a permanent or
	// session-based lifetime. A permanent cookie persists until its
	// specified expiry time, defined by the Expires or Max-Age cookie
	// attributes, while a session cookie is deleted when the current
	// session ends.
	//
	// When set to "Permanent", AbsoluteTimeout indicates the
	// cookie's lifetime via the Expires or Max-Age cookie attributes
	// and is required.
	//
	// When set to "Session", AbsoluteTimeout indicates the
	// absolute lifetime of the cookie tracked by the gateway and
	// is optional.
	//
	// Defaults to "Session".
	//
	// Support: Core for "Session" type
	//
	// Support: Extended for "Permanent" type
	LifetimeType pulumi.StringPtrInput `pulumi:"lifetimeType"`
}

func (XBackendTrafficPolicySpecSessionPersistenceCookieConfigArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistenceCookieConfig)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecSessionPersistenceCookieConfigArgs) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput {
	return i.ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecSessionPersistenceCookieConfigArgs) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput)
}

func (i XBackendTrafficPolicySpecSessionPersistenceCookieConfigArgs) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput {
	return i.ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecSessionPersistenceCookieConfigArgs) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput).ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutputWithContext(ctx)
}

// XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrInput is an input type that accepts XBackendTrafficPolicySpecSessionPersistenceCookieConfigArgs, XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtr and XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrInput` via:
//
//	        XBackendTrafficPolicySpecSessionPersistenceCookieConfigArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput
	ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutputWithContext(context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput
}

type xbackendTrafficPolicySpecSessionPersistenceCookieConfigPtrType XBackendTrafficPolicySpecSessionPersistenceCookieConfigArgs

func XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtr(v *XBackendTrafficPolicySpecSessionPersistenceCookieConfigArgs) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrInput {
	return (*xbackendTrafficPolicySpecSessionPersistenceCookieConfigPtrType)(v)
}

func (*xbackendTrafficPolicySpecSessionPersistenceCookieConfigPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecSessionPersistenceCookieConfig)(nil)).Elem()
}

func (i *xbackendTrafficPolicySpecSessionPersistenceCookieConfigPtrType) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput {
	return i.ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicySpecSessionPersistenceCookieConfigPtrType) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput)
}

// CookieConfig provides configuration settings that are specific
// to cookie-based session persistence.
//
// Support: Core
type XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistenceCookieConfig)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput {
	return o.ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicySpecSessionPersistenceCookieConfig) *XBackendTrafficPolicySpecSessionPersistenceCookieConfig {
		return &v
	}).(XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput)
}

// LifetimeType specifies whether the cookie has a permanent or
// session-based lifetime. A permanent cookie persists until its
// specified expiry time, defined by the Expires or Max-Age cookie
// attributes, while a session cookie is deleted when the current
// session ends.
//
// When set to "Permanent", AbsoluteTimeout indicates the
// cookie's lifetime via the Expires or Max-Age cookie attributes
// and is required.
//
// When set to "Session", AbsoluteTimeout indicates the
// absolute lifetime of the cookie tracked by the gateway and
// is optional.
//
// Defaults to "Session".
//
// Support: Core for "Session" type
//
// Support: Extended for "Permanent" type
func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput) LifetimeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecSessionPersistenceCookieConfig) *string { return v.LifetimeType }).(pulumi.StringPtrOutput)
}

type XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecSessionPersistenceCookieConfig)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput) Elem() XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistenceCookieConfig) XBackendTrafficPolicySpecSessionPersistenceCookieConfig {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicySpecSessionPersistenceCookieConfig
		return ret
	}).(XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput)
}

// LifetimeType specifies whether the cookie has a permanent or
// session-based lifetime. A permanent cookie persists until its
// specified expiry time, defined by the Expires or Max-Age cookie
// attributes, while a session cookie is deleted when the current
// session ends.
//
// When set to "Permanent", AbsoluteTimeout indicates the
// cookie's lifetime via the Expires or Max-Age cookie attributes
// and is required.
//
// When set to "Session", AbsoluteTimeout indicates the
// absolute lifetime of the cookie tracked by the gateway and
// is optional.
//
// Defaults to "Session".
//
// Support: Core for "Session" type
//
// Support: Extended for "Permanent" type
func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput) LifetimeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistenceCookieConfig) *string {
		if v == nil {
			return nil
		}
		return v.LifetimeType
	}).(pulumi.StringPtrOutput)
}

// CookieConfig provides configuration settings that are specific
// to cookie-based session persistence.
//
// Support: Core
type XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch struct {
	// LifetimeType specifies whether the cookie has a permanent or
	// session-based lifetime. A permanent cookie persists until its
	// specified expiry time, defined by the Expires or Max-Age cookie
	// attributes, while a session cookie is deleted when the current
	// session ends.
	//
	// When set to "Permanent", AbsoluteTimeout indicates the
	// cookie's lifetime via the Expires or Max-Age cookie attributes
	// and is required.
	//
	// When set to "Session", AbsoluteTimeout indicates the
	// absolute lifetime of the cookie tracked by the gateway and
	// is optional.
	//
	// Defaults to "Session".
	//
	// Support: Core for "Session" type
	//
	// Support: Extended for "Permanent" type
	LifetimeType *string `pulumi:"lifetimeType"`
}

// XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchInput is an input type that accepts XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchArgs and XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchInput` via:
//
//	XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchArgs{...}
type XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput
	ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutputWithContext(context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput
}

// CookieConfig provides configuration settings that are specific
// to cookie-based session persistence.
//
// Support: Core
type XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchArgs struct {
	// LifetimeType specifies whether the cookie has a permanent or
	// session-based lifetime. A permanent cookie persists until its
	// specified expiry time, defined by the Expires or Max-Age cookie
	// attributes, while a session cookie is deleted when the current
	// session ends.
	//
	// When set to "Permanent", AbsoluteTimeout indicates the
	// cookie's lifetime via the Expires or Max-Age cookie attributes
	// and is required.
	//
	// When set to "Session", AbsoluteTimeout indicates the
	// absolute lifetime of the cookie tracked by the gateway and
	// is optional.
	//
	// Defaults to "Session".
	//
	// Support: Core for "Session" type
	//
	// Support: Extended for "Permanent" type
	LifetimeType pulumi.StringPtrInput `pulumi:"lifetimeType"`
}

func (XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchArgs) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput {
	return i.ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchArgs) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput)
}

func (i XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchArgs) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput {
	return i.ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchArgs) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput).ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutputWithContext(ctx)
}

// XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrInput is an input type that accepts XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchArgs, XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtr and XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrInput` via:
//
//	        XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput
	ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutputWithContext(context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput
}

type xbackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrType XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchArgs

func XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtr(v *XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchArgs) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrInput {
	return (*xbackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrType)(v)
}

func (*xbackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch)(nil)).Elem()
}

func (i *xbackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrType) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput {
	return i.ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrType) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput)
}

// CookieConfig provides configuration settings that are specific
// to cookie-based session persistence.
//
// Support: Core
type XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput {
	return o.ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch) *XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch {
		return &v
	}).(XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput)
}

// LifetimeType specifies whether the cookie has a permanent or
// session-based lifetime. A permanent cookie persists until its
// specified expiry time, defined by the Expires or Max-Age cookie
// attributes, while a session cookie is deleted when the current
// session ends.
//
// When set to "Permanent", AbsoluteTimeout indicates the
// cookie's lifetime via the Expires or Max-Age cookie attributes
// and is required.
//
// When set to "Session", AbsoluteTimeout indicates the
// absolute lifetime of the cookie tracked by the gateway and
// is optional.
//
// Defaults to "Session".
//
// Support: Core for "Session" type
//
// Support: Extended for "Permanent" type
func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput) LifetimeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch) *string { return v.LifetimeType }).(pulumi.StringPtrOutput)
}

type XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput) ToXBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput) Elem() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch) XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch
		return ret
	}).(XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput)
}

// LifetimeType specifies whether the cookie has a permanent or
// session-based lifetime. A permanent cookie persists until its
// specified expiry time, defined by the Expires or Max-Age cookie
// attributes, while a session cookie is deleted when the current
// session ends.
//
// When set to "Permanent", AbsoluteTimeout indicates the
// cookie's lifetime via the Expires or Max-Age cookie attributes
// and is required.
//
// When set to "Session", AbsoluteTimeout indicates the
// absolute lifetime of the cookie tracked by the gateway and
// is optional.
//
// Defaults to "Session".
//
// Support: Core for "Session" type
//
// Support: Extended for "Permanent" type
func (o XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput) LifetimeType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch) *string {
		if v == nil {
			return nil
		}
		return v.LifetimeType
	}).(pulumi.StringPtrOutput)
}

// SessionPersistence defines and configures session persistence
// for the backend.
//
// Support: Extended
type XBackendTrafficPolicySpecSessionPersistencePatch struct {
	// AbsoluteTimeout defines the absolute timeout of the persistent
	// session. Once the AbsoluteTimeout duration has elapsed, the
	// session becomes invalid.
	//
	// Support: Extended
	AbsoluteTimeout *string                                                       `pulumi:"absoluteTimeout"`
	CookieConfig    *XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch `pulumi:"cookieConfig"`
	// IdleTimeout defines the idle timeout of the persistent session.
	// Once the session has been idle for more than the specified
	// IdleTimeout duration, the session becomes invalid.
	//
	// Support: Extended
	IdleTimeout *string `pulumi:"idleTimeout"`
	// SessionName defines the name of the persistent session token
	// which may be reflected in the cookie or the header. Users
	// should avoid reusing session names to prevent unintended
	// consequences, such as rejection or unpredictable behavior.
	//
	// Support: Implementation-specific
	SessionName *string `pulumi:"sessionName"`
	// Type defines the type of session persistence such as through
	// the use a header or cookie. Defaults to cookie based session
	// persistence.
	//
	// Support: Core for "Cookie" type
	//
	// Support: Extended for "Header" type
	Type *string `pulumi:"type"`
}

// XBackendTrafficPolicySpecSessionPersistencePatchInput is an input type that accepts XBackendTrafficPolicySpecSessionPersistencePatchArgs and XBackendTrafficPolicySpecSessionPersistencePatchOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecSessionPersistencePatchInput` via:
//
//	XBackendTrafficPolicySpecSessionPersistencePatchArgs{...}
type XBackendTrafficPolicySpecSessionPersistencePatchInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecSessionPersistencePatchOutput() XBackendTrafficPolicySpecSessionPersistencePatchOutput
	ToXBackendTrafficPolicySpecSessionPersistencePatchOutputWithContext(context.Context) XBackendTrafficPolicySpecSessionPersistencePatchOutput
}

// SessionPersistence defines and configures session persistence
// for the backend.
//
// Support: Extended
type XBackendTrafficPolicySpecSessionPersistencePatchArgs struct {
	// AbsoluteTimeout defines the absolute timeout of the persistent
	// session. Once the AbsoluteTimeout duration has elapsed, the
	// session becomes invalid.
	//
	// Support: Extended
	AbsoluteTimeout pulumi.StringPtrInput                                                `pulumi:"absoluteTimeout"`
	CookieConfig    XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrInput `pulumi:"cookieConfig"`
	// IdleTimeout defines the idle timeout of the persistent session.
	// Once the session has been idle for more than the specified
	// IdleTimeout duration, the session becomes invalid.
	//
	// Support: Extended
	IdleTimeout pulumi.StringPtrInput `pulumi:"idleTimeout"`
	// SessionName defines the name of the persistent session token
	// which may be reflected in the cookie or the header. Users
	// should avoid reusing session names to prevent unintended
	// consequences, such as rejection or unpredictable behavior.
	//
	// Support: Implementation-specific
	SessionName pulumi.StringPtrInput `pulumi:"sessionName"`
	// Type defines the type of session persistence such as through
	// the use a header or cookie. Defaults to cookie based session
	// persistence.
	//
	// Support: Core for "Cookie" type
	//
	// Support: Extended for "Header" type
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (XBackendTrafficPolicySpecSessionPersistencePatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistencePatch)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecSessionPersistencePatchArgs) ToXBackendTrafficPolicySpecSessionPersistencePatchOutput() XBackendTrafficPolicySpecSessionPersistencePatchOutput {
	return i.ToXBackendTrafficPolicySpecSessionPersistencePatchOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecSessionPersistencePatchArgs) ToXBackendTrafficPolicySpecSessionPersistencePatchOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistencePatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecSessionPersistencePatchOutput)
}

func (i XBackendTrafficPolicySpecSessionPersistencePatchArgs) ToXBackendTrafficPolicySpecSessionPersistencePatchPtrOutput() XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput {
	return i.ToXBackendTrafficPolicySpecSessionPersistencePatchPtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecSessionPersistencePatchArgs) ToXBackendTrafficPolicySpecSessionPersistencePatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecSessionPersistencePatchOutput).ToXBackendTrafficPolicySpecSessionPersistencePatchPtrOutputWithContext(ctx)
}

// XBackendTrafficPolicySpecSessionPersistencePatchPtrInput is an input type that accepts XBackendTrafficPolicySpecSessionPersistencePatchArgs, XBackendTrafficPolicySpecSessionPersistencePatchPtr and XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecSessionPersistencePatchPtrInput` via:
//
//	        XBackendTrafficPolicySpecSessionPersistencePatchArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicySpecSessionPersistencePatchPtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecSessionPersistencePatchPtrOutput() XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput
	ToXBackendTrafficPolicySpecSessionPersistencePatchPtrOutputWithContext(context.Context) XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput
}

type xbackendTrafficPolicySpecSessionPersistencePatchPtrType XBackendTrafficPolicySpecSessionPersistencePatchArgs

func XBackendTrafficPolicySpecSessionPersistencePatchPtr(v *XBackendTrafficPolicySpecSessionPersistencePatchArgs) XBackendTrafficPolicySpecSessionPersistencePatchPtrInput {
	return (*xbackendTrafficPolicySpecSessionPersistencePatchPtrType)(v)
}

func (*xbackendTrafficPolicySpecSessionPersistencePatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecSessionPersistencePatch)(nil)).Elem()
}

func (i *xbackendTrafficPolicySpecSessionPersistencePatchPtrType) ToXBackendTrafficPolicySpecSessionPersistencePatchPtrOutput() XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput {
	return i.ToXBackendTrafficPolicySpecSessionPersistencePatchPtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicySpecSessionPersistencePatchPtrType) ToXBackendTrafficPolicySpecSessionPersistencePatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput)
}

// SessionPersistence defines and configures session persistence
// for the backend.
//
// Support: Extended
type XBackendTrafficPolicySpecSessionPersistencePatchOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecSessionPersistencePatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistencePatch)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecSessionPersistencePatchOutput) ToXBackendTrafficPolicySpecSessionPersistencePatchOutput() XBackendTrafficPolicySpecSessionPersistencePatchOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistencePatchOutput) ToXBackendTrafficPolicySpecSessionPersistencePatchOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistencePatchOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistencePatchOutput) ToXBackendTrafficPolicySpecSessionPersistencePatchPtrOutput() XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput {
	return o.ToXBackendTrafficPolicySpecSessionPersistencePatchPtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicySpecSessionPersistencePatchOutput) ToXBackendTrafficPolicySpecSessionPersistencePatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicySpecSessionPersistencePatch) *XBackendTrafficPolicySpecSessionPersistencePatch {
		return &v
	}).(XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput)
}

// AbsoluteTimeout defines the absolute timeout of the persistent
// session. Once the AbsoluteTimeout duration has elapsed, the
// session becomes invalid.
//
// Support: Extended
func (o XBackendTrafficPolicySpecSessionPersistencePatchOutput) AbsoluteTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecSessionPersistencePatch) *string { return v.AbsoluteTimeout }).(pulumi.StringPtrOutput)
}

func (o XBackendTrafficPolicySpecSessionPersistencePatchOutput) CookieConfig() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecSessionPersistencePatch) *XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch {
		return v.CookieConfig
	}).(XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput)
}

// IdleTimeout defines the idle timeout of the persistent session.
// Once the session has been idle for more than the specified
// IdleTimeout duration, the session becomes invalid.
//
// Support: Extended
func (o XBackendTrafficPolicySpecSessionPersistencePatchOutput) IdleTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecSessionPersistencePatch) *string { return v.IdleTimeout }).(pulumi.StringPtrOutput)
}

// SessionName defines the name of the persistent session token
// which may be reflected in the cookie or the header. Users
// should avoid reusing session names to prevent unintended
// consequences, such as rejection or unpredictable behavior.
//
// Support: Implementation-specific
func (o XBackendTrafficPolicySpecSessionPersistencePatchOutput) SessionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecSessionPersistencePatch) *string { return v.SessionName }).(pulumi.StringPtrOutput)
}

// Type defines the type of session persistence such as through
// the use a header or cookie. Defaults to cookie based session
// persistence.
//
// Support: Core for "Cookie" type
//
// Support: Extended for "Header" type
func (o XBackendTrafficPolicySpecSessionPersistencePatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecSessionPersistencePatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicySpecSessionPersistencePatch)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput) ToXBackendTrafficPolicySpecSessionPersistencePatchPtrOutput() XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput) ToXBackendTrafficPolicySpecSessionPersistencePatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput) Elem() XBackendTrafficPolicySpecSessionPersistencePatchOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistencePatch) XBackendTrafficPolicySpecSessionPersistencePatch {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicySpecSessionPersistencePatch
		return ret
	}).(XBackendTrafficPolicySpecSessionPersistencePatchOutput)
}

// AbsoluteTimeout defines the absolute timeout of the persistent
// session. Once the AbsoluteTimeout duration has elapsed, the
// session becomes invalid.
//
// Support: Extended
func (o XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput) AbsoluteTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistencePatch) *string {
		if v == nil {
			return nil
		}
		return v.AbsoluteTimeout
	}).(pulumi.StringPtrOutput)
}

func (o XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput) CookieConfig() XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistencePatch) *XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatch {
		if v == nil {
			return nil
		}
		return v.CookieConfig
	}).(XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput)
}

// IdleTimeout defines the idle timeout of the persistent session.
// Once the session has been idle for more than the specified
// IdleTimeout duration, the session becomes invalid.
//
// Support: Extended
func (o XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput) IdleTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistencePatch) *string {
		if v == nil {
			return nil
		}
		return v.IdleTimeout
	}).(pulumi.StringPtrOutput)
}

// SessionName defines the name of the persistent session token
// which may be reflected in the cookie or the header. Users
// should avoid reusing session names to prevent unintended
// consequences, such as rejection or unpredictable behavior.
//
// Support: Implementation-specific
func (o XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput) SessionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistencePatch) *string {
		if v == nil {
			return nil
		}
		return v.SessionName
	}).(pulumi.StringPtrOutput)
}

// Type defines the type of session persistence such as through
// the use a header or cookie. Defaults to cookie based session
// persistence.
//
// Support: Core for "Cookie" type
//
// Support: Extended for "Header" type
func (o XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicySpecSessionPersistencePatch) *string {
		if v == nil {
			return nil
		}
		return v.Type
	}).(pulumi.StringPtrOutput)
}

// LocalPolicyTargetReference identifies an API object to apply a direct or
// inherited policy to. This should be used as part of Policy resources
// that can target Gateway API resources. For more information on how this
// policy attachment model works, and a sample Policy resource, refer to
// the policy attachment documentation for Gateway API.
type XBackendTrafficPolicySpecTargetRefs struct {
	// Group is the group of the target resource.
	Group *string `pulumi:"group"`
	// Kind is kind of the target resource.
	Kind *string `pulumi:"kind"`
	// Name is the name of the target resource.
	Name *string `pulumi:"name"`
}

// XBackendTrafficPolicySpecTargetRefsInput is an input type that accepts XBackendTrafficPolicySpecTargetRefsArgs and XBackendTrafficPolicySpecTargetRefsOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecTargetRefsInput` via:
//
//	XBackendTrafficPolicySpecTargetRefsArgs{...}
type XBackendTrafficPolicySpecTargetRefsInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecTargetRefsOutput() XBackendTrafficPolicySpecTargetRefsOutput
	ToXBackendTrafficPolicySpecTargetRefsOutputWithContext(context.Context) XBackendTrafficPolicySpecTargetRefsOutput
}

// LocalPolicyTargetReference identifies an API object to apply a direct or
// inherited policy to. This should be used as part of Policy resources
// that can target Gateway API resources. For more information on how this
// policy attachment model works, and a sample Policy resource, refer to
// the policy attachment documentation for Gateway API.
type XBackendTrafficPolicySpecTargetRefsArgs struct {
	// Group is the group of the target resource.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the target resource.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the target resource.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (XBackendTrafficPolicySpecTargetRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecTargetRefs)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecTargetRefsArgs) ToXBackendTrafficPolicySpecTargetRefsOutput() XBackendTrafficPolicySpecTargetRefsOutput {
	return i.ToXBackendTrafficPolicySpecTargetRefsOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecTargetRefsArgs) ToXBackendTrafficPolicySpecTargetRefsOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecTargetRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecTargetRefsOutput)
}

// XBackendTrafficPolicySpecTargetRefsArrayInput is an input type that accepts XBackendTrafficPolicySpecTargetRefsArray and XBackendTrafficPolicySpecTargetRefsArrayOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecTargetRefsArrayInput` via:
//
//	XBackendTrafficPolicySpecTargetRefsArray{ XBackendTrafficPolicySpecTargetRefsArgs{...} }
type XBackendTrafficPolicySpecTargetRefsArrayInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecTargetRefsArrayOutput() XBackendTrafficPolicySpecTargetRefsArrayOutput
	ToXBackendTrafficPolicySpecTargetRefsArrayOutputWithContext(context.Context) XBackendTrafficPolicySpecTargetRefsArrayOutput
}

type XBackendTrafficPolicySpecTargetRefsArray []XBackendTrafficPolicySpecTargetRefsInput

func (XBackendTrafficPolicySpecTargetRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XBackendTrafficPolicySpecTargetRefs)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecTargetRefsArray) ToXBackendTrafficPolicySpecTargetRefsArrayOutput() XBackendTrafficPolicySpecTargetRefsArrayOutput {
	return i.ToXBackendTrafficPolicySpecTargetRefsArrayOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecTargetRefsArray) ToXBackendTrafficPolicySpecTargetRefsArrayOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecTargetRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecTargetRefsArrayOutput)
}

// LocalPolicyTargetReference identifies an API object to apply a direct or
// inherited policy to. This should be used as part of Policy resources
// that can target Gateway API resources. For more information on how this
// policy attachment model works, and a sample Policy resource, refer to
// the policy attachment documentation for Gateway API.
type XBackendTrafficPolicySpecTargetRefsOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecTargetRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecTargetRefs)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecTargetRefsOutput) ToXBackendTrafficPolicySpecTargetRefsOutput() XBackendTrafficPolicySpecTargetRefsOutput {
	return o
}

func (o XBackendTrafficPolicySpecTargetRefsOutput) ToXBackendTrafficPolicySpecTargetRefsOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecTargetRefsOutput {
	return o
}

// Group is the group of the target resource.
func (o XBackendTrafficPolicySpecTargetRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecTargetRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the target resource.
func (o XBackendTrafficPolicySpecTargetRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecTargetRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the target resource.
func (o XBackendTrafficPolicySpecTargetRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecTargetRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type XBackendTrafficPolicySpecTargetRefsArrayOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecTargetRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XBackendTrafficPolicySpecTargetRefs)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecTargetRefsArrayOutput) ToXBackendTrafficPolicySpecTargetRefsArrayOutput() XBackendTrafficPolicySpecTargetRefsArrayOutput {
	return o
}

func (o XBackendTrafficPolicySpecTargetRefsArrayOutput) ToXBackendTrafficPolicySpecTargetRefsArrayOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecTargetRefsArrayOutput {
	return o
}

func (o XBackendTrafficPolicySpecTargetRefsArrayOutput) Index(i pulumi.IntInput) XBackendTrafficPolicySpecTargetRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XBackendTrafficPolicySpecTargetRefs {
		return vs[0].([]XBackendTrafficPolicySpecTargetRefs)[vs[1].(int)]
	}).(XBackendTrafficPolicySpecTargetRefsOutput)
}

// LocalPolicyTargetReference identifies an API object to apply a direct or
// inherited policy to. This should be used as part of Policy resources
// that can target Gateway API resources. For more information on how this
// policy attachment model works, and a sample Policy resource, refer to
// the policy attachment documentation for Gateway API.
type XBackendTrafficPolicySpecTargetRefsPatch struct {
	// Group is the group of the target resource.
	Group *string `pulumi:"group"`
	// Kind is kind of the target resource.
	Kind *string `pulumi:"kind"`
	// Name is the name of the target resource.
	Name *string `pulumi:"name"`
}

// XBackendTrafficPolicySpecTargetRefsPatchInput is an input type that accepts XBackendTrafficPolicySpecTargetRefsPatchArgs and XBackendTrafficPolicySpecTargetRefsPatchOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecTargetRefsPatchInput` via:
//
//	XBackendTrafficPolicySpecTargetRefsPatchArgs{...}
type XBackendTrafficPolicySpecTargetRefsPatchInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecTargetRefsPatchOutput() XBackendTrafficPolicySpecTargetRefsPatchOutput
	ToXBackendTrafficPolicySpecTargetRefsPatchOutputWithContext(context.Context) XBackendTrafficPolicySpecTargetRefsPatchOutput
}

// LocalPolicyTargetReference identifies an API object to apply a direct or
// inherited policy to. This should be used as part of Policy resources
// that can target Gateway API resources. For more information on how this
// policy attachment model works, and a sample Policy resource, refer to
// the policy attachment documentation for Gateway API.
type XBackendTrafficPolicySpecTargetRefsPatchArgs struct {
	// Group is the group of the target resource.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the target resource.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the target resource.
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (XBackendTrafficPolicySpecTargetRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecTargetRefsPatch)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecTargetRefsPatchArgs) ToXBackendTrafficPolicySpecTargetRefsPatchOutput() XBackendTrafficPolicySpecTargetRefsPatchOutput {
	return i.ToXBackendTrafficPolicySpecTargetRefsPatchOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecTargetRefsPatchArgs) ToXBackendTrafficPolicySpecTargetRefsPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecTargetRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecTargetRefsPatchOutput)
}

// XBackendTrafficPolicySpecTargetRefsPatchArrayInput is an input type that accepts XBackendTrafficPolicySpecTargetRefsPatchArray and XBackendTrafficPolicySpecTargetRefsPatchArrayOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicySpecTargetRefsPatchArrayInput` via:
//
//	XBackendTrafficPolicySpecTargetRefsPatchArray{ XBackendTrafficPolicySpecTargetRefsPatchArgs{...} }
type XBackendTrafficPolicySpecTargetRefsPatchArrayInput interface {
	pulumi.Input

	ToXBackendTrafficPolicySpecTargetRefsPatchArrayOutput() XBackendTrafficPolicySpecTargetRefsPatchArrayOutput
	ToXBackendTrafficPolicySpecTargetRefsPatchArrayOutputWithContext(context.Context) XBackendTrafficPolicySpecTargetRefsPatchArrayOutput
}

type XBackendTrafficPolicySpecTargetRefsPatchArray []XBackendTrafficPolicySpecTargetRefsPatchInput

func (XBackendTrafficPolicySpecTargetRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XBackendTrafficPolicySpecTargetRefsPatch)(nil)).Elem()
}

func (i XBackendTrafficPolicySpecTargetRefsPatchArray) ToXBackendTrafficPolicySpecTargetRefsPatchArrayOutput() XBackendTrafficPolicySpecTargetRefsPatchArrayOutput {
	return i.ToXBackendTrafficPolicySpecTargetRefsPatchArrayOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicySpecTargetRefsPatchArray) ToXBackendTrafficPolicySpecTargetRefsPatchArrayOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecTargetRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicySpecTargetRefsPatchArrayOutput)
}

// LocalPolicyTargetReference identifies an API object to apply a direct or
// inherited policy to. This should be used as part of Policy resources
// that can target Gateway API resources. For more information on how this
// policy attachment model works, and a sample Policy resource, refer to
// the policy attachment documentation for Gateway API.
type XBackendTrafficPolicySpecTargetRefsPatchOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecTargetRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicySpecTargetRefsPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecTargetRefsPatchOutput) ToXBackendTrafficPolicySpecTargetRefsPatchOutput() XBackendTrafficPolicySpecTargetRefsPatchOutput {
	return o
}

func (o XBackendTrafficPolicySpecTargetRefsPatchOutput) ToXBackendTrafficPolicySpecTargetRefsPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecTargetRefsPatchOutput {
	return o
}

// Group is the group of the target resource.
func (o XBackendTrafficPolicySpecTargetRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecTargetRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the target resource.
func (o XBackendTrafficPolicySpecTargetRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecTargetRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the target resource.
func (o XBackendTrafficPolicySpecTargetRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicySpecTargetRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type XBackendTrafficPolicySpecTargetRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicySpecTargetRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XBackendTrafficPolicySpecTargetRefsPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicySpecTargetRefsPatchArrayOutput) ToXBackendTrafficPolicySpecTargetRefsPatchArrayOutput() XBackendTrafficPolicySpecTargetRefsPatchArrayOutput {
	return o
}

func (o XBackendTrafficPolicySpecTargetRefsPatchArrayOutput) ToXBackendTrafficPolicySpecTargetRefsPatchArrayOutputWithContext(ctx context.Context) XBackendTrafficPolicySpecTargetRefsPatchArrayOutput {
	return o
}

func (o XBackendTrafficPolicySpecTargetRefsPatchArrayOutput) Index(i pulumi.IntInput) XBackendTrafficPolicySpecTargetRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XBackendTrafficPolicySpecTargetRefsPatch {
		return vs[0].([]XBackendTrafficPolicySpecTargetRefsPatch)[vs[1].(int)]
	}).(XBackendTrafficPolicySpecTargetRefsPatchOutput)
}

// Status defines the current state of BackendTrafficPolicy.
type XBackendTrafficPolicyStatus struct {
	// Ancestors is a list of ancestor resources (usually Gateways) that are
	// associated with the policy, and the status of the policy with respect to
	// each ancestor. When this policy attaches to a parent, the controller that
	// manages the parent and the ancestors MUST add an entry to this list when
	// the controller first sees the policy and SHOULD update the entry as
	// appropriate when the relevant ancestor is modified.
	//
	// Note that choosing the relevant ancestor is left to the Policy designers;
	// an important part of Policy design is designing the right object level at
	// which to namespace this status.
	//
	// Note also that implementations MUST ONLY populate ancestor status for
	// the Ancestor resources they are responsible for. Implementations MUST
	// use the ControllerName field to uniquely identify the entries in this list
	// that they are responsible for.
	//
	// Note that to achieve this, the list of PolicyAncestorStatus structs
	// MUST be treated as a map with a composite key, made up of the AncestorRef
	// and ControllerName fields combined.
	//
	// A maximum of 16 ancestors will be represented in this list. An empty list
	// means the Policy is not relevant for any ancestors.
	//
	// If this slice is full, implementations MUST NOT add further entries.
	// Instead they MUST consider the policy unimplementable and signal that
	// on any related resources such as the ancestor that would be referenced
	// here. For example, if this list was full on BackendTLSPolicy, no
	// additional Gateways would be able to reference the Service targeted by
	// the BackendTLSPolicy.
	Ancestors []XBackendTrafficPolicyStatusAncestors `pulumi:"ancestors"`
}

// XBackendTrafficPolicyStatusInput is an input type that accepts XBackendTrafficPolicyStatusArgs and XBackendTrafficPolicyStatusOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusInput` via:
//
//	XBackendTrafficPolicyStatusArgs{...}
type XBackendTrafficPolicyStatusInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusOutput() XBackendTrafficPolicyStatusOutput
	ToXBackendTrafficPolicyStatusOutputWithContext(context.Context) XBackendTrafficPolicyStatusOutput
}

// Status defines the current state of BackendTrafficPolicy.
type XBackendTrafficPolicyStatusArgs struct {
	// Ancestors is a list of ancestor resources (usually Gateways) that are
	// associated with the policy, and the status of the policy with respect to
	// each ancestor. When this policy attaches to a parent, the controller that
	// manages the parent and the ancestors MUST add an entry to this list when
	// the controller first sees the policy and SHOULD update the entry as
	// appropriate when the relevant ancestor is modified.
	//
	// Note that choosing the relevant ancestor is left to the Policy designers;
	// an important part of Policy design is designing the right object level at
	// which to namespace this status.
	//
	// Note also that implementations MUST ONLY populate ancestor status for
	// the Ancestor resources they are responsible for. Implementations MUST
	// use the ControllerName field to uniquely identify the entries in this list
	// that they are responsible for.
	//
	// Note that to achieve this, the list of PolicyAncestorStatus structs
	// MUST be treated as a map with a composite key, made up of the AncestorRef
	// and ControllerName fields combined.
	//
	// A maximum of 16 ancestors will be represented in this list. An empty list
	// means the Policy is not relevant for any ancestors.
	//
	// If this slice is full, implementations MUST NOT add further entries.
	// Instead they MUST consider the policy unimplementable and signal that
	// on any related resources such as the ancestor that would be referenced
	// here. For example, if this list was full on BackendTLSPolicy, no
	// additional Gateways would be able to reference the Service targeted by
	// the BackendTLSPolicy.
	Ancestors XBackendTrafficPolicyStatusAncestorsArrayInput `pulumi:"ancestors"`
}

func (XBackendTrafficPolicyStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatus)(nil)).Elem()
}

func (i XBackendTrafficPolicyStatusArgs) ToXBackendTrafficPolicyStatusOutput() XBackendTrafficPolicyStatusOutput {
	return i.ToXBackendTrafficPolicyStatusOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusArgs) ToXBackendTrafficPolicyStatusOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusOutput)
}

func (i XBackendTrafficPolicyStatusArgs) ToXBackendTrafficPolicyStatusPtrOutput() XBackendTrafficPolicyStatusPtrOutput {
	return i.ToXBackendTrafficPolicyStatusPtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusArgs) ToXBackendTrafficPolicyStatusPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusOutput).ToXBackendTrafficPolicyStatusPtrOutputWithContext(ctx)
}

// XBackendTrafficPolicyStatusPtrInput is an input type that accepts XBackendTrafficPolicyStatusArgs, XBackendTrafficPolicyStatusPtr and XBackendTrafficPolicyStatusPtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusPtrInput` via:
//
//	        XBackendTrafficPolicyStatusArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicyStatusPtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusPtrOutput() XBackendTrafficPolicyStatusPtrOutput
	ToXBackendTrafficPolicyStatusPtrOutputWithContext(context.Context) XBackendTrafficPolicyStatusPtrOutput
}

type xbackendTrafficPolicyStatusPtrType XBackendTrafficPolicyStatusArgs

func XBackendTrafficPolicyStatusPtr(v *XBackendTrafficPolicyStatusArgs) XBackendTrafficPolicyStatusPtrInput {
	return (*xbackendTrafficPolicyStatusPtrType)(v)
}

func (*xbackendTrafficPolicyStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicyStatus)(nil)).Elem()
}

func (i *xbackendTrafficPolicyStatusPtrType) ToXBackendTrafficPolicyStatusPtrOutput() XBackendTrafficPolicyStatusPtrOutput {
	return i.ToXBackendTrafficPolicyStatusPtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicyStatusPtrType) ToXBackendTrafficPolicyStatusPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusPtrOutput)
}

// Status defines the current state of BackendTrafficPolicy.
type XBackendTrafficPolicyStatusOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatus)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusOutput) ToXBackendTrafficPolicyStatusOutput() XBackendTrafficPolicyStatusOutput {
	return o
}

func (o XBackendTrafficPolicyStatusOutput) ToXBackendTrafficPolicyStatusOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusOutput {
	return o
}

func (o XBackendTrafficPolicyStatusOutput) ToXBackendTrafficPolicyStatusPtrOutput() XBackendTrafficPolicyStatusPtrOutput {
	return o.ToXBackendTrafficPolicyStatusPtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicyStatusOutput) ToXBackendTrafficPolicyStatusPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicyStatus) *XBackendTrafficPolicyStatus {
		return &v
	}).(XBackendTrafficPolicyStatusPtrOutput)
}

// Ancestors is a list of ancestor resources (usually Gateways) that are
// associated with the policy, and the status of the policy with respect to
// each ancestor. When this policy attaches to a parent, the controller that
// manages the parent and the ancestors MUST add an entry to this list when
// the controller first sees the policy and SHOULD update the entry as
// appropriate when the relevant ancestor is modified.
//
// Note that choosing the relevant ancestor is left to the Policy designers;
// an important part of Policy design is designing the right object level at
// which to namespace this status.
//
// Note also that implementations MUST ONLY populate ancestor status for
// the Ancestor resources they are responsible for. Implementations MUST
// use the ControllerName field to uniquely identify the entries in this list
// that they are responsible for.
//
// Note that to achieve this, the list of PolicyAncestorStatus structs
// MUST be treated as a map with a composite key, made up of the AncestorRef
// and ControllerName fields combined.
//
// A maximum of 16 ancestors will be represented in this list. An empty list
// means the Policy is not relevant for any ancestors.
//
// If this slice is full, implementations MUST NOT add further entries.
// Instead they MUST consider the policy unimplementable and signal that
// on any related resources such as the ancestor that would be referenced
// here. For example, if this list was full on BackendTLSPolicy, no
// additional Gateways would be able to reference the Service targeted by
// the BackendTLSPolicy.
func (o XBackendTrafficPolicyStatusOutput) Ancestors() XBackendTrafficPolicyStatusAncestorsArrayOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatus) []XBackendTrafficPolicyStatusAncestors { return v.Ancestors }).(XBackendTrafficPolicyStatusAncestorsArrayOutput)
}

type XBackendTrafficPolicyStatusPtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicyStatus)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusPtrOutput) ToXBackendTrafficPolicyStatusPtrOutput() XBackendTrafficPolicyStatusPtrOutput {
	return o
}

func (o XBackendTrafficPolicyStatusPtrOutput) ToXBackendTrafficPolicyStatusPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusPtrOutput {
	return o
}

func (o XBackendTrafficPolicyStatusPtrOutput) Elem() XBackendTrafficPolicyStatusOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatus) XBackendTrafficPolicyStatus {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicyStatus
		return ret
	}).(XBackendTrafficPolicyStatusOutput)
}

// Ancestors is a list of ancestor resources (usually Gateways) that are
// associated with the policy, and the status of the policy with respect to
// each ancestor. When this policy attaches to a parent, the controller that
// manages the parent and the ancestors MUST add an entry to this list when
// the controller first sees the policy and SHOULD update the entry as
// appropriate when the relevant ancestor is modified.
//
// Note that choosing the relevant ancestor is left to the Policy designers;
// an important part of Policy design is designing the right object level at
// which to namespace this status.
//
// Note also that implementations MUST ONLY populate ancestor status for
// the Ancestor resources they are responsible for. Implementations MUST
// use the ControllerName field to uniquely identify the entries in this list
// that they are responsible for.
//
// Note that to achieve this, the list of PolicyAncestorStatus structs
// MUST be treated as a map with a composite key, made up of the AncestorRef
// and ControllerName fields combined.
//
// A maximum of 16 ancestors will be represented in this list. An empty list
// means the Policy is not relevant for any ancestors.
//
// If this slice is full, implementations MUST NOT add further entries.
// Instead they MUST consider the policy unimplementable and signal that
// on any related resources such as the ancestor that would be referenced
// here. For example, if this list was full on BackendTLSPolicy, no
// additional Gateways would be able to reference the Service targeted by
// the BackendTLSPolicy.
func (o XBackendTrafficPolicyStatusPtrOutput) Ancestors() XBackendTrafficPolicyStatusAncestorsArrayOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatus) []XBackendTrafficPolicyStatusAncestors {
		if v == nil {
			return nil
		}
		return v.Ancestors
	}).(XBackendTrafficPolicyStatusAncestorsArrayOutput)
}

// PolicyAncestorStatus describes the status of a route with respect to an
// associated Ancestor.
//
// Ancestors refer to objects that are either the Target of a policy or above it
// in terms of object hierarchy. For example, if a policy targets a Service, the
// Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
// the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
// useful object to place Policy status on, so we recommend that implementations
// SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
// have a _very_ good reason otherwise.
//
// In the context of policy attachment, the Ancestor is used to distinguish which
// resource results in a distinct application of this policy. For example, if a policy
// targets a Service, it may have a distinct result per attached Gateway.
//
// Policies targeting the same resource may have different effects depending on the
// ancestors of those resources. For example, different Gateways targeting the same
// Service may have different capabilities, especially if they have different underlying
// implementations.
//
// For example, in BackendTLSPolicy, the Policy attaches to a Service that is
// used as a backend in a HTTPRoute that is itself attached to a Gateway.
// In this case, the relevant object for status is the Gateway, and that is the
// ancestor object referred to in this status.
//
// Note that a parent is also an ancestor, so for objects where the parent is the
// relevant object for status, this struct SHOULD still be used.
//
// This struct is intended to be used in a slice that's effectively a map,
// with a composite key made up of the AncestorRef and the ControllerName.
type XBackendTrafficPolicyStatusAncestors struct {
	AncestorRef *XBackendTrafficPolicyStatusAncestorsAncestorRef `pulumi:"ancestorRef"`
	// Conditions describes the status of the Policy with respect to the given Ancestor.
	Conditions []XBackendTrafficPolicyStatusAncestorsConditions `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName *string `pulumi:"controllerName"`
}

// XBackendTrafficPolicyStatusAncestorsInput is an input type that accepts XBackendTrafficPolicyStatusAncestorsArgs and XBackendTrafficPolicyStatusAncestorsOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusAncestorsInput` via:
//
//	XBackendTrafficPolicyStatusAncestorsArgs{...}
type XBackendTrafficPolicyStatusAncestorsInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusAncestorsOutput() XBackendTrafficPolicyStatusAncestorsOutput
	ToXBackendTrafficPolicyStatusAncestorsOutputWithContext(context.Context) XBackendTrafficPolicyStatusAncestorsOutput
}

// PolicyAncestorStatus describes the status of a route with respect to an
// associated Ancestor.
//
// Ancestors refer to objects that are either the Target of a policy or above it
// in terms of object hierarchy. For example, if a policy targets a Service, the
// Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
// the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
// useful object to place Policy status on, so we recommend that implementations
// SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
// have a _very_ good reason otherwise.
//
// In the context of policy attachment, the Ancestor is used to distinguish which
// resource results in a distinct application of this policy. For example, if a policy
// targets a Service, it may have a distinct result per attached Gateway.
//
// Policies targeting the same resource may have different effects depending on the
// ancestors of those resources. For example, different Gateways targeting the same
// Service may have different capabilities, especially if they have different underlying
// implementations.
//
// For example, in BackendTLSPolicy, the Policy attaches to a Service that is
// used as a backend in a HTTPRoute that is itself attached to a Gateway.
// In this case, the relevant object for status is the Gateway, and that is the
// ancestor object referred to in this status.
//
// Note that a parent is also an ancestor, so for objects where the parent is the
// relevant object for status, this struct SHOULD still be used.
//
// This struct is intended to be used in a slice that's effectively a map,
// with a composite key made up of the AncestorRef and the ControllerName.
type XBackendTrafficPolicyStatusAncestorsArgs struct {
	AncestorRef XBackendTrafficPolicyStatusAncestorsAncestorRefPtrInput `pulumi:"ancestorRef"`
	// Conditions describes the status of the Policy with respect to the given Ancestor.
	Conditions XBackendTrafficPolicyStatusAncestorsConditionsArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringPtrInput `pulumi:"controllerName"`
}

func (XBackendTrafficPolicyStatusAncestorsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatusAncestors)(nil)).Elem()
}

func (i XBackendTrafficPolicyStatusAncestorsArgs) ToXBackendTrafficPolicyStatusAncestorsOutput() XBackendTrafficPolicyStatusAncestorsOutput {
	return i.ToXBackendTrafficPolicyStatusAncestorsOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusAncestorsArgs) ToXBackendTrafficPolicyStatusAncestorsOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusAncestorsOutput)
}

// XBackendTrafficPolicyStatusAncestorsArrayInput is an input type that accepts XBackendTrafficPolicyStatusAncestorsArray and XBackendTrafficPolicyStatusAncestorsArrayOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusAncestorsArrayInput` via:
//
//	XBackendTrafficPolicyStatusAncestorsArray{ XBackendTrafficPolicyStatusAncestorsArgs{...} }
type XBackendTrafficPolicyStatusAncestorsArrayInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusAncestorsArrayOutput() XBackendTrafficPolicyStatusAncestorsArrayOutput
	ToXBackendTrafficPolicyStatusAncestorsArrayOutputWithContext(context.Context) XBackendTrafficPolicyStatusAncestorsArrayOutput
}

type XBackendTrafficPolicyStatusAncestorsArray []XBackendTrafficPolicyStatusAncestorsInput

func (XBackendTrafficPolicyStatusAncestorsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XBackendTrafficPolicyStatusAncestors)(nil)).Elem()
}

func (i XBackendTrafficPolicyStatusAncestorsArray) ToXBackendTrafficPolicyStatusAncestorsArrayOutput() XBackendTrafficPolicyStatusAncestorsArrayOutput {
	return i.ToXBackendTrafficPolicyStatusAncestorsArrayOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusAncestorsArray) ToXBackendTrafficPolicyStatusAncestorsArrayOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusAncestorsArrayOutput)
}

// PolicyAncestorStatus describes the status of a route with respect to an
// associated Ancestor.
//
// Ancestors refer to objects that are either the Target of a policy or above it
// in terms of object hierarchy. For example, if a policy targets a Service, the
// Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
// the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
// useful object to place Policy status on, so we recommend that implementations
// SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
// have a _very_ good reason otherwise.
//
// In the context of policy attachment, the Ancestor is used to distinguish which
// resource results in a distinct application of this policy. For example, if a policy
// targets a Service, it may have a distinct result per attached Gateway.
//
// Policies targeting the same resource may have different effects depending on the
// ancestors of those resources. For example, different Gateways targeting the same
// Service may have different capabilities, especially if they have different underlying
// implementations.
//
// For example, in BackendTLSPolicy, the Policy attaches to a Service that is
// used as a backend in a HTTPRoute that is itself attached to a Gateway.
// In this case, the relevant object for status is the Gateway, and that is the
// ancestor object referred to in this status.
//
// Note that a parent is also an ancestor, so for objects where the parent is the
// relevant object for status, this struct SHOULD still be used.
//
// This struct is intended to be used in a slice that's effectively a map,
// with a composite key made up of the AncestorRef and the ControllerName.
type XBackendTrafficPolicyStatusAncestorsOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusAncestorsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatusAncestors)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusAncestorsOutput) ToXBackendTrafficPolicyStatusAncestorsOutput() XBackendTrafficPolicyStatusAncestorsOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsOutput) ToXBackendTrafficPolicyStatusAncestorsOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsOutput) AncestorRef() XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestors) *XBackendTrafficPolicyStatusAncestorsAncestorRef {
		return v.AncestorRef
	}).(XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput)
}

// Conditions describes the status of the Policy with respect to the given Ancestor.
func (o XBackendTrafficPolicyStatusAncestorsOutput) Conditions() XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestors) []XBackendTrafficPolicyStatusAncestorsConditions {
		return v.Conditions
	}).(XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o XBackendTrafficPolicyStatusAncestorsOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestors) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

type XBackendTrafficPolicyStatusAncestorsArrayOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusAncestorsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XBackendTrafficPolicyStatusAncestors)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusAncestorsArrayOutput) ToXBackendTrafficPolicyStatusAncestorsArrayOutput() XBackendTrafficPolicyStatusAncestorsArrayOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsArrayOutput) ToXBackendTrafficPolicyStatusAncestorsArrayOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsArrayOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsArrayOutput) Index(i pulumi.IntInput) XBackendTrafficPolicyStatusAncestorsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XBackendTrafficPolicyStatusAncestors {
		return vs[0].([]XBackendTrafficPolicyStatusAncestors)[vs[1].(int)]
	}).(XBackendTrafficPolicyStatusAncestorsOutput)
}

// AncestorRef corresponds with a ParentRef in the spec that this
// PolicyAncestorStatus struct describes the status of.
type XBackendTrafficPolicyStatusAncestorsAncestorRef struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// XBackendTrafficPolicyStatusAncestorsAncestorRefInput is an input type that accepts XBackendTrafficPolicyStatusAncestorsAncestorRefArgs and XBackendTrafficPolicyStatusAncestorsAncestorRefOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusAncestorsAncestorRefInput` via:
//
//	XBackendTrafficPolicyStatusAncestorsAncestorRefArgs{...}
type XBackendTrafficPolicyStatusAncestorsAncestorRefInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusAncestorsAncestorRefOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefOutput
	ToXBackendTrafficPolicyStatusAncestorsAncestorRefOutputWithContext(context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefOutput
}

// AncestorRef corresponds with a ParentRef in the spec that this
// PolicyAncestorStatus struct describes the status of.
type XBackendTrafficPolicyStatusAncestorsAncestorRefArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (XBackendTrafficPolicyStatusAncestorsAncestorRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsAncestorRef)(nil)).Elem()
}

func (i XBackendTrafficPolicyStatusAncestorsAncestorRefArgs) ToXBackendTrafficPolicyStatusAncestorsAncestorRefOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefOutput {
	return i.ToXBackendTrafficPolicyStatusAncestorsAncestorRefOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusAncestorsAncestorRefArgs) ToXBackendTrafficPolicyStatusAncestorsAncestorRefOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusAncestorsAncestorRefOutput)
}

func (i XBackendTrafficPolicyStatusAncestorsAncestorRefArgs) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput {
	return i.ToXBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusAncestorsAncestorRefArgs) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusAncestorsAncestorRefOutput).ToXBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutputWithContext(ctx)
}

// XBackendTrafficPolicyStatusAncestorsAncestorRefPtrInput is an input type that accepts XBackendTrafficPolicyStatusAncestorsAncestorRefArgs, XBackendTrafficPolicyStatusAncestorsAncestorRefPtr and XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusAncestorsAncestorRefPtrInput` via:
//
//	        XBackendTrafficPolicyStatusAncestorsAncestorRefArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicyStatusAncestorsAncestorRefPtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput
	ToXBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutputWithContext(context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput
}

type xbackendTrafficPolicyStatusAncestorsAncestorRefPtrType XBackendTrafficPolicyStatusAncestorsAncestorRefArgs

func XBackendTrafficPolicyStatusAncestorsAncestorRefPtr(v *XBackendTrafficPolicyStatusAncestorsAncestorRefArgs) XBackendTrafficPolicyStatusAncestorsAncestorRefPtrInput {
	return (*xbackendTrafficPolicyStatusAncestorsAncestorRefPtrType)(v)
}

func (*xbackendTrafficPolicyStatusAncestorsAncestorRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicyStatusAncestorsAncestorRef)(nil)).Elem()
}

func (i *xbackendTrafficPolicyStatusAncestorsAncestorRefPtrType) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput {
	return i.ToXBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicyStatusAncestorsAncestorRefPtrType) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput)
}

// AncestorRef corresponds with a ParentRef in the spec that this
// PolicyAncestorStatus struct describes the status of.
type XBackendTrafficPolicyStatusAncestorsAncestorRefOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusAncestorsAncestorRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsAncestorRef)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusAncestorsAncestorRefOutput) ToXBackendTrafficPolicyStatusAncestorsAncestorRefOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsAncestorRefOutput) ToXBackendTrafficPolicyStatusAncestorsAncestorRefOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsAncestorRefOutput) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput {
	return o.ToXBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicyStatusAncestorsAncestorRefOutput) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicyStatusAncestorsAncestorRef) *XBackendTrafficPolicyStatusAncestorsAncestorRef {
		return &v
	}).(XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsAncestorRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsAncestorRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsAncestorRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsAncestorRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsAncestorRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsAncestorRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicyStatusAncestorsAncestorRef)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput) Elem() XBackendTrafficPolicyStatusAncestorsAncestorRefOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusAncestorsAncestorRef) XBackendTrafficPolicyStatusAncestorsAncestorRef {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicyStatusAncestorsAncestorRef
		return ret
	}).(XBackendTrafficPolicyStatusAncestorsAncestorRefOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusAncestorsAncestorRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusAncestorsAncestorRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusAncestorsAncestorRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusAncestorsAncestorRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusAncestorsAncestorRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusAncestorsAncestorRef) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// AncestorRef corresponds with a ParentRef in the spec that this
// PolicyAncestorStatus struct describes the status of.
type XBackendTrafficPolicyStatusAncestorsAncestorRefPatch struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// XBackendTrafficPolicyStatusAncestorsAncestorRefPatchInput is an input type that accepts XBackendTrafficPolicyStatusAncestorsAncestorRefPatchArgs and XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusAncestorsAncestorRefPatchInput` via:
//
//	XBackendTrafficPolicyStatusAncestorsAncestorRefPatchArgs{...}
type XBackendTrafficPolicyStatusAncestorsAncestorRefPatchInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput
	ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutputWithContext(context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput
}

// AncestorRef corresponds with a ParentRef in the spec that this
// PolicyAncestorStatus struct describes the status of.
type XBackendTrafficPolicyStatusAncestorsAncestorRefPatchArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (XBackendTrafficPolicyStatusAncestorsAncestorRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsAncestorRefPatch)(nil)).Elem()
}

func (i XBackendTrafficPolicyStatusAncestorsAncestorRefPatchArgs) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput {
	return i.ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusAncestorsAncestorRefPatchArgs) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput)
}

func (i XBackendTrafficPolicyStatusAncestorsAncestorRefPatchArgs) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput {
	return i.ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusAncestorsAncestorRefPatchArgs) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput).ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutputWithContext(ctx)
}

// XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrInput is an input type that accepts XBackendTrafficPolicyStatusAncestorsAncestorRefPatchArgs, XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtr and XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrInput` via:
//
//	        XBackendTrafficPolicyStatusAncestorsAncestorRefPatchArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput
	ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutputWithContext(context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput
}

type xbackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrType XBackendTrafficPolicyStatusAncestorsAncestorRefPatchArgs

func XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtr(v *XBackendTrafficPolicyStatusAncestorsAncestorRefPatchArgs) XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrInput {
	return (*xbackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrType)(v)
}

func (*xbackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicyStatusAncestorsAncestorRefPatch)(nil)).Elem()
}

func (i *xbackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrType) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput {
	return i.ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrType) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput)
}

// AncestorRef corresponds with a ParentRef in the spec that this
// PolicyAncestorStatus struct describes the status of.
type XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsAncestorRefPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput {
	return o.ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicyStatusAncestorsAncestorRefPatch) *XBackendTrafficPolicyStatusAncestorsAncestorRefPatch {
		return &v
	}).(XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsAncestorRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsAncestorRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsAncestorRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsAncestorRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsAncestorRefPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsAncestorRefPatch) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicyStatusAncestorsAncestorRefPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput() XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput) ToXBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput) Elem() XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusAncestorsAncestorRefPatch) XBackendTrafficPolicyStatusAncestorsAncestorRefPatch {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicyStatusAncestorsAncestorRefPatch
		return ret
	}).(XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusAncestorsAncestorRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusAncestorsAncestorRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusAncestorsAncestorRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusAncestorsAncestorRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusAncestorsAncestorRefPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusAncestorsAncestorRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type XBackendTrafficPolicyStatusAncestorsConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type *string `pulumi:"type"`
}

// XBackendTrafficPolicyStatusAncestorsConditionsInput is an input type that accepts XBackendTrafficPolicyStatusAncestorsConditionsArgs and XBackendTrafficPolicyStatusAncestorsConditionsOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusAncestorsConditionsInput` via:
//
//	XBackendTrafficPolicyStatusAncestorsConditionsArgs{...}
type XBackendTrafficPolicyStatusAncestorsConditionsInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusAncestorsConditionsOutput() XBackendTrafficPolicyStatusAncestorsConditionsOutput
	ToXBackendTrafficPolicyStatusAncestorsConditionsOutputWithContext(context.Context) XBackendTrafficPolicyStatusAncestorsConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
type XBackendTrafficPolicyStatusAncestorsConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (XBackendTrafficPolicyStatusAncestorsConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsConditions)(nil)).Elem()
}

func (i XBackendTrafficPolicyStatusAncestorsConditionsArgs) ToXBackendTrafficPolicyStatusAncestorsConditionsOutput() XBackendTrafficPolicyStatusAncestorsConditionsOutput {
	return i.ToXBackendTrafficPolicyStatusAncestorsConditionsOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusAncestorsConditionsArgs) ToXBackendTrafficPolicyStatusAncestorsConditionsOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusAncestorsConditionsOutput)
}

// XBackendTrafficPolicyStatusAncestorsConditionsArrayInput is an input type that accepts XBackendTrafficPolicyStatusAncestorsConditionsArray and XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusAncestorsConditionsArrayInput` via:
//
//	XBackendTrafficPolicyStatusAncestorsConditionsArray{ XBackendTrafficPolicyStatusAncestorsConditionsArgs{...} }
type XBackendTrafficPolicyStatusAncestorsConditionsArrayInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusAncestorsConditionsArrayOutput() XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput
	ToXBackendTrafficPolicyStatusAncestorsConditionsArrayOutputWithContext(context.Context) XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput
}

type XBackendTrafficPolicyStatusAncestorsConditionsArray []XBackendTrafficPolicyStatusAncestorsConditionsInput

func (XBackendTrafficPolicyStatusAncestorsConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XBackendTrafficPolicyStatusAncestorsConditions)(nil)).Elem()
}

func (i XBackendTrafficPolicyStatusAncestorsConditionsArray) ToXBackendTrafficPolicyStatusAncestorsConditionsArrayOutput() XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput {
	return i.ToXBackendTrafficPolicyStatusAncestorsConditionsArrayOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusAncestorsConditionsArray) ToXBackendTrafficPolicyStatusAncestorsConditionsArrayOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type XBackendTrafficPolicyStatusAncestorsConditionsOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusAncestorsConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsConditions)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusAncestorsConditionsOutput) ToXBackendTrafficPolicyStatusAncestorsConditionsOutput() XBackendTrafficPolicyStatusAncestorsConditionsOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsConditionsOutput) ToXBackendTrafficPolicyStatusAncestorsConditionsOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o XBackendTrafficPolicyStatusAncestorsConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o XBackendTrafficPolicyStatusAncestorsConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o XBackendTrafficPolicyStatusAncestorsConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o XBackendTrafficPolicyStatusAncestorsConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o XBackendTrafficPolicyStatusAncestorsConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
func (o XBackendTrafficPolicyStatusAncestorsConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XBackendTrafficPolicyStatusAncestorsConditions)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput) ToXBackendTrafficPolicyStatusAncestorsConditionsArrayOutput() XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput) ToXBackendTrafficPolicyStatusAncestorsConditionsArrayOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput) Index(i pulumi.IntInput) XBackendTrafficPolicyStatusAncestorsConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XBackendTrafficPolicyStatusAncestorsConditions {
		return vs[0].([]XBackendTrafficPolicyStatusAncestorsConditions)[vs[1].(int)]
	}).(XBackendTrafficPolicyStatusAncestorsConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type XBackendTrafficPolicyStatusAncestorsConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type *string `pulumi:"type"`
}

// XBackendTrafficPolicyStatusAncestorsConditionsPatchInput is an input type that accepts XBackendTrafficPolicyStatusAncestorsConditionsPatchArgs and XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusAncestorsConditionsPatchInput` via:
//
//	XBackendTrafficPolicyStatusAncestorsConditionsPatchArgs{...}
type XBackendTrafficPolicyStatusAncestorsConditionsPatchInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusAncestorsConditionsPatchOutput() XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput
	ToXBackendTrafficPolicyStatusAncestorsConditionsPatchOutputWithContext(context.Context) XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
type XBackendTrafficPolicyStatusAncestorsConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (XBackendTrafficPolicyStatusAncestorsConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsConditionsPatch)(nil)).Elem()
}

func (i XBackendTrafficPolicyStatusAncestorsConditionsPatchArgs) ToXBackendTrafficPolicyStatusAncestorsConditionsPatchOutput() XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput {
	return i.ToXBackendTrafficPolicyStatusAncestorsConditionsPatchOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusAncestorsConditionsPatchArgs) ToXBackendTrafficPolicyStatusAncestorsConditionsPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput)
}

// XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayInput is an input type that accepts XBackendTrafficPolicyStatusAncestorsConditionsPatchArray and XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayInput` via:
//
//	XBackendTrafficPolicyStatusAncestorsConditionsPatchArray{ XBackendTrafficPolicyStatusAncestorsConditionsPatchArgs{...} }
type XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput() XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput
	ToXBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutputWithContext(context.Context) XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput
}

type XBackendTrafficPolicyStatusAncestorsConditionsPatchArray []XBackendTrafficPolicyStatusAncestorsConditionsPatchInput

func (XBackendTrafficPolicyStatusAncestorsConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XBackendTrafficPolicyStatusAncestorsConditionsPatch)(nil)).Elem()
}

func (i XBackendTrafficPolicyStatusAncestorsConditionsPatchArray) ToXBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput() XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput {
	return i.ToXBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusAncestorsConditionsPatchArray) ToXBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsConditionsPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput) ToXBackendTrafficPolicyStatusAncestorsConditionsPatchOutput() XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput) ToXBackendTrafficPolicyStatusAncestorsConditionsPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
func (o XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XBackendTrafficPolicyStatusAncestorsConditionsPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput) ToXBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput() XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput) ToXBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput) Index(i pulumi.IntInput) XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XBackendTrafficPolicyStatusAncestorsConditionsPatch {
		return vs[0].([]XBackendTrafficPolicyStatusAncestorsConditionsPatch)[vs[1].(int)]
	}).(XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput)
}

// PolicyAncestorStatus describes the status of a route with respect to an
// associated Ancestor.
//
// Ancestors refer to objects that are either the Target of a policy or above it
// in terms of object hierarchy. For example, if a policy targets a Service, the
// Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
// the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
// useful object to place Policy status on, so we recommend that implementations
// SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
// have a _very_ good reason otherwise.
//
// In the context of policy attachment, the Ancestor is used to distinguish which
// resource results in a distinct application of this policy. For example, if a policy
// targets a Service, it may have a distinct result per attached Gateway.
//
// Policies targeting the same resource may have different effects depending on the
// ancestors of those resources. For example, different Gateways targeting the same
// Service may have different capabilities, especially if they have different underlying
// implementations.
//
// For example, in BackendTLSPolicy, the Policy attaches to a Service that is
// used as a backend in a HTTPRoute that is itself attached to a Gateway.
// In this case, the relevant object for status is the Gateway, and that is the
// ancestor object referred to in this status.
//
// Note that a parent is also an ancestor, so for objects where the parent is the
// relevant object for status, this struct SHOULD still be used.
//
// This struct is intended to be used in a slice that's effectively a map,
// with a composite key made up of the AncestorRef and the ControllerName.
type XBackendTrafficPolicyStatusAncestorsPatch struct {
	AncestorRef *XBackendTrafficPolicyStatusAncestorsAncestorRefPatch `pulumi:"ancestorRef"`
	// Conditions describes the status of the Policy with respect to the given Ancestor.
	Conditions []XBackendTrafficPolicyStatusAncestorsConditionsPatch `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName *string `pulumi:"controllerName"`
}

// XBackendTrafficPolicyStatusAncestorsPatchInput is an input type that accepts XBackendTrafficPolicyStatusAncestorsPatchArgs and XBackendTrafficPolicyStatusAncestorsPatchOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusAncestorsPatchInput` via:
//
//	XBackendTrafficPolicyStatusAncestorsPatchArgs{...}
type XBackendTrafficPolicyStatusAncestorsPatchInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusAncestorsPatchOutput() XBackendTrafficPolicyStatusAncestorsPatchOutput
	ToXBackendTrafficPolicyStatusAncestorsPatchOutputWithContext(context.Context) XBackendTrafficPolicyStatusAncestorsPatchOutput
}

// PolicyAncestorStatus describes the status of a route with respect to an
// associated Ancestor.
//
// Ancestors refer to objects that are either the Target of a policy or above it
// in terms of object hierarchy. For example, if a policy targets a Service, the
// Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
// the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
// useful object to place Policy status on, so we recommend that implementations
// SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
// have a _very_ good reason otherwise.
//
// In the context of policy attachment, the Ancestor is used to distinguish which
// resource results in a distinct application of this policy. For example, if a policy
// targets a Service, it may have a distinct result per attached Gateway.
//
// Policies targeting the same resource may have different effects depending on the
// ancestors of those resources. For example, different Gateways targeting the same
// Service may have different capabilities, especially if they have different underlying
// implementations.
//
// For example, in BackendTLSPolicy, the Policy attaches to a Service that is
// used as a backend in a HTTPRoute that is itself attached to a Gateway.
// In this case, the relevant object for status is the Gateway, and that is the
// ancestor object referred to in this status.
//
// Note that a parent is also an ancestor, so for objects where the parent is the
// relevant object for status, this struct SHOULD still be used.
//
// This struct is intended to be used in a slice that's effectively a map,
// with a composite key made up of the AncestorRef and the ControllerName.
type XBackendTrafficPolicyStatusAncestorsPatchArgs struct {
	AncestorRef XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrInput `pulumi:"ancestorRef"`
	// Conditions describes the status of the Policy with respect to the given Ancestor.
	Conditions XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringPtrInput `pulumi:"controllerName"`
}

func (XBackendTrafficPolicyStatusAncestorsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsPatch)(nil)).Elem()
}

func (i XBackendTrafficPolicyStatusAncestorsPatchArgs) ToXBackendTrafficPolicyStatusAncestorsPatchOutput() XBackendTrafficPolicyStatusAncestorsPatchOutput {
	return i.ToXBackendTrafficPolicyStatusAncestorsPatchOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusAncestorsPatchArgs) ToXBackendTrafficPolicyStatusAncestorsPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusAncestorsPatchOutput)
}

// XBackendTrafficPolicyStatusAncestorsPatchArrayInput is an input type that accepts XBackendTrafficPolicyStatusAncestorsPatchArray and XBackendTrafficPolicyStatusAncestorsPatchArrayOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusAncestorsPatchArrayInput` via:
//
//	XBackendTrafficPolicyStatusAncestorsPatchArray{ XBackendTrafficPolicyStatusAncestorsPatchArgs{...} }
type XBackendTrafficPolicyStatusAncestorsPatchArrayInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusAncestorsPatchArrayOutput() XBackendTrafficPolicyStatusAncestorsPatchArrayOutput
	ToXBackendTrafficPolicyStatusAncestorsPatchArrayOutputWithContext(context.Context) XBackendTrafficPolicyStatusAncestorsPatchArrayOutput
}

type XBackendTrafficPolicyStatusAncestorsPatchArray []XBackendTrafficPolicyStatusAncestorsPatchInput

func (XBackendTrafficPolicyStatusAncestorsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XBackendTrafficPolicyStatusAncestorsPatch)(nil)).Elem()
}

func (i XBackendTrafficPolicyStatusAncestorsPatchArray) ToXBackendTrafficPolicyStatusAncestorsPatchArrayOutput() XBackendTrafficPolicyStatusAncestorsPatchArrayOutput {
	return i.ToXBackendTrafficPolicyStatusAncestorsPatchArrayOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusAncestorsPatchArray) ToXBackendTrafficPolicyStatusAncestorsPatchArrayOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusAncestorsPatchArrayOutput)
}

// PolicyAncestorStatus describes the status of a route with respect to an
// associated Ancestor.
//
// Ancestors refer to objects that are either the Target of a policy or above it
// in terms of object hierarchy. For example, if a policy targets a Service, the
// Policy's Ancestors are, in order, the Service, the HTTPRoute, the Gateway, and
// the GatewayClass. Almost always, in this hierarchy, the Gateway will be the most
// useful object to place Policy status on, so we recommend that implementations
// SHOULD use Gateway as the PolicyAncestorStatus object unless the designers
// have a _very_ good reason otherwise.
//
// In the context of policy attachment, the Ancestor is used to distinguish which
// resource results in a distinct application of this policy. For example, if a policy
// targets a Service, it may have a distinct result per attached Gateway.
//
// Policies targeting the same resource may have different effects depending on the
// ancestors of those resources. For example, different Gateways targeting the same
// Service may have different capabilities, especially if they have different underlying
// implementations.
//
// For example, in BackendTLSPolicy, the Policy attaches to a Service that is
// used as a backend in a HTTPRoute that is itself attached to a Gateway.
// In this case, the relevant object for status is the Gateway, and that is the
// ancestor object referred to in this status.
//
// Note that a parent is also an ancestor, so for objects where the parent is the
// relevant object for status, this struct SHOULD still be used.
//
// This struct is intended to be used in a slice that's effectively a map,
// with a composite key made up of the AncestorRef and the ControllerName.
type XBackendTrafficPolicyStatusAncestorsPatchOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusAncestorsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusAncestorsPatchOutput) ToXBackendTrafficPolicyStatusAncestorsPatchOutput() XBackendTrafficPolicyStatusAncestorsPatchOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsPatchOutput) ToXBackendTrafficPolicyStatusAncestorsPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsPatchOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsPatchOutput) AncestorRef() XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsPatch) *XBackendTrafficPolicyStatusAncestorsAncestorRefPatch {
		return v.AncestorRef
	}).(XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput)
}

// Conditions describes the status of the Policy with respect to the given Ancestor.
func (o XBackendTrafficPolicyStatusAncestorsPatchOutput) Conditions() XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsPatch) []XBackendTrafficPolicyStatusAncestorsConditionsPatch {
		return v.Conditions
	}).(XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o XBackendTrafficPolicyStatusAncestorsPatchOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusAncestorsPatch) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

type XBackendTrafficPolicyStatusAncestorsPatchArrayOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusAncestorsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XBackendTrafficPolicyStatusAncestorsPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusAncestorsPatchArrayOutput) ToXBackendTrafficPolicyStatusAncestorsPatchArrayOutput() XBackendTrafficPolicyStatusAncestorsPatchArrayOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsPatchArrayOutput) ToXBackendTrafficPolicyStatusAncestorsPatchArrayOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusAncestorsPatchArrayOutput {
	return o
}

func (o XBackendTrafficPolicyStatusAncestorsPatchArrayOutput) Index(i pulumi.IntInput) XBackendTrafficPolicyStatusAncestorsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XBackendTrafficPolicyStatusAncestorsPatch {
		return vs[0].([]XBackendTrafficPolicyStatusAncestorsPatch)[vs[1].(int)]
	}).(XBackendTrafficPolicyStatusAncestorsPatchOutput)
}

// Status defines the current state of BackendTrafficPolicy.
type XBackendTrafficPolicyStatusPatch struct {
	// Ancestors is a list of ancestor resources (usually Gateways) that are
	// associated with the policy, and the status of the policy with respect to
	// each ancestor. When this policy attaches to a parent, the controller that
	// manages the parent and the ancestors MUST add an entry to this list when
	// the controller first sees the policy and SHOULD update the entry as
	// appropriate when the relevant ancestor is modified.
	//
	// Note that choosing the relevant ancestor is left to the Policy designers;
	// an important part of Policy design is designing the right object level at
	// which to namespace this status.
	//
	// Note also that implementations MUST ONLY populate ancestor status for
	// the Ancestor resources they are responsible for. Implementations MUST
	// use the ControllerName field to uniquely identify the entries in this list
	// that they are responsible for.
	//
	// Note that to achieve this, the list of PolicyAncestorStatus structs
	// MUST be treated as a map with a composite key, made up of the AncestorRef
	// and ControllerName fields combined.
	//
	// A maximum of 16 ancestors will be represented in this list. An empty list
	// means the Policy is not relevant for any ancestors.
	//
	// If this slice is full, implementations MUST NOT add further entries.
	// Instead they MUST consider the policy unimplementable and signal that
	// on any related resources such as the ancestor that would be referenced
	// here. For example, if this list was full on BackendTLSPolicy, no
	// additional Gateways would be able to reference the Service targeted by
	// the BackendTLSPolicy.
	Ancestors []XBackendTrafficPolicyStatusAncestorsPatch `pulumi:"ancestors"`
}

// XBackendTrafficPolicyStatusPatchInput is an input type that accepts XBackendTrafficPolicyStatusPatchArgs and XBackendTrafficPolicyStatusPatchOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusPatchInput` via:
//
//	XBackendTrafficPolicyStatusPatchArgs{...}
type XBackendTrafficPolicyStatusPatchInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusPatchOutput() XBackendTrafficPolicyStatusPatchOutput
	ToXBackendTrafficPolicyStatusPatchOutputWithContext(context.Context) XBackendTrafficPolicyStatusPatchOutput
}

// Status defines the current state of BackendTrafficPolicy.
type XBackendTrafficPolicyStatusPatchArgs struct {
	// Ancestors is a list of ancestor resources (usually Gateways) that are
	// associated with the policy, and the status of the policy with respect to
	// each ancestor. When this policy attaches to a parent, the controller that
	// manages the parent and the ancestors MUST add an entry to this list when
	// the controller first sees the policy and SHOULD update the entry as
	// appropriate when the relevant ancestor is modified.
	//
	// Note that choosing the relevant ancestor is left to the Policy designers;
	// an important part of Policy design is designing the right object level at
	// which to namespace this status.
	//
	// Note also that implementations MUST ONLY populate ancestor status for
	// the Ancestor resources they are responsible for. Implementations MUST
	// use the ControllerName field to uniquely identify the entries in this list
	// that they are responsible for.
	//
	// Note that to achieve this, the list of PolicyAncestorStatus structs
	// MUST be treated as a map with a composite key, made up of the AncestorRef
	// and ControllerName fields combined.
	//
	// A maximum of 16 ancestors will be represented in this list. An empty list
	// means the Policy is not relevant for any ancestors.
	//
	// If this slice is full, implementations MUST NOT add further entries.
	// Instead they MUST consider the policy unimplementable and signal that
	// on any related resources such as the ancestor that would be referenced
	// here. For example, if this list was full on BackendTLSPolicy, no
	// additional Gateways would be able to reference the Service targeted by
	// the BackendTLSPolicy.
	Ancestors XBackendTrafficPolicyStatusAncestorsPatchArrayInput `pulumi:"ancestors"`
}

func (XBackendTrafficPolicyStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatusPatch)(nil)).Elem()
}

func (i XBackendTrafficPolicyStatusPatchArgs) ToXBackendTrafficPolicyStatusPatchOutput() XBackendTrafficPolicyStatusPatchOutput {
	return i.ToXBackendTrafficPolicyStatusPatchOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusPatchArgs) ToXBackendTrafficPolicyStatusPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusPatchOutput)
}

func (i XBackendTrafficPolicyStatusPatchArgs) ToXBackendTrafficPolicyStatusPatchPtrOutput() XBackendTrafficPolicyStatusPatchPtrOutput {
	return i.ToXBackendTrafficPolicyStatusPatchPtrOutputWithContext(context.Background())
}

func (i XBackendTrafficPolicyStatusPatchArgs) ToXBackendTrafficPolicyStatusPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusPatchOutput).ToXBackendTrafficPolicyStatusPatchPtrOutputWithContext(ctx)
}

// XBackendTrafficPolicyStatusPatchPtrInput is an input type that accepts XBackendTrafficPolicyStatusPatchArgs, XBackendTrafficPolicyStatusPatchPtr and XBackendTrafficPolicyStatusPatchPtrOutput values.
// You can construct a concrete instance of `XBackendTrafficPolicyStatusPatchPtrInput` via:
//
//	        XBackendTrafficPolicyStatusPatchArgs{...}
//
//	or:
//
//	        nil
type XBackendTrafficPolicyStatusPatchPtrInput interface {
	pulumi.Input

	ToXBackendTrafficPolicyStatusPatchPtrOutput() XBackendTrafficPolicyStatusPatchPtrOutput
	ToXBackendTrafficPolicyStatusPatchPtrOutputWithContext(context.Context) XBackendTrafficPolicyStatusPatchPtrOutput
}

type xbackendTrafficPolicyStatusPatchPtrType XBackendTrafficPolicyStatusPatchArgs

func XBackendTrafficPolicyStatusPatchPtr(v *XBackendTrafficPolicyStatusPatchArgs) XBackendTrafficPolicyStatusPatchPtrInput {
	return (*xbackendTrafficPolicyStatusPatchPtrType)(v)
}

func (*xbackendTrafficPolicyStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicyStatusPatch)(nil)).Elem()
}

func (i *xbackendTrafficPolicyStatusPatchPtrType) ToXBackendTrafficPolicyStatusPatchPtrOutput() XBackendTrafficPolicyStatusPatchPtrOutput {
	return i.ToXBackendTrafficPolicyStatusPatchPtrOutputWithContext(context.Background())
}

func (i *xbackendTrafficPolicyStatusPatchPtrType) ToXBackendTrafficPolicyStatusPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XBackendTrafficPolicyStatusPatchPtrOutput)
}

// Status defines the current state of BackendTrafficPolicy.
type XBackendTrafficPolicyStatusPatchOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XBackendTrafficPolicyStatusPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusPatchOutput) ToXBackendTrafficPolicyStatusPatchOutput() XBackendTrafficPolicyStatusPatchOutput {
	return o
}

func (o XBackendTrafficPolicyStatusPatchOutput) ToXBackendTrafficPolicyStatusPatchOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusPatchOutput {
	return o
}

func (o XBackendTrafficPolicyStatusPatchOutput) ToXBackendTrafficPolicyStatusPatchPtrOutput() XBackendTrafficPolicyStatusPatchPtrOutput {
	return o.ToXBackendTrafficPolicyStatusPatchPtrOutputWithContext(context.Background())
}

func (o XBackendTrafficPolicyStatusPatchOutput) ToXBackendTrafficPolicyStatusPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XBackendTrafficPolicyStatusPatch) *XBackendTrafficPolicyStatusPatch {
		return &v
	}).(XBackendTrafficPolicyStatusPatchPtrOutput)
}

// Ancestors is a list of ancestor resources (usually Gateways) that are
// associated with the policy, and the status of the policy with respect to
// each ancestor. When this policy attaches to a parent, the controller that
// manages the parent and the ancestors MUST add an entry to this list when
// the controller first sees the policy and SHOULD update the entry as
// appropriate when the relevant ancestor is modified.
//
// Note that choosing the relevant ancestor is left to the Policy designers;
// an important part of Policy design is designing the right object level at
// which to namespace this status.
//
// Note also that implementations MUST ONLY populate ancestor status for
// the Ancestor resources they are responsible for. Implementations MUST
// use the ControllerName field to uniquely identify the entries in this list
// that they are responsible for.
//
// Note that to achieve this, the list of PolicyAncestorStatus structs
// MUST be treated as a map with a composite key, made up of the AncestorRef
// and ControllerName fields combined.
//
// A maximum of 16 ancestors will be represented in this list. An empty list
// means the Policy is not relevant for any ancestors.
//
// If this slice is full, implementations MUST NOT add further entries.
// Instead they MUST consider the policy unimplementable and signal that
// on any related resources such as the ancestor that would be referenced
// here. For example, if this list was full on BackendTLSPolicy, no
// additional Gateways would be able to reference the Service targeted by
// the BackendTLSPolicy.
func (o XBackendTrafficPolicyStatusPatchOutput) Ancestors() XBackendTrafficPolicyStatusAncestorsPatchArrayOutput {
	return o.ApplyT(func(v XBackendTrafficPolicyStatusPatch) []XBackendTrafficPolicyStatusAncestorsPatch {
		return v.Ancestors
	}).(XBackendTrafficPolicyStatusAncestorsPatchArrayOutput)
}

type XBackendTrafficPolicyStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (XBackendTrafficPolicyStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XBackendTrafficPolicyStatusPatch)(nil)).Elem()
}

func (o XBackendTrafficPolicyStatusPatchPtrOutput) ToXBackendTrafficPolicyStatusPatchPtrOutput() XBackendTrafficPolicyStatusPatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicyStatusPatchPtrOutput) ToXBackendTrafficPolicyStatusPatchPtrOutputWithContext(ctx context.Context) XBackendTrafficPolicyStatusPatchPtrOutput {
	return o
}

func (o XBackendTrafficPolicyStatusPatchPtrOutput) Elem() XBackendTrafficPolicyStatusPatchOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusPatch) XBackendTrafficPolicyStatusPatch {
		if v != nil {
			return *v
		}
		var ret XBackendTrafficPolicyStatusPatch
		return ret
	}).(XBackendTrafficPolicyStatusPatchOutput)
}

// Ancestors is a list of ancestor resources (usually Gateways) that are
// associated with the policy, and the status of the policy with respect to
// each ancestor. When this policy attaches to a parent, the controller that
// manages the parent and the ancestors MUST add an entry to this list when
// the controller first sees the policy and SHOULD update the entry as
// appropriate when the relevant ancestor is modified.
//
// Note that choosing the relevant ancestor is left to the Policy designers;
// an important part of Policy design is designing the right object level at
// which to namespace this status.
//
// Note also that implementations MUST ONLY populate ancestor status for
// the Ancestor resources they are responsible for. Implementations MUST
// use the ControllerName field to uniquely identify the entries in this list
// that they are responsible for.
//
// Note that to achieve this, the list of PolicyAncestorStatus structs
// MUST be treated as a map with a composite key, made up of the AncestorRef
// and ControllerName fields combined.
//
// A maximum of 16 ancestors will be represented in this list. An empty list
// means the Policy is not relevant for any ancestors.
//
// If this slice is full, implementations MUST NOT add further entries.
// Instead they MUST consider the policy unimplementable and signal that
// on any related resources such as the ancestor that would be referenced
// here. For example, if this list was full on BackendTLSPolicy, no
// additional Gateways would be able to reference the Service targeted by
// the BackendTLSPolicy.
func (o XBackendTrafficPolicyStatusPatchPtrOutput) Ancestors() XBackendTrafficPolicyStatusAncestorsPatchArrayOutput {
	return o.ApplyT(func(v *XBackendTrafficPolicyStatusPatch) []XBackendTrafficPolicyStatusAncestorsPatch {
		if v == nil {
			return nil
		}
		return v.Ancestors
	}).(XBackendTrafficPolicyStatusAncestorsPatchArrayOutput)
}

// XListenerSet defines a set of additional listeners
// to attach to an existing Gateway.
type XListenerSetType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta  `pulumi:"metadata"`
	Spec     *XListenerSetSpec   `pulumi:"spec"`
	Status   *XListenerSetStatus `pulumi:"status"`
}

// XListenerSetTypeInput is an input type that accepts XListenerSetTypeArgs and XListenerSetTypeOutput values.
// You can construct a concrete instance of `XListenerSetTypeInput` via:
//
//	XListenerSetTypeArgs{...}
type XListenerSetTypeInput interface {
	pulumi.Input

	ToXListenerSetTypeOutput() XListenerSetTypeOutput
	ToXListenerSetTypeOutputWithContext(context.Context) XListenerSetTypeOutput
}

// XListenerSet defines a set of additional listeners
// to attach to an existing Gateway.
type XListenerSetTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput  `pulumi:"metadata"`
	Spec     XListenerSetSpecPtrInput   `pulumi:"spec"`
	Status   XListenerSetStatusPtrInput `pulumi:"status"`
}

func (XListenerSetTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetType)(nil)).Elem()
}

func (i XListenerSetTypeArgs) ToXListenerSetTypeOutput() XListenerSetTypeOutput {
	return i.ToXListenerSetTypeOutputWithContext(context.Background())
}

func (i XListenerSetTypeArgs) ToXListenerSetTypeOutputWithContext(ctx context.Context) XListenerSetTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetTypeOutput)
}

// XListenerSetTypeArrayInput is an input type that accepts XListenerSetTypeArray and XListenerSetTypeArrayOutput values.
// You can construct a concrete instance of `XListenerSetTypeArrayInput` via:
//
//	XListenerSetTypeArray{ XListenerSetTypeArgs{...} }
type XListenerSetTypeArrayInput interface {
	pulumi.Input

	ToXListenerSetTypeArrayOutput() XListenerSetTypeArrayOutput
	ToXListenerSetTypeArrayOutputWithContext(context.Context) XListenerSetTypeArrayOutput
}

type XListenerSetTypeArray []XListenerSetTypeInput

func (XListenerSetTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetType)(nil)).Elem()
}

func (i XListenerSetTypeArray) ToXListenerSetTypeArrayOutput() XListenerSetTypeArrayOutput {
	return i.ToXListenerSetTypeArrayOutputWithContext(context.Background())
}

func (i XListenerSetTypeArray) ToXListenerSetTypeArrayOutputWithContext(ctx context.Context) XListenerSetTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetTypeArrayOutput)
}

// XListenerSet defines a set of additional listeners
// to attach to an existing Gateway.
type XListenerSetTypeOutput struct{ *pulumi.OutputState }

func (XListenerSetTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetType)(nil)).Elem()
}

func (o XListenerSetTypeOutput) ToXListenerSetTypeOutput() XListenerSetTypeOutput {
	return o
}

func (o XListenerSetTypeOutput) ToXListenerSetTypeOutputWithContext(ctx context.Context) XListenerSetTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o XListenerSetTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o XListenerSetTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o XListenerSetTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v XListenerSetType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o XListenerSetTypeOutput) Spec() XListenerSetSpecPtrOutput {
	return o.ApplyT(func(v XListenerSetType) *XListenerSetSpec { return v.Spec }).(XListenerSetSpecPtrOutput)
}

func (o XListenerSetTypeOutput) Status() XListenerSetStatusPtrOutput {
	return o.ApplyT(func(v XListenerSetType) *XListenerSetStatus { return v.Status }).(XListenerSetStatusPtrOutput)
}

type XListenerSetTypeArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetType)(nil)).Elem()
}

func (o XListenerSetTypeArrayOutput) ToXListenerSetTypeArrayOutput() XListenerSetTypeArrayOutput {
	return o
}

func (o XListenerSetTypeArrayOutput) ToXListenerSetTypeArrayOutputWithContext(ctx context.Context) XListenerSetTypeArrayOutput {
	return o
}

func (o XListenerSetTypeArrayOutput) Index(i pulumi.IntInput) XListenerSetTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetType {
		return vs[0].([]XListenerSetType)[vs[1].(int)]
	}).(XListenerSetTypeOutput)
}

// XListenerSetList is a list of XListenerSet
type XListenerSetListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of xlistenersets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []XListenerSetType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// XListenerSetListTypeInput is an input type that accepts XListenerSetListTypeArgs and XListenerSetListTypeOutput values.
// You can construct a concrete instance of `XListenerSetListTypeInput` via:
//
//	XListenerSetListTypeArgs{...}
type XListenerSetListTypeInput interface {
	pulumi.Input

	ToXListenerSetListTypeOutput() XListenerSetListTypeOutput
	ToXListenerSetListTypeOutputWithContext(context.Context) XListenerSetListTypeOutput
}

// XListenerSetList is a list of XListenerSet
type XListenerSetListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of xlistenersets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items XListenerSetTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (XListenerSetListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetListType)(nil)).Elem()
}

func (i XListenerSetListTypeArgs) ToXListenerSetListTypeOutput() XListenerSetListTypeOutput {
	return i.ToXListenerSetListTypeOutputWithContext(context.Background())
}

func (i XListenerSetListTypeArgs) ToXListenerSetListTypeOutputWithContext(ctx context.Context) XListenerSetListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetListTypeOutput)
}

// XListenerSetList is a list of XListenerSet
type XListenerSetListTypeOutput struct{ *pulumi.OutputState }

func (XListenerSetListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetListType)(nil)).Elem()
}

func (o XListenerSetListTypeOutput) ToXListenerSetListTypeOutput() XListenerSetListTypeOutput {
	return o
}

func (o XListenerSetListTypeOutput) ToXListenerSetListTypeOutputWithContext(ctx context.Context) XListenerSetListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o XListenerSetListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of xlistenersets. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o XListenerSetListTypeOutput) Items() XListenerSetTypeArrayOutput {
	return o.ApplyT(func(v XListenerSetListType) []XListenerSetType { return v.Items }).(XListenerSetTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o XListenerSetListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o XListenerSetListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v XListenerSetListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// XListenerSet defines a set of additional listeners
// to attach to an existing Gateway.
type XListenerSetPatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch  `pulumi:"metadata"`
	Spec     *XListenerSetSpecPatch   `pulumi:"spec"`
	Status   *XListenerSetStatusPatch `pulumi:"status"`
}

// XListenerSetPatchTypeInput is an input type that accepts XListenerSetPatchTypeArgs and XListenerSetPatchTypeOutput values.
// You can construct a concrete instance of `XListenerSetPatchTypeInput` via:
//
//	XListenerSetPatchTypeArgs{...}
type XListenerSetPatchTypeInput interface {
	pulumi.Input

	ToXListenerSetPatchTypeOutput() XListenerSetPatchTypeOutput
	ToXListenerSetPatchTypeOutputWithContext(context.Context) XListenerSetPatchTypeOutput
}

// XListenerSet defines a set of additional listeners
// to attach to an existing Gateway.
type XListenerSetPatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput  `pulumi:"metadata"`
	Spec     XListenerSetSpecPatchPtrInput   `pulumi:"spec"`
	Status   XListenerSetStatusPatchPtrInput `pulumi:"status"`
}

func (XListenerSetPatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetPatchType)(nil)).Elem()
}

func (i XListenerSetPatchTypeArgs) ToXListenerSetPatchTypeOutput() XListenerSetPatchTypeOutput {
	return i.ToXListenerSetPatchTypeOutputWithContext(context.Background())
}

func (i XListenerSetPatchTypeArgs) ToXListenerSetPatchTypeOutputWithContext(ctx context.Context) XListenerSetPatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetPatchTypeOutput)
}

// XListenerSet defines a set of additional listeners
// to attach to an existing Gateway.
type XListenerSetPatchTypeOutput struct{ *pulumi.OutputState }

func (XListenerSetPatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetPatchType)(nil)).Elem()
}

func (o XListenerSetPatchTypeOutput) ToXListenerSetPatchTypeOutput() XListenerSetPatchTypeOutput {
	return o
}

func (o XListenerSetPatchTypeOutput) ToXListenerSetPatchTypeOutputWithContext(ctx context.Context) XListenerSetPatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o XListenerSetPatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetPatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o XListenerSetPatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetPatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o XListenerSetPatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v XListenerSetPatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o XListenerSetPatchTypeOutput) Spec() XListenerSetSpecPatchPtrOutput {
	return o.ApplyT(func(v XListenerSetPatchType) *XListenerSetSpecPatch { return v.Spec }).(XListenerSetSpecPatchPtrOutput)
}

func (o XListenerSetPatchTypeOutput) Status() XListenerSetStatusPatchPtrOutput {
	return o.ApplyT(func(v XListenerSetPatchType) *XListenerSetStatusPatch { return v.Status }).(XListenerSetStatusPatchPtrOutput)
}

// Spec defines the desired state of ListenerSet.
type XListenerSetSpec struct {
	// Listeners associated with this ListenerSet. Listeners define
	// logical endpoints that are bound on this referenced parent Gateway's addresses.
	//
	// Listeners in a `Gateway` and their attached `ListenerSets` are concatenated
	// as a list when programming the underlying infrastructure. Each listener
	// name does not need to be unique across the Gateway and ListenerSets.
	// See ListenerEntry.Name for more details.
	//
	// Implementations MUST treat the parent Gateway as having the merged
	// list of all listeners from itself and attached ListenerSets using
	// the following precedence:
	//
	// 1. "parent" Gateway
	// 2. ListenerSet ordered by creation time (oldest first)
	// 3. ListenerSet ordered alphabetically by “{namespace}/{name}”.
	//
	// An implementation MAY reject listeners by setting the ListenerEntryStatus
	// ` Accepted`` condition to False with the Reason  `TooManyListeners`
	//
	// If a listener has a conflict, this will be reported in the
	// Status.ListenerEntryStatus setting the `Conflicted` condition to True.
	//
	// Implementations SHOULD be cautious about what information from the
	// parent or siblings are reported to avoid accidentally leaking
	// sensitive information that the child would not otherwise have access
	// to. This can include contents of secrets etc.
	Listeners []XListenerSetSpecListeners `pulumi:"listeners"`
	ParentRef *XListenerSetSpecParentRef  `pulumi:"parentRef"`
}

// XListenerSetSpecInput is an input type that accepts XListenerSetSpecArgs and XListenerSetSpecOutput values.
// You can construct a concrete instance of `XListenerSetSpecInput` via:
//
//	XListenerSetSpecArgs{...}
type XListenerSetSpecInput interface {
	pulumi.Input

	ToXListenerSetSpecOutput() XListenerSetSpecOutput
	ToXListenerSetSpecOutputWithContext(context.Context) XListenerSetSpecOutput
}

// Spec defines the desired state of ListenerSet.
type XListenerSetSpecArgs struct {
	// Listeners associated with this ListenerSet. Listeners define
	// logical endpoints that are bound on this referenced parent Gateway's addresses.
	//
	// Listeners in a `Gateway` and their attached `ListenerSets` are concatenated
	// as a list when programming the underlying infrastructure. Each listener
	// name does not need to be unique across the Gateway and ListenerSets.
	// See ListenerEntry.Name for more details.
	//
	// Implementations MUST treat the parent Gateway as having the merged
	// list of all listeners from itself and attached ListenerSets using
	// the following precedence:
	//
	// 1. "parent" Gateway
	// 2. ListenerSet ordered by creation time (oldest first)
	// 3. ListenerSet ordered alphabetically by “{namespace}/{name}”.
	//
	// An implementation MAY reject listeners by setting the ListenerEntryStatus
	// ` Accepted`` condition to False with the Reason  `TooManyListeners`
	//
	// If a listener has a conflict, this will be reported in the
	// Status.ListenerEntryStatus setting the `Conflicted` condition to True.
	//
	// Implementations SHOULD be cautious about what information from the
	// parent or siblings are reported to avoid accidentally leaking
	// sensitive information that the child would not otherwise have access
	// to. This can include contents of secrets etc.
	Listeners XListenerSetSpecListenersArrayInput `pulumi:"listeners"`
	ParentRef XListenerSetSpecParentRefPtrInput   `pulumi:"parentRef"`
}

func (XListenerSetSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpec)(nil)).Elem()
}

func (i XListenerSetSpecArgs) ToXListenerSetSpecOutput() XListenerSetSpecOutput {
	return i.ToXListenerSetSpecOutputWithContext(context.Background())
}

func (i XListenerSetSpecArgs) ToXListenerSetSpecOutputWithContext(ctx context.Context) XListenerSetSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecOutput)
}

func (i XListenerSetSpecArgs) ToXListenerSetSpecPtrOutput() XListenerSetSpecPtrOutput {
	return i.ToXListenerSetSpecPtrOutputWithContext(context.Background())
}

func (i XListenerSetSpecArgs) ToXListenerSetSpecPtrOutputWithContext(ctx context.Context) XListenerSetSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecOutput).ToXListenerSetSpecPtrOutputWithContext(ctx)
}

// XListenerSetSpecPtrInput is an input type that accepts XListenerSetSpecArgs, XListenerSetSpecPtr and XListenerSetSpecPtrOutput values.
// You can construct a concrete instance of `XListenerSetSpecPtrInput` via:
//
//	        XListenerSetSpecArgs{...}
//
//	or:
//
//	        nil
type XListenerSetSpecPtrInput interface {
	pulumi.Input

	ToXListenerSetSpecPtrOutput() XListenerSetSpecPtrOutput
	ToXListenerSetSpecPtrOutputWithContext(context.Context) XListenerSetSpecPtrOutput
}

type xlistenerSetSpecPtrType XListenerSetSpecArgs

func XListenerSetSpecPtr(v *XListenerSetSpecArgs) XListenerSetSpecPtrInput {
	return (*xlistenerSetSpecPtrType)(v)
}

func (*xlistenerSetSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpec)(nil)).Elem()
}

func (i *xlistenerSetSpecPtrType) ToXListenerSetSpecPtrOutput() XListenerSetSpecPtrOutput {
	return i.ToXListenerSetSpecPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetSpecPtrType) ToXListenerSetSpecPtrOutputWithContext(ctx context.Context) XListenerSetSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecPtrOutput)
}

// Spec defines the desired state of ListenerSet.
type XListenerSetSpecOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpec)(nil)).Elem()
}

func (o XListenerSetSpecOutput) ToXListenerSetSpecOutput() XListenerSetSpecOutput {
	return o
}

func (o XListenerSetSpecOutput) ToXListenerSetSpecOutputWithContext(ctx context.Context) XListenerSetSpecOutput {
	return o
}

func (o XListenerSetSpecOutput) ToXListenerSetSpecPtrOutput() XListenerSetSpecPtrOutput {
	return o.ToXListenerSetSpecPtrOutputWithContext(context.Background())
}

func (o XListenerSetSpecOutput) ToXListenerSetSpecPtrOutputWithContext(ctx context.Context) XListenerSetSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetSpec) *XListenerSetSpec {
		return &v
	}).(XListenerSetSpecPtrOutput)
}

// Listeners associated with this ListenerSet. Listeners define
// logical endpoints that are bound on this referenced parent Gateway's addresses.
//
// Listeners in a `Gateway` and their attached `ListenerSets` are concatenated
// as a list when programming the underlying infrastructure. Each listener
// name does not need to be unique across the Gateway and ListenerSets.
// See ListenerEntry.Name for more details.
//
// Implementations MUST treat the parent Gateway as having the merged
// list of all listeners from itself and attached ListenerSets using
// the following precedence:
//
// 1. "parent" Gateway
// 2. ListenerSet ordered by creation time (oldest first)
// 3. ListenerSet ordered alphabetically by “{namespace}/{name}”.
//
// An implementation MAY reject listeners by setting the ListenerEntryStatus
// ` Accepted“ condition to False with the Reason  `TooManyListeners`
//
// If a listener has a conflict, this will be reported in the
// Status.ListenerEntryStatus setting the `Conflicted` condition to True.
//
// Implementations SHOULD be cautious about what information from the
// parent or siblings are reported to avoid accidentally leaking
// sensitive information that the child would not otherwise have access
// to. This can include contents of secrets etc.
func (o XListenerSetSpecOutput) Listeners() XListenerSetSpecListenersArrayOutput {
	return o.ApplyT(func(v XListenerSetSpec) []XListenerSetSpecListeners { return v.Listeners }).(XListenerSetSpecListenersArrayOutput)
}

func (o XListenerSetSpecOutput) ParentRef() XListenerSetSpecParentRefPtrOutput {
	return o.ApplyT(func(v XListenerSetSpec) *XListenerSetSpecParentRef { return v.ParentRef }).(XListenerSetSpecParentRefPtrOutput)
}

type XListenerSetSpecPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpec)(nil)).Elem()
}

func (o XListenerSetSpecPtrOutput) ToXListenerSetSpecPtrOutput() XListenerSetSpecPtrOutput {
	return o
}

func (o XListenerSetSpecPtrOutput) ToXListenerSetSpecPtrOutputWithContext(ctx context.Context) XListenerSetSpecPtrOutput {
	return o
}

func (o XListenerSetSpecPtrOutput) Elem() XListenerSetSpecOutput {
	return o.ApplyT(func(v *XListenerSetSpec) XListenerSetSpec {
		if v != nil {
			return *v
		}
		var ret XListenerSetSpec
		return ret
	}).(XListenerSetSpecOutput)
}

// Listeners associated with this ListenerSet. Listeners define
// logical endpoints that are bound on this referenced parent Gateway's addresses.
//
// Listeners in a `Gateway` and their attached `ListenerSets` are concatenated
// as a list when programming the underlying infrastructure. Each listener
// name does not need to be unique across the Gateway and ListenerSets.
// See ListenerEntry.Name for more details.
//
// Implementations MUST treat the parent Gateway as having the merged
// list of all listeners from itself and attached ListenerSets using
// the following precedence:
//
// 1. "parent" Gateway
// 2. ListenerSet ordered by creation time (oldest first)
// 3. ListenerSet ordered alphabetically by “{namespace}/{name}”.
//
// An implementation MAY reject listeners by setting the ListenerEntryStatus
// ` Accepted“ condition to False with the Reason  `TooManyListeners`
//
// If a listener has a conflict, this will be reported in the
// Status.ListenerEntryStatus setting the `Conflicted` condition to True.
//
// Implementations SHOULD be cautious about what information from the
// parent or siblings are reported to avoid accidentally leaking
// sensitive information that the child would not otherwise have access
// to. This can include contents of secrets etc.
func (o XListenerSetSpecPtrOutput) Listeners() XListenerSetSpecListenersArrayOutput {
	return o.ApplyT(func(v *XListenerSetSpec) []XListenerSetSpecListeners {
		if v == nil {
			return nil
		}
		return v.Listeners
	}).(XListenerSetSpecListenersArrayOutput)
}

func (o XListenerSetSpecPtrOutput) ParentRef() XListenerSetSpecParentRefPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpec) *XListenerSetSpecParentRef {
		if v == nil {
			return nil
		}
		return v.ParentRef
	}).(XListenerSetSpecParentRefPtrOutput)
}

type XListenerSetSpecListeners struct {
	AllowedRoutes *XListenerSetSpecListenersAllowedRoutes `pulumi:"allowedRoutes"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
	//   protocol layers as described above. If an implementation does not
	//   ensure that both the SNI and Host header match the Listener hostname,
	//   it MUST clearly document that.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	Hostname *string `pulumi:"hostname"`
	// Name is the name of the Listener. This name MUST be unique within a
	// ListenerSet.
	//
	// Name is not required to be unique across a Gateway and ListenerSets.
	// Routes can attach to a Listener by having a ListenerSet as a parentRef
	// and setting the SectionName
	Name *string `pulumi:"name"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	Port *int `pulumi:"port"`
	// Protocol specifies the network protocol this listener expects to receive.
	Protocol *string                       `pulumi:"protocol"`
	Tls      *XListenerSetSpecListenersTls `pulumi:"tls"`
}

// XListenerSetSpecListenersInput is an input type that accepts XListenerSetSpecListenersArgs and XListenerSetSpecListenersOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersInput` via:
//
//	XListenerSetSpecListenersArgs{...}
type XListenerSetSpecListenersInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersOutput() XListenerSetSpecListenersOutput
	ToXListenerSetSpecListenersOutputWithContext(context.Context) XListenerSetSpecListenersOutput
}

type XListenerSetSpecListenersArgs struct {
	AllowedRoutes XListenerSetSpecListenersAllowedRoutesPtrInput `pulumi:"allowedRoutes"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
	//   protocol layers as described above. If an implementation does not
	//   ensure that both the SNI and Host header match the Listener hostname,
	//   it MUST clearly document that.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	// Name is the name of the Listener. This name MUST be unique within a
	// ListenerSet.
	//
	// Name is not required to be unique across a Gateway and ListenerSets.
	// Routes can attach to a Listener by having a ListenerSet as a parentRef
	// and setting the SectionName
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Protocol specifies the network protocol this listener expects to receive.
	Protocol pulumi.StringPtrInput                `pulumi:"protocol"`
	Tls      XListenerSetSpecListenersTlsPtrInput `pulumi:"tls"`
}

func (XListenerSetSpecListenersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListeners)(nil)).Elem()
}

func (i XListenerSetSpecListenersArgs) ToXListenerSetSpecListenersOutput() XListenerSetSpecListenersOutput {
	return i.ToXListenerSetSpecListenersOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersArgs) ToXListenerSetSpecListenersOutputWithContext(ctx context.Context) XListenerSetSpecListenersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersOutput)
}

// XListenerSetSpecListenersArrayInput is an input type that accepts XListenerSetSpecListenersArray and XListenerSetSpecListenersArrayOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersArrayInput` via:
//
//	XListenerSetSpecListenersArray{ XListenerSetSpecListenersArgs{...} }
type XListenerSetSpecListenersArrayInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersArrayOutput() XListenerSetSpecListenersArrayOutput
	ToXListenerSetSpecListenersArrayOutputWithContext(context.Context) XListenerSetSpecListenersArrayOutput
}

type XListenerSetSpecListenersArray []XListenerSetSpecListenersInput

func (XListenerSetSpecListenersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListeners)(nil)).Elem()
}

func (i XListenerSetSpecListenersArray) ToXListenerSetSpecListenersArrayOutput() XListenerSetSpecListenersArrayOutput {
	return i.ToXListenerSetSpecListenersArrayOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersArray) ToXListenerSetSpecListenersArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersArrayOutput)
}

type XListenerSetSpecListenersOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListeners)(nil)).Elem()
}

func (o XListenerSetSpecListenersOutput) ToXListenerSetSpecListenersOutput() XListenerSetSpecListenersOutput {
	return o
}

func (o XListenerSetSpecListenersOutput) ToXListenerSetSpecListenersOutputWithContext(ctx context.Context) XListenerSetSpecListenersOutput {
	return o
}

func (o XListenerSetSpecListenersOutput) AllowedRoutes() XListenerSetSpecListenersAllowedRoutesPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListeners) *XListenerSetSpecListenersAllowedRoutes { return v.AllowedRoutes }).(XListenerSetSpecListenersAllowedRoutesPtrOutput)
}

// Hostname specifies the virtual hostname to match for protocol types that
// define this concept. When unspecified, all hostnames are matched. This
// field is ignored for protocols that don't require hostname based
// matching.
//
// Implementations MUST apply Hostname matching appropriately for each of
// the following protocols:
//
//   - TLS: The Listener Hostname MUST match the SNI.
//   - HTTP: The Listener Hostname MUST match the Host header of the request.
//   - HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
//     protocol layers as described above. If an implementation does not
//     ensure that both the SNI and Host header match the Listener hostname,
//     it MUST clearly document that.
//
// For HTTPRoute and TLSRoute resources, there is an interaction with the
// `spec.hostnames` array. When both listener and route specify hostnames,
// there MUST be an intersection between the values for a Route to be
// accepted. For more information, refer to the Route specific Hostnames
// documentation.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
func (o XListenerSetSpecListenersOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListeners) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

// Name is the name of the Listener. This name MUST be unique within a
// ListenerSet.
//
// Name is not required to be unique across a Gateway and ListenerSets.
// Routes can attach to a Listener by having a ListenerSet as a parentRef
// and setting the SectionName
func (o XListenerSetSpecListenersOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListeners) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Port is the network port. Multiple listeners may use the
// same port, subject to the Listener compatibility rules.
func (o XListenerSetSpecListenersOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListeners) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Protocol specifies the network protocol this listener expects to receive.
func (o XListenerSetSpecListenersOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListeners) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

func (o XListenerSetSpecListenersOutput) Tls() XListenerSetSpecListenersTlsPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListeners) *XListenerSetSpecListenersTls { return v.Tls }).(XListenerSetSpecListenersTlsPtrOutput)
}

type XListenerSetSpecListenersArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListeners)(nil)).Elem()
}

func (o XListenerSetSpecListenersArrayOutput) ToXListenerSetSpecListenersArrayOutput() XListenerSetSpecListenersArrayOutput {
	return o
}

func (o XListenerSetSpecListenersArrayOutput) ToXListenerSetSpecListenersArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersArrayOutput {
	return o
}

func (o XListenerSetSpecListenersArrayOutput) Index(i pulumi.IntInput) XListenerSetSpecListenersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetSpecListeners {
		return vs[0].([]XListenerSetSpecListeners)[vs[1].(int)]
	}).(XListenerSetSpecListenersOutput)
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
type XListenerSetSpecListenersAllowedRoutes struct {
	// Kinds specifies the groups and kinds of Routes that are allowed to bind
	// to this Gateway Listener. When unspecified or empty, the kinds of Routes
	// selected are determined using the Listener protocol.
	//
	// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
	// with the application protocol specified in the Listener's Protocol field.
	// If an implementation does not support or recognize this resource type, it
	// MUST set the "ResolvedRefs" condition to False for this Listener with the
	// "InvalidRouteKinds" reason.
	//
	// Support: Core
	Kinds      []XListenerSetSpecListenersAllowedRoutesKinds     `pulumi:"kinds"`
	Namespaces *XListenerSetSpecListenersAllowedRoutesNamespaces `pulumi:"namespaces"`
}

// XListenerSetSpecListenersAllowedRoutesInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesArgs and XListenerSetSpecListenersAllowedRoutesOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesInput` via:
//
//	XListenerSetSpecListenersAllowedRoutesArgs{...}
type XListenerSetSpecListenersAllowedRoutesInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesOutput() XListenerSetSpecListenersAllowedRoutesOutput
	ToXListenerSetSpecListenersAllowedRoutesOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesOutput
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
type XListenerSetSpecListenersAllowedRoutesArgs struct {
	// Kinds specifies the groups and kinds of Routes that are allowed to bind
	// to this Gateway Listener. When unspecified or empty, the kinds of Routes
	// selected are determined using the Listener protocol.
	//
	// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
	// with the application protocol specified in the Listener's Protocol field.
	// If an implementation does not support or recognize this resource type, it
	// MUST set the "ResolvedRefs" condition to False for this Listener with the
	// "InvalidRouteKinds" reason.
	//
	// Support: Core
	Kinds      XListenerSetSpecListenersAllowedRoutesKindsArrayInput    `pulumi:"kinds"`
	Namespaces XListenerSetSpecListenersAllowedRoutesNamespacesPtrInput `pulumi:"namespaces"`
}

func (XListenerSetSpecListenersAllowedRoutesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutes)(nil)).Elem()
}

func (i XListenerSetSpecListenersAllowedRoutesArgs) ToXListenerSetSpecListenersAllowedRoutesOutput() XListenerSetSpecListenersAllowedRoutesOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesArgs) ToXListenerSetSpecListenersAllowedRoutesOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesOutput)
}

func (i XListenerSetSpecListenersAllowedRoutesArgs) ToXListenerSetSpecListenersAllowedRoutesPtrOutput() XListenerSetSpecListenersAllowedRoutesPtrOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesPtrOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesArgs) ToXListenerSetSpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesOutput).ToXListenerSetSpecListenersAllowedRoutesPtrOutputWithContext(ctx)
}

// XListenerSetSpecListenersAllowedRoutesPtrInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesArgs, XListenerSetSpecListenersAllowedRoutesPtr and XListenerSetSpecListenersAllowedRoutesPtrOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesPtrInput` via:
//
//	        XListenerSetSpecListenersAllowedRoutesArgs{...}
//
//	or:
//
//	        nil
type XListenerSetSpecListenersAllowedRoutesPtrInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesPtrOutput() XListenerSetSpecListenersAllowedRoutesPtrOutput
	ToXListenerSetSpecListenersAllowedRoutesPtrOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesPtrOutput
}

type xlistenerSetSpecListenersAllowedRoutesPtrType XListenerSetSpecListenersAllowedRoutesArgs

func XListenerSetSpecListenersAllowedRoutesPtr(v *XListenerSetSpecListenersAllowedRoutesArgs) XListenerSetSpecListenersAllowedRoutesPtrInput {
	return (*xlistenerSetSpecListenersAllowedRoutesPtrType)(v)
}

func (*xlistenerSetSpecListenersAllowedRoutesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersAllowedRoutes)(nil)).Elem()
}

func (i *xlistenerSetSpecListenersAllowedRoutesPtrType) ToXListenerSetSpecListenersAllowedRoutesPtrOutput() XListenerSetSpecListenersAllowedRoutesPtrOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetSpecListenersAllowedRoutesPtrType) ToXListenerSetSpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesPtrOutput)
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
type XListenerSetSpecListenersAllowedRoutesOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutes)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesOutput) ToXListenerSetSpecListenersAllowedRoutesOutput() XListenerSetSpecListenersAllowedRoutesOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesOutput) ToXListenerSetSpecListenersAllowedRoutesOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesOutput) ToXListenerSetSpecListenersAllowedRoutesPtrOutput() XListenerSetSpecListenersAllowedRoutesPtrOutput {
	return o.ToXListenerSetSpecListenersAllowedRoutesPtrOutputWithContext(context.Background())
}

func (o XListenerSetSpecListenersAllowedRoutesOutput) ToXListenerSetSpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetSpecListenersAllowedRoutes) *XListenerSetSpecListenersAllowedRoutes {
		return &v
	}).(XListenerSetSpecListenersAllowedRoutesPtrOutput)
}

// Kinds specifies the groups and kinds of Routes that are allowed to bind
// to this Gateway Listener. When unspecified or empty, the kinds of Routes
// selected are determined using the Listener protocol.
//
// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
// with the application protocol specified in the Listener's Protocol field.
// If an implementation does not support or recognize this resource type, it
// MUST set the "ResolvedRefs" condition to False for this Listener with the
// "InvalidRouteKinds" reason.
//
// Support: Core
func (o XListenerSetSpecListenersAllowedRoutesOutput) Kinds() XListenerSetSpecListenersAllowedRoutesKindsArrayOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutes) []XListenerSetSpecListenersAllowedRoutesKinds {
		return v.Kinds
	}).(XListenerSetSpecListenersAllowedRoutesKindsArrayOutput)
}

func (o XListenerSetSpecListenersAllowedRoutesOutput) Namespaces() XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutes) *XListenerSetSpecListenersAllowedRoutesNamespaces {
		return v.Namespaces
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput)
}

type XListenerSetSpecListenersAllowedRoutesPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersAllowedRoutes)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesPtrOutput) ToXListenerSetSpecListenersAllowedRoutesPtrOutput() XListenerSetSpecListenersAllowedRoutesPtrOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesPtrOutput) ToXListenerSetSpecListenersAllowedRoutesPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesPtrOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesPtrOutput) Elem() XListenerSetSpecListenersAllowedRoutesOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutes) XListenerSetSpecListenersAllowedRoutes {
		if v != nil {
			return *v
		}
		var ret XListenerSetSpecListenersAllowedRoutes
		return ret
	}).(XListenerSetSpecListenersAllowedRoutesOutput)
}

// Kinds specifies the groups and kinds of Routes that are allowed to bind
// to this Gateway Listener. When unspecified or empty, the kinds of Routes
// selected are determined using the Listener protocol.
//
// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
// with the application protocol specified in the Listener's Protocol field.
// If an implementation does not support or recognize this resource type, it
// MUST set the "ResolvedRefs" condition to False for this Listener with the
// "InvalidRouteKinds" reason.
//
// Support: Core
func (o XListenerSetSpecListenersAllowedRoutesPtrOutput) Kinds() XListenerSetSpecListenersAllowedRoutesKindsArrayOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutes) []XListenerSetSpecListenersAllowedRoutesKinds {
		if v == nil {
			return nil
		}
		return v.Kinds
	}).(XListenerSetSpecListenersAllowedRoutesKindsArrayOutput)
}

func (o XListenerSetSpecListenersAllowedRoutesPtrOutput) Namespaces() XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutes) *XListenerSetSpecListenersAllowedRoutesNamespaces {
		if v == nil {
			return nil
		}
		return v.Namespaces
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type XListenerSetSpecListenersAllowedRoutesKinds struct {
	// Group is the group of the Route.
	Group *string `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind *string `pulumi:"kind"`
}

// XListenerSetSpecListenersAllowedRoutesKindsInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesKindsArgs and XListenerSetSpecListenersAllowedRoutesKindsOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesKindsInput` via:
//
//	XListenerSetSpecListenersAllowedRoutesKindsArgs{...}
type XListenerSetSpecListenersAllowedRoutesKindsInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesKindsOutput() XListenerSetSpecListenersAllowedRoutesKindsOutput
	ToXListenerSetSpecListenersAllowedRoutesKindsOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesKindsOutput
}

// RouteGroupKind indicates the group and kind of a Route resource.
type XListenerSetSpecListenersAllowedRoutesKindsArgs struct {
	// Group is the group of the Route.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
}

func (XListenerSetSpecListenersAllowedRoutesKindsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (i XListenerSetSpecListenersAllowedRoutesKindsArgs) ToXListenerSetSpecListenersAllowedRoutesKindsOutput() XListenerSetSpecListenersAllowedRoutesKindsOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesKindsOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesKindsArgs) ToXListenerSetSpecListenersAllowedRoutesKindsOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesKindsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesKindsOutput)
}

// XListenerSetSpecListenersAllowedRoutesKindsArrayInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesKindsArray and XListenerSetSpecListenersAllowedRoutesKindsArrayOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesKindsArrayInput` via:
//
//	XListenerSetSpecListenersAllowedRoutesKindsArray{ XListenerSetSpecListenersAllowedRoutesKindsArgs{...} }
type XListenerSetSpecListenersAllowedRoutesKindsArrayInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesKindsArrayOutput() XListenerSetSpecListenersAllowedRoutesKindsArrayOutput
	ToXListenerSetSpecListenersAllowedRoutesKindsArrayOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesKindsArrayOutput
}

type XListenerSetSpecListenersAllowedRoutesKindsArray []XListenerSetSpecListenersAllowedRoutesKindsInput

func (XListenerSetSpecListenersAllowedRoutesKindsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (i XListenerSetSpecListenersAllowedRoutesKindsArray) ToXListenerSetSpecListenersAllowedRoutesKindsArrayOutput() XListenerSetSpecListenersAllowedRoutesKindsArrayOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesKindsArrayOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesKindsArray) ToXListenerSetSpecListenersAllowedRoutesKindsArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesKindsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesKindsArrayOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type XListenerSetSpecListenersAllowedRoutesKindsOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesKindsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesKindsOutput) ToXListenerSetSpecListenersAllowedRoutesKindsOutput() XListenerSetSpecListenersAllowedRoutesKindsOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesKindsOutput) ToXListenerSetSpecListenersAllowedRoutesKindsOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesKindsOutput {
	return o
}

// Group is the group of the Route.
func (o XListenerSetSpecListenersAllowedRoutesKindsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesKinds) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the Route.
func (o XListenerSetSpecListenersAllowedRoutesKindsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesKinds) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

type XListenerSetSpecListenersAllowedRoutesKindsArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesKindsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersAllowedRoutesKinds)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesKindsArrayOutput) ToXListenerSetSpecListenersAllowedRoutesKindsArrayOutput() XListenerSetSpecListenersAllowedRoutesKindsArrayOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesKindsArrayOutput) ToXListenerSetSpecListenersAllowedRoutesKindsArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesKindsArrayOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesKindsArrayOutput) Index(i pulumi.IntInput) XListenerSetSpecListenersAllowedRoutesKindsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetSpecListenersAllowedRoutesKinds {
		return vs[0].([]XListenerSetSpecListenersAllowedRoutesKinds)[vs[1].(int)]
	}).(XListenerSetSpecListenersAllowedRoutesKindsOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type XListenerSetSpecListenersAllowedRoutesKindsPatch struct {
	// Group is the group of the Route.
	Group *string `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind *string `pulumi:"kind"`
}

// XListenerSetSpecListenersAllowedRoutesKindsPatchInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesKindsPatchArgs and XListenerSetSpecListenersAllowedRoutesKindsPatchOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesKindsPatchInput` via:
//
//	XListenerSetSpecListenersAllowedRoutesKindsPatchArgs{...}
type XListenerSetSpecListenersAllowedRoutesKindsPatchInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesKindsPatchOutput() XListenerSetSpecListenersAllowedRoutesKindsPatchOutput
	ToXListenerSetSpecListenersAllowedRoutesKindsPatchOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesKindsPatchOutput
}

// RouteGroupKind indicates the group and kind of a Route resource.
type XListenerSetSpecListenersAllowedRoutesKindsPatchArgs struct {
	// Group is the group of the Route.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
}

func (XListenerSetSpecListenersAllowedRoutesKindsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesKindsPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersAllowedRoutesKindsPatchArgs) ToXListenerSetSpecListenersAllowedRoutesKindsPatchOutput() XListenerSetSpecListenersAllowedRoutesKindsPatchOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesKindsPatchOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesKindsPatchArgs) ToXListenerSetSpecListenersAllowedRoutesKindsPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesKindsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesKindsPatchOutput)
}

// XListenerSetSpecListenersAllowedRoutesKindsPatchArrayInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesKindsPatchArray and XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesKindsPatchArrayInput` via:
//
//	XListenerSetSpecListenersAllowedRoutesKindsPatchArray{ XListenerSetSpecListenersAllowedRoutesKindsPatchArgs{...} }
type XListenerSetSpecListenersAllowedRoutesKindsPatchArrayInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput() XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput
	ToXListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput
}

type XListenerSetSpecListenersAllowedRoutesKindsPatchArray []XListenerSetSpecListenersAllowedRoutesKindsPatchInput

func (XListenerSetSpecListenersAllowedRoutesKindsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersAllowedRoutesKindsPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersAllowedRoutesKindsPatchArray) ToXListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput() XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesKindsPatchArray) ToXListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type XListenerSetSpecListenersAllowedRoutesKindsPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesKindsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesKindsPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesKindsPatchOutput) ToXListenerSetSpecListenersAllowedRoutesKindsPatchOutput() XListenerSetSpecListenersAllowedRoutesKindsPatchOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesKindsPatchOutput) ToXListenerSetSpecListenersAllowedRoutesKindsPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesKindsPatchOutput {
	return o
}

// Group is the group of the Route.
func (o XListenerSetSpecListenersAllowedRoutesKindsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesKindsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the Route.
func (o XListenerSetSpecListenersAllowedRoutesKindsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesKindsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

type XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersAllowedRoutesKindsPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput) ToXListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput() XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput) ToXListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput) Index(i pulumi.IntInput) XListenerSetSpecListenersAllowedRoutesKindsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetSpecListenersAllowedRoutesKindsPatch {
		return vs[0].([]XListenerSetSpecListenersAllowedRoutesKindsPatch)[vs[1].(int)]
	}).(XListenerSetSpecListenersAllowedRoutesKindsPatchOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type XListenerSetSpecListenersAllowedRoutesNamespaces struct {
	// From indicates where Routes will be selected for this Gateway. Possible
	// values are:
	//
	// * All: Routes in all namespaces may be used by this Gateway.
	// * Selector: Routes in namespaces selected by the selector may be used by
	//   this Gateway.
	// * Same: Only Routes in the same namespace may be used by this Gateway.
	//
	// Support: Core
	From     *string                                                   `pulumi:"from"`
	Selector *XListenerSetSpecListenersAllowedRoutesNamespacesSelector `pulumi:"selector"`
}

// XListenerSetSpecListenersAllowedRoutesNamespacesInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesNamespacesArgs and XListenerSetSpecListenersAllowedRoutesNamespacesOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesNamespacesInput` via:
//
//	XListenerSetSpecListenersAllowedRoutesNamespacesArgs{...}
type XListenerSetSpecListenersAllowedRoutesNamespacesInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesNamespacesOutput() XListenerSetSpecListenersAllowedRoutesNamespacesOutput
	ToXListenerSetSpecListenersAllowedRoutesNamespacesOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesOutput
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type XListenerSetSpecListenersAllowedRoutesNamespacesArgs struct {
	// From indicates where Routes will be selected for this Gateway. Possible
	// values are:
	//
	// * All: Routes in all namespaces may be used by this Gateway.
	// * Selector: Routes in namespaces selected by the selector may be used by
	//   this Gateway.
	// * Same: Only Routes in the same namespace may be used by this Gateway.
	//
	// Support: Core
	From     pulumi.StringPtrInput                                            `pulumi:"from"`
	Selector XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrInput `pulumi:"selector"`
}

func (XListenerSetSpecListenersAllowedRoutesNamespacesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesOutput() XListenerSetSpecListenersAllowedRoutesNamespacesOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesOutput)
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesOutput).ToXListenerSetSpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx)
}

// XListenerSetSpecListenersAllowedRoutesNamespacesPtrInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesNamespacesArgs, XListenerSetSpecListenersAllowedRoutesNamespacesPtr and XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesNamespacesPtrInput` via:
//
//	        XListenerSetSpecListenersAllowedRoutesNamespacesArgs{...}
//
//	or:
//
//	        nil
type XListenerSetSpecListenersAllowedRoutesNamespacesPtrInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput
	ToXListenerSetSpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput
}

type xlistenerSetSpecListenersAllowedRoutesNamespacesPtrType XListenerSetSpecListenersAllowedRoutesNamespacesArgs

func XListenerSetSpecListenersAllowedRoutesNamespacesPtr(v *XListenerSetSpecListenersAllowedRoutesNamespacesArgs) XListenerSetSpecListenersAllowedRoutesNamespacesPtrInput {
	return (*xlistenerSetSpecListenersAllowedRoutesNamespacesPtrType)(v)
}

func (*xlistenerSetSpecListenersAllowedRoutesNamespacesPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (i *xlistenerSetSpecListenersAllowedRoutesNamespacesPtrType) ToXListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetSpecListenersAllowedRoutesNamespacesPtrType) ToXListenerSetSpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type XListenerSetSpecListenersAllowedRoutesNamespacesOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesNamespacesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesOutput() XListenerSetSpecListenersAllowedRoutesNamespacesOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ToXListenerSetSpecListenersAllowedRoutesNamespacesPtrOutputWithContext(context.Background())
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetSpecListenersAllowedRoutesNamespaces) *XListenerSetSpecListenersAllowedRoutesNamespaces {
		return &v
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput)
}

// From indicates where Routes will be selected for this Gateway. Possible
// values are:
//
//   - All: Routes in all namespaces may be used by this Gateway.
//   - Selector: Routes in namespaces selected by the selector may be used by
//     this Gateway.
//   - Same: Only Routes in the same namespace may be used by this Gateway.
//
// Support: Core
func (o XListenerSetSpecListenersAllowedRoutesNamespacesOutput) From() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesNamespaces) *string { return v.From }).(pulumi.StringPtrOutput)
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesOutput) Selector() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesNamespaces) *XListenerSetSpecListenersAllowedRoutesNamespacesSelector {
		return v.Selector
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

type XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersAllowedRoutesNamespaces)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput) Elem() XListenerSetSpecListenersAllowedRoutesNamespacesOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesNamespaces) XListenerSetSpecListenersAllowedRoutesNamespaces {
		if v != nil {
			return *v
		}
		var ret XListenerSetSpecListenersAllowedRoutesNamespaces
		return ret
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesOutput)
}

// From indicates where Routes will be selected for this Gateway. Possible
// values are:
//
//   - All: Routes in all namespaces may be used by this Gateway.
//   - Selector: Routes in namespaces selected by the selector may be used by
//     this Gateway.
//   - Same: Only Routes in the same namespace may be used by this Gateway.
//
// Support: Core
func (o XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput) From() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesNamespaces) *string {
		if v == nil {
			return nil
		}
		return v.From
	}).(pulumi.StringPtrOutput)
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput) Selector() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesNamespaces) *XListenerSetSpecListenersAllowedRoutesNamespacesSelector {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type XListenerSetSpecListenersAllowedRoutesNamespacesPatch struct {
	// From indicates where Routes will be selected for this Gateway. Possible
	// values are:
	//
	// * All: Routes in all namespaces may be used by this Gateway.
	// * Selector: Routes in namespaces selected by the selector may be used by
	//   this Gateway.
	// * Same: Only Routes in the same namespace may be used by this Gateway.
	//
	// Support: Core
	From     *string                                                        `pulumi:"from"`
	Selector *XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch `pulumi:"selector"`
}

// XListenerSetSpecListenersAllowedRoutesNamespacesPatchInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesNamespacesPatchArgs and XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesNamespacesPatchInput` via:
//
//	XListenerSetSpecListenersAllowedRoutesNamespacesPatchArgs{...}
type XListenerSetSpecListenersAllowedRoutesNamespacesPatchInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput() XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput
	ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type XListenerSetSpecListenersAllowedRoutesNamespacesPatchArgs struct {
	// From indicates where Routes will be selected for this Gateway. Possible
	// values are:
	//
	// * All: Routes in all namespaces may be used by this Gateway.
	// * Selector: Routes in namespaces selected by the selector may be used by
	//   this Gateway.
	// * Same: Only Routes in the same namespace may be used by this Gateway.
	//
	// Support: Core
	From     pulumi.StringPtrInput                                                 `pulumi:"from"`
	Selector XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput `pulumi:"selector"`
}

func (XListenerSetSpecListenersAllowedRoutesNamespacesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesPatchArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput() XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesPatchArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput)
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesPatchArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesPatchArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput).ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx)
}

// XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesNamespacesPatchArgs, XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtr and XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrInput` via:
//
//	        XListenerSetSpecListenersAllowedRoutesNamespacesPatchArgs{...}
//
//	or:
//
//	        nil
type XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput
	ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput
}

type xlistenerSetSpecListenersAllowedRoutesNamespacesPatchPtrType XListenerSetSpecListenersAllowedRoutesNamespacesPatchArgs

func XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtr(v *XListenerSetSpecListenersAllowedRoutesNamespacesPatchArgs) XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrInput {
	return (*xlistenerSetSpecListenersAllowedRoutesNamespacesPatchPtrType)(v)
}

func (*xlistenerSetSpecListenersAllowedRoutesNamespacesPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersAllowedRoutesNamespacesPatch)(nil)).Elem()
}

func (i *xlistenerSetSpecListenersAllowedRoutesNamespacesPatchPtrType) ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetSpecListenersAllowedRoutesNamespacesPatchPtrType) ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput)
}

// Namespaces indicates namespaces from which Routes may be attached to this
// Listener. This is restricted to the namespace of this Gateway by default.
//
// Support: Core
type XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput() XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o.ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(context.Background())
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetSpecListenersAllowedRoutesNamespacesPatch) *XListenerSetSpecListenersAllowedRoutesNamespacesPatch {
		return &v
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput)
}

// From indicates where Routes will be selected for this Gateway. Possible
// values are:
//
//   - All: Routes in all namespaces may be used by this Gateway.
//   - Selector: Routes in namespaces selected by the selector may be used by
//     this Gateway.
//   - Same: Only Routes in the same namespace may be used by this Gateway.
//
// Support: Core
func (o XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput) From() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesNamespacesPatch) *string { return v.From }).(pulumi.StringPtrOutput)
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput) Selector() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesNamespacesPatch) *XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch {
		return v.Selector
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput)
}

type XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersAllowedRoutesNamespacesPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput) Elem() XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesNamespacesPatch) XListenerSetSpecListenersAllowedRoutesNamespacesPatch {
		if v != nil {
			return *v
		}
		var ret XListenerSetSpecListenersAllowedRoutesNamespacesPatch
		return ret
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput)
}

// From indicates where Routes will be selected for this Gateway. Possible
// values are:
//
//   - All: Routes in all namespaces may be used by this Gateway.
//   - Selector: Routes in namespaces selected by the selector may be used by
//     this Gateway.
//   - Same: Only Routes in the same namespace may be used by this Gateway.
//
// Support: Core
func (o XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput) From() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesNamespacesPatch) *string {
		if v == nil {
			return nil
		}
		return v.From
	}).(pulumi.StringPtrOutput)
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput) Selector() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesNamespacesPatch) *XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch {
		if v == nil {
			return nil
		}
		return v.Selector
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type XListenerSetSpecListenersAllowedRoutesNamespacesSelector struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// XListenerSetSpecListenersAllowedRoutesNamespacesSelectorInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesNamespacesSelectorArgs and XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesNamespacesSelectorInput` via:
//
//	XListenerSetSpecListenersAllowedRoutesNamespacesSelectorArgs{...}
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput
	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (XListenerSetSpecListenersAllowedRoutesNamespacesSelectorArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput)
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput).ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx)
}

// XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesNamespacesSelectorArgs, XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtr and XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrInput` via:
//
//	        XListenerSetSpecListenersAllowedRoutesNamespacesSelectorArgs{...}
//
//	or:
//
//	        nil
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput
	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput
}

type xlistenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrType XListenerSetSpecListenersAllowedRoutesNamespacesSelectorArgs

func XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtr(v *XListenerSetSpecListenersAllowedRoutesNamespacesSelectorArgs) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrInput {
	return (*xlistenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrType)(v)
}

func (*xlistenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (i *xlistenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrType) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrType) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(context.Background())
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetSpecListenersAllowedRoutesNamespacesSelector) *XListenerSetSpecListenersAllowedRoutesNamespacesSelector {
		return &v
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput) MatchExpressions() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesNamespacesSelector) []XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
		return v.MatchExpressions
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesNamespacesSelector) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersAllowedRoutesNamespacesSelector)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput) Elem() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesNamespacesSelector) XListenerSetSpecListenersAllowedRoutesNamespacesSelector {
		if v != nil {
			return *v
		}
		var ret XListenerSetSpecListenersAllowedRoutesNamespacesSelector
		return ret
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput) MatchExpressions() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesNamespacesSelector) []XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesNamespacesSelector) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs and XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput` via:
//
//	XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs{...}
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput
	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput)
}

// XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray and XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput` via:
//
//	XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray{ XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs{...} }
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput
	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput
}

type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray []XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput

func (XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return o
}

// key is the label key that the selector applies to.
func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions) *string { return v.Key }).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput) Index(i pulumi.IntInput) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions {
		return vs[0].([]XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressions)[vs[1].(int)]
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch struct {
	// key is the label key that the selector applies to.
	Key *string `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator *string `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values []string `pulumi:"values"`
}

// XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs and XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput` via:
//
//	XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs{...}
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput
	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs struct {
	// key is the label key that the selector applies to.
	Key pulumi.StringPtrInput `pulumi:"key"`
	// operator represents a key's relationship to a set of values.
	// Valid operators are In, NotIn, Exists and DoesNotExist.
	Operator pulumi.StringPtrInput `pulumi:"operator"`
	// values is an array of string values. If the operator is In or NotIn,
	// the values array must be non-empty. If the operator is Exists or DoesNotExist,
	// the values array must be empty. This array is replaced during a strategic
	// merge patch.
	Values pulumi.StringArrayInput `pulumi:"values"`
}

func (XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput)
}

// XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray and XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput` via:
//
//	XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray{ XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs{...} }
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput
	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput
}

type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray []XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput

func (XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput)
}

// A label selector requirement is a selector that contains values, a key, and an operator that
// relates the key and values.
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return o
}

// key is the label key that the selector applies to.
func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) Key() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch) *string {
		return v.Key
	}).(pulumi.StringPtrOutput)
}

// operator represents a key's relationship to a set of values.
// Valid operators are In, NotIn, Exists and DoesNotExist.
func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) Operator() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch) *string {
		return v.Operator
	}).(pulumi.StringPtrOutput)
}

// values is an array of string values. If the operator is In or NotIn,
// the values array must be non-empty. If the operator is Exists or DoesNotExist,
// the values array must be empty. This array is replaced during a strategic
// merge patch.
func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput) Values() pulumi.StringArrayOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch) []string {
		return v.Values
	}).(pulumi.StringArrayOutput)
}

type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput) Index(i pulumi.IntInput) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch {
		return vs[0].([]XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch)[vs[1].(int)]
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions []XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels map[string]string `pulumi:"matchLabels"`
}

// XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchArgs and XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchInput` via:
//
//	XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchArgs{...}
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput
	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchArgs struct {
	// matchExpressions is a list of label selector requirements. The requirements are ANDed.
	MatchExpressions XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput `pulumi:"matchExpressions"`
	// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
	// map is equivalent to an element of matchExpressions, whose key field is "key", the
	// operator is "In", and the values array contains only "value". The requirements are ANDed.
	MatchLabels pulumi.StringMapInput `pulumi:"matchLabels"`
}

func (XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput)
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchArgs) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput).ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx)
}

// XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchArgs, XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtr and XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput` via:
//
//	        XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchArgs{...}
//
//	or:
//
//	        nil
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput
	ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput
}

type xlistenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrType XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchArgs

func XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtr(v *XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchArgs) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput {
	return (*xlistenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrType)(v)
}

func (*xlistenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch)(nil)).Elem()
}

func (i *xlistenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrType) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrType) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput)
}

// Selector must be specified when From is set to "Selector". In that case,
// only Routes in Namespaces matching this Selector will be selected by this
// Gateway. This field is ignored for other values of "From".
//
// Support: Core
type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o.ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(context.Background())
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch) *XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch {
		return &v
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput) MatchExpressions() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch) []XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch {
		return v.MatchExpressions
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch) map[string]string {
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

type XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) ToXListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) Elem() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch) XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch {
		if v != nil {
			return *v
		}
		var ret XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch
		return ret
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput)
}

// matchExpressions is a list of label selector requirements. The requirements are ANDed.
func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) MatchExpressions() XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch) []XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatch {
		if v == nil {
			return nil
		}
		return v.MatchExpressions
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput)
}

// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
// map is equivalent to an element of matchExpressions, whose key field is "key", the
// operator is "In", and the values array contains only "value". The requirements are ANDed.
func (o XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput) MatchLabels() pulumi.StringMapOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.MatchLabels
	}).(pulumi.StringMapOutput)
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
type XListenerSetSpecListenersAllowedRoutesPatch struct {
	// Kinds specifies the groups and kinds of Routes that are allowed to bind
	// to this Gateway Listener. When unspecified or empty, the kinds of Routes
	// selected are determined using the Listener protocol.
	//
	// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
	// with the application protocol specified in the Listener's Protocol field.
	// If an implementation does not support or recognize this resource type, it
	// MUST set the "ResolvedRefs" condition to False for this Listener with the
	// "InvalidRouteKinds" reason.
	//
	// Support: Core
	Kinds      []XListenerSetSpecListenersAllowedRoutesKindsPatch     `pulumi:"kinds"`
	Namespaces *XListenerSetSpecListenersAllowedRoutesNamespacesPatch `pulumi:"namespaces"`
}

// XListenerSetSpecListenersAllowedRoutesPatchInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesPatchArgs and XListenerSetSpecListenersAllowedRoutesPatchOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesPatchInput` via:
//
//	XListenerSetSpecListenersAllowedRoutesPatchArgs{...}
type XListenerSetSpecListenersAllowedRoutesPatchInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesPatchOutput() XListenerSetSpecListenersAllowedRoutesPatchOutput
	ToXListenerSetSpecListenersAllowedRoutesPatchOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesPatchOutput
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
type XListenerSetSpecListenersAllowedRoutesPatchArgs struct {
	// Kinds specifies the groups and kinds of Routes that are allowed to bind
	// to this Gateway Listener. When unspecified or empty, the kinds of Routes
	// selected are determined using the Listener protocol.
	//
	// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
	// with the application protocol specified in the Listener's Protocol field.
	// If an implementation does not support or recognize this resource type, it
	// MUST set the "ResolvedRefs" condition to False for this Listener with the
	// "InvalidRouteKinds" reason.
	//
	// Support: Core
	Kinds      XListenerSetSpecListenersAllowedRoutesKindsPatchArrayInput    `pulumi:"kinds"`
	Namespaces XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrInput `pulumi:"namespaces"`
}

func (XListenerSetSpecListenersAllowedRoutesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersAllowedRoutesPatchArgs) ToXListenerSetSpecListenersAllowedRoutesPatchOutput() XListenerSetSpecListenersAllowedRoutesPatchOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesPatchOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesPatchArgs) ToXListenerSetSpecListenersAllowedRoutesPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesPatchOutput)
}

func (i XListenerSetSpecListenersAllowedRoutesPatchArgs) ToXListenerSetSpecListenersAllowedRoutesPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesPatchPtrOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesPatchPtrOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersAllowedRoutesPatchArgs) ToXListenerSetSpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesPatchOutput).ToXListenerSetSpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx)
}

// XListenerSetSpecListenersAllowedRoutesPatchPtrInput is an input type that accepts XListenerSetSpecListenersAllowedRoutesPatchArgs, XListenerSetSpecListenersAllowedRoutesPatchPtr and XListenerSetSpecListenersAllowedRoutesPatchPtrOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersAllowedRoutesPatchPtrInput` via:
//
//	        XListenerSetSpecListenersAllowedRoutesPatchArgs{...}
//
//	or:
//
//	        nil
type XListenerSetSpecListenersAllowedRoutesPatchPtrInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersAllowedRoutesPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesPatchPtrOutput
	ToXListenerSetSpecListenersAllowedRoutesPatchPtrOutputWithContext(context.Context) XListenerSetSpecListenersAllowedRoutesPatchPtrOutput
}

type xlistenerSetSpecListenersAllowedRoutesPatchPtrType XListenerSetSpecListenersAllowedRoutesPatchArgs

func XListenerSetSpecListenersAllowedRoutesPatchPtr(v *XListenerSetSpecListenersAllowedRoutesPatchArgs) XListenerSetSpecListenersAllowedRoutesPatchPtrInput {
	return (*xlistenerSetSpecListenersAllowedRoutesPatchPtrType)(v)
}

func (*xlistenerSetSpecListenersAllowedRoutesPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersAllowedRoutesPatch)(nil)).Elem()
}

func (i *xlistenerSetSpecListenersAllowedRoutesPatchPtrType) ToXListenerSetSpecListenersAllowedRoutesPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesPatchPtrOutput {
	return i.ToXListenerSetSpecListenersAllowedRoutesPatchPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetSpecListenersAllowedRoutesPatchPtrType) ToXListenerSetSpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersAllowedRoutesPatchPtrOutput)
}

// AllowedRoutes defines the types of routes that MAY be attached to a
// Listener and the trusted namespaces where those Route resources MAY be
// present.
//
// Although a client request may match multiple route rules, only one rule
// may ultimately receive the request. Matching precedence MUST be
// determined in order of the following criteria:
//
//   - The most specific match as defined by the Route type.
//   - The oldest Route based on creation timestamp. For example, a Route with
//     a creation timestamp of "2020-09-08 01:02:03" is given precedence over
//     a Route with a creation timestamp of "2020-09-08 01:02:04".
//   - If everything else is equivalent, the Route appearing first in
//     alphabetical order (namespace/name) should be given precedence. For
//     example, foo/bar is given precedence over foo/baz.
//
// All valid rules within a Route attached to this Listener should be
// implemented. Invalid Route rules can be ignored (sometimes that will mean
// the full Route). If a Route rule transitions from valid to invalid,
// support for that Route rule should be dropped to ensure consistency. For
// example, even if a filter specified by a Route rule is invalid, the rest
// of the rules within that Route should still be supported.
type XListenerSetSpecListenersAllowedRoutesPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesPatchOutput) ToXListenerSetSpecListenersAllowedRoutesPatchOutput() XListenerSetSpecListenersAllowedRoutesPatchOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesPatchOutput) ToXListenerSetSpecListenersAllowedRoutesPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesPatchOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesPatchOutput) ToXListenerSetSpecListenersAllowedRoutesPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesPatchPtrOutput {
	return o.ToXListenerSetSpecListenersAllowedRoutesPatchPtrOutputWithContext(context.Background())
}

func (o XListenerSetSpecListenersAllowedRoutesPatchOutput) ToXListenerSetSpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetSpecListenersAllowedRoutesPatch) *XListenerSetSpecListenersAllowedRoutesPatch {
		return &v
	}).(XListenerSetSpecListenersAllowedRoutesPatchPtrOutput)
}

// Kinds specifies the groups and kinds of Routes that are allowed to bind
// to this Gateway Listener. When unspecified or empty, the kinds of Routes
// selected are determined using the Listener protocol.
//
// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
// with the application protocol specified in the Listener's Protocol field.
// If an implementation does not support or recognize this resource type, it
// MUST set the "ResolvedRefs" condition to False for this Listener with the
// "InvalidRouteKinds" reason.
//
// Support: Core
func (o XListenerSetSpecListenersAllowedRoutesPatchOutput) Kinds() XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesPatch) []XListenerSetSpecListenersAllowedRoutesKindsPatch {
		return v.Kinds
	}).(XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput)
}

func (o XListenerSetSpecListenersAllowedRoutesPatchOutput) Namespaces() XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersAllowedRoutesPatch) *XListenerSetSpecListenersAllowedRoutesNamespacesPatch {
		return v.Namespaces
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput)
}

type XListenerSetSpecListenersAllowedRoutesPatchPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersAllowedRoutesPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersAllowedRoutesPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersAllowedRoutesPatchPtrOutput) ToXListenerSetSpecListenersAllowedRoutesPatchPtrOutput() XListenerSetSpecListenersAllowedRoutesPatchPtrOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesPatchPtrOutput) ToXListenerSetSpecListenersAllowedRoutesPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersAllowedRoutesPatchPtrOutput {
	return o
}

func (o XListenerSetSpecListenersAllowedRoutesPatchPtrOutput) Elem() XListenerSetSpecListenersAllowedRoutesPatchOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesPatch) XListenerSetSpecListenersAllowedRoutesPatch {
		if v != nil {
			return *v
		}
		var ret XListenerSetSpecListenersAllowedRoutesPatch
		return ret
	}).(XListenerSetSpecListenersAllowedRoutesPatchOutput)
}

// Kinds specifies the groups and kinds of Routes that are allowed to bind
// to this Gateway Listener. When unspecified or empty, the kinds of Routes
// selected are determined using the Listener protocol.
//
// A RouteGroupKind MUST correspond to kinds of Routes that are compatible
// with the application protocol specified in the Listener's Protocol field.
// If an implementation does not support or recognize this resource type, it
// MUST set the "ResolvedRefs" condition to False for this Listener with the
// "InvalidRouteKinds" reason.
//
// Support: Core
func (o XListenerSetSpecListenersAllowedRoutesPatchPtrOutput) Kinds() XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesPatch) []XListenerSetSpecListenersAllowedRoutesKindsPatch {
		if v == nil {
			return nil
		}
		return v.Kinds
	}).(XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput)
}

func (o XListenerSetSpecListenersAllowedRoutesPatchPtrOutput) Namespaces() XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersAllowedRoutesPatch) *XListenerSetSpecListenersAllowedRoutesNamespacesPatch {
		if v == nil {
			return nil
		}
		return v.Namespaces
	}).(XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput)
}

type XListenerSetSpecListenersPatch struct {
	AllowedRoutes *XListenerSetSpecListenersAllowedRoutesPatch `pulumi:"allowedRoutes"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
	//   protocol layers as described above. If an implementation does not
	//   ensure that both the SNI and Host header match the Listener hostname,
	//   it MUST clearly document that.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	Hostname *string `pulumi:"hostname"`
	// Name is the name of the Listener. This name MUST be unique within a
	// ListenerSet.
	//
	// Name is not required to be unique across a Gateway and ListenerSets.
	// Routes can attach to a Listener by having a ListenerSet as a parentRef
	// and setting the SectionName
	Name *string `pulumi:"name"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	Port *int `pulumi:"port"`
	// Protocol specifies the network protocol this listener expects to receive.
	Protocol *string                            `pulumi:"protocol"`
	Tls      *XListenerSetSpecListenersTlsPatch `pulumi:"tls"`
}

// XListenerSetSpecListenersPatchInput is an input type that accepts XListenerSetSpecListenersPatchArgs and XListenerSetSpecListenersPatchOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersPatchInput` via:
//
//	XListenerSetSpecListenersPatchArgs{...}
type XListenerSetSpecListenersPatchInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersPatchOutput() XListenerSetSpecListenersPatchOutput
	ToXListenerSetSpecListenersPatchOutputWithContext(context.Context) XListenerSetSpecListenersPatchOutput
}

type XListenerSetSpecListenersPatchArgs struct {
	AllowedRoutes XListenerSetSpecListenersAllowedRoutesPatchPtrInput `pulumi:"allowedRoutes"`
	// Hostname specifies the virtual hostname to match for protocol types that
	// define this concept. When unspecified, all hostnames are matched. This
	// field is ignored for protocols that don't require hostname based
	// matching.
	//
	// Implementations MUST apply Hostname matching appropriately for each of
	// the following protocols:
	//
	// * TLS: The Listener Hostname MUST match the SNI.
	// * HTTP: The Listener Hostname MUST match the Host header of the request.
	// * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
	//   protocol layers as described above. If an implementation does not
	//   ensure that both the SNI and Host header match the Listener hostname,
	//   it MUST clearly document that.
	//
	// For HTTPRoute and TLSRoute resources, there is an interaction with the
	// `spec.hostnames` array. When both listener and route specify hostnames,
	// there MUST be an intersection between the values for a Route to be
	// accepted. For more information, refer to the Route specific Hostnames
	// documentation.
	//
	// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
	// as a suffix match. That means that a match for `*.example.com` would match
	// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
	Hostname pulumi.StringPtrInput `pulumi:"hostname"`
	// Name is the name of the Listener. This name MUST be unique within a
	// ListenerSet.
	//
	// Name is not required to be unique across a Gateway and ListenerSets.
	// Routes can attach to a Listener by having a ListenerSet as a parentRef
	// and setting the SectionName
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Port is the network port. Multiple listeners may use the
	// same port, subject to the Listener compatibility rules.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Protocol specifies the network protocol this listener expects to receive.
	Protocol pulumi.StringPtrInput                     `pulumi:"protocol"`
	Tls      XListenerSetSpecListenersTlsPatchPtrInput `pulumi:"tls"`
}

func (XListenerSetSpecListenersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersPatchArgs) ToXListenerSetSpecListenersPatchOutput() XListenerSetSpecListenersPatchOutput {
	return i.ToXListenerSetSpecListenersPatchOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersPatchArgs) ToXListenerSetSpecListenersPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersPatchOutput)
}

// XListenerSetSpecListenersPatchArrayInput is an input type that accepts XListenerSetSpecListenersPatchArray and XListenerSetSpecListenersPatchArrayOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersPatchArrayInput` via:
//
//	XListenerSetSpecListenersPatchArray{ XListenerSetSpecListenersPatchArgs{...} }
type XListenerSetSpecListenersPatchArrayInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersPatchArrayOutput() XListenerSetSpecListenersPatchArrayOutput
	ToXListenerSetSpecListenersPatchArrayOutputWithContext(context.Context) XListenerSetSpecListenersPatchArrayOutput
}

type XListenerSetSpecListenersPatchArray []XListenerSetSpecListenersPatchInput

func (XListenerSetSpecListenersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersPatchArray) ToXListenerSetSpecListenersPatchArrayOutput() XListenerSetSpecListenersPatchArrayOutput {
	return i.ToXListenerSetSpecListenersPatchArrayOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersPatchArray) ToXListenerSetSpecListenersPatchArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersPatchArrayOutput)
}

type XListenerSetSpecListenersPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersPatchOutput) ToXListenerSetSpecListenersPatchOutput() XListenerSetSpecListenersPatchOutput {
	return o
}

func (o XListenerSetSpecListenersPatchOutput) ToXListenerSetSpecListenersPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersPatchOutput {
	return o
}

func (o XListenerSetSpecListenersPatchOutput) AllowedRoutes() XListenerSetSpecListenersAllowedRoutesPatchPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersPatch) *XListenerSetSpecListenersAllowedRoutesPatch {
		return v.AllowedRoutes
	}).(XListenerSetSpecListenersAllowedRoutesPatchPtrOutput)
}

// Hostname specifies the virtual hostname to match for protocol types that
// define this concept. When unspecified, all hostnames are matched. This
// field is ignored for protocols that don't require hostname based
// matching.
//
// Implementations MUST apply Hostname matching appropriately for each of
// the following protocols:
//
//   - TLS: The Listener Hostname MUST match the SNI.
//   - HTTP: The Listener Hostname MUST match the Host header of the request.
//   - HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
//     protocol layers as described above. If an implementation does not
//     ensure that both the SNI and Host header match the Listener hostname,
//     it MUST clearly document that.
//
// For HTTPRoute and TLSRoute resources, there is an interaction with the
// `spec.hostnames` array. When both listener and route specify hostnames,
// there MUST be an intersection between the values for a Route to be
// accepted. For more information, refer to the Route specific Hostnames
// documentation.
//
// Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
// as a suffix match. That means that a match for `*.example.com` would match
// both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
func (o XListenerSetSpecListenersPatchOutput) Hostname() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersPatch) *string { return v.Hostname }).(pulumi.StringPtrOutput)
}

// Name is the name of the Listener. This name MUST be unique within a
// ListenerSet.
//
// Name is not required to be unique across a Gateway and ListenerSets.
// Routes can attach to a Listener by having a ListenerSet as a parentRef
// and setting the SectionName
func (o XListenerSetSpecListenersPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Port is the network port. Multiple listeners may use the
// same port, subject to the Listener compatibility rules.
func (o XListenerSetSpecListenersPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Protocol specifies the network protocol this listener expects to receive.
func (o XListenerSetSpecListenersPatchOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersPatch) *string { return v.Protocol }).(pulumi.StringPtrOutput)
}

func (o XListenerSetSpecListenersPatchOutput) Tls() XListenerSetSpecListenersTlsPatchPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersPatch) *XListenerSetSpecListenersTlsPatch { return v.Tls }).(XListenerSetSpecListenersTlsPatchPtrOutput)
}

type XListenerSetSpecListenersPatchArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersPatchArrayOutput) ToXListenerSetSpecListenersPatchArrayOutput() XListenerSetSpecListenersPatchArrayOutput {
	return o
}

func (o XListenerSetSpecListenersPatchArrayOutput) ToXListenerSetSpecListenersPatchArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersPatchArrayOutput {
	return o
}

func (o XListenerSetSpecListenersPatchArrayOutput) Index(i pulumi.IntInput) XListenerSetSpecListenersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetSpecListenersPatch {
		return vs[0].([]XListenerSetSpecListenersPatch)[vs[1].(int)]
	}).(XListenerSetSpecListenersPatchOutput)
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
type XListenerSetSpecListenersTls struct {
	// CertificateRefs contains a series of references to Kubernetes objects that
	// contains TLS certificates and private keys. These certificates are used to
	// establish a TLS handshake for requests that match the hostname of the
	// associated listener.
	//
	// A single CertificateRef to a Kubernetes Secret has "Core" support.
	// Implementations MAY choose to support attaching multiple certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// References to a resource in different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	//
	// This field is required to have at least one element when the mode is set
	// to "Terminate" (default) and is optional otherwise.
	//
	// CertificateRefs can reference to standard Kubernetes resources, i.e.
	// Secret, or implementation-specific custom resources.
	//
	// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
	//
	// Support: Implementation-specific (More than one reference or other resource types)
	CertificateRefs    []XListenerSetSpecListenersTlsCertificateRefs   `pulumi:"certificateRefs"`
	FrontendValidation *XListenerSetSpecListenersTlsFrontendValidation `pulumi:"frontendValidation"`
	// Mode defines the TLS behavior for the TLS session initiated by the client.
	// There are two possible modes:
	//
	// - Terminate: The TLS session between the downstream client and the
	//   Gateway is terminated at the Gateway. This mode requires certificates
	//   to be specified in some way, such as populating the certificateRefs
	//   field.
	// - Passthrough: The TLS session is NOT terminated by the Gateway. This
	//   implies that the Gateway can't decipher the TLS stream except for
	//   the ClientHello message of the TLS protocol. The certificateRefs field
	//   is ignored in this mode.
	//
	// Support: Core
	Mode *string `pulumi:"mode"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options map[string]string `pulumi:"options"`
}

// XListenerSetSpecListenersTlsInput is an input type that accepts XListenerSetSpecListenersTlsArgs and XListenerSetSpecListenersTlsOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsInput` via:
//
//	XListenerSetSpecListenersTlsArgs{...}
type XListenerSetSpecListenersTlsInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsOutput() XListenerSetSpecListenersTlsOutput
	ToXListenerSetSpecListenersTlsOutputWithContext(context.Context) XListenerSetSpecListenersTlsOutput
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
type XListenerSetSpecListenersTlsArgs struct {
	// CertificateRefs contains a series of references to Kubernetes objects that
	// contains TLS certificates and private keys. These certificates are used to
	// establish a TLS handshake for requests that match the hostname of the
	// associated listener.
	//
	// A single CertificateRef to a Kubernetes Secret has "Core" support.
	// Implementations MAY choose to support attaching multiple certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// References to a resource in different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	//
	// This field is required to have at least one element when the mode is set
	// to "Terminate" (default) and is optional otherwise.
	//
	// CertificateRefs can reference to standard Kubernetes resources, i.e.
	// Secret, or implementation-specific custom resources.
	//
	// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
	//
	// Support: Implementation-specific (More than one reference or other resource types)
	CertificateRefs    XListenerSetSpecListenersTlsCertificateRefsArrayInput  `pulumi:"certificateRefs"`
	FrontendValidation XListenerSetSpecListenersTlsFrontendValidationPtrInput `pulumi:"frontendValidation"`
	// Mode defines the TLS behavior for the TLS session initiated by the client.
	// There are two possible modes:
	//
	// - Terminate: The TLS session between the downstream client and the
	//   Gateway is terminated at the Gateway. This mode requires certificates
	//   to be specified in some way, such as populating the certificateRefs
	//   field.
	// - Passthrough: The TLS session is NOT terminated by the Gateway. This
	//   implies that the Gateway can't decipher the TLS stream except for
	//   the ClientHello message of the TLS protocol. The certificateRefs field
	//   is ignored in this mode.
	//
	// Support: Core
	Mode pulumi.StringPtrInput `pulumi:"mode"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options pulumi.StringMapInput `pulumi:"options"`
}

func (XListenerSetSpecListenersTlsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTls)(nil)).Elem()
}

func (i XListenerSetSpecListenersTlsArgs) ToXListenerSetSpecListenersTlsOutput() XListenerSetSpecListenersTlsOutput {
	return i.ToXListenerSetSpecListenersTlsOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsArgs) ToXListenerSetSpecListenersTlsOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsOutput)
}

func (i XListenerSetSpecListenersTlsArgs) ToXListenerSetSpecListenersTlsPtrOutput() XListenerSetSpecListenersTlsPtrOutput {
	return i.ToXListenerSetSpecListenersTlsPtrOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsArgs) ToXListenerSetSpecListenersTlsPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsOutput).ToXListenerSetSpecListenersTlsPtrOutputWithContext(ctx)
}

// XListenerSetSpecListenersTlsPtrInput is an input type that accepts XListenerSetSpecListenersTlsArgs, XListenerSetSpecListenersTlsPtr and XListenerSetSpecListenersTlsPtrOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsPtrInput` via:
//
//	        XListenerSetSpecListenersTlsArgs{...}
//
//	or:
//
//	        nil
type XListenerSetSpecListenersTlsPtrInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsPtrOutput() XListenerSetSpecListenersTlsPtrOutput
	ToXListenerSetSpecListenersTlsPtrOutputWithContext(context.Context) XListenerSetSpecListenersTlsPtrOutput
}

type xlistenerSetSpecListenersTlsPtrType XListenerSetSpecListenersTlsArgs

func XListenerSetSpecListenersTlsPtr(v *XListenerSetSpecListenersTlsArgs) XListenerSetSpecListenersTlsPtrInput {
	return (*xlistenerSetSpecListenersTlsPtrType)(v)
}

func (*xlistenerSetSpecListenersTlsPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersTls)(nil)).Elem()
}

func (i *xlistenerSetSpecListenersTlsPtrType) ToXListenerSetSpecListenersTlsPtrOutput() XListenerSetSpecListenersTlsPtrOutput {
	return i.ToXListenerSetSpecListenersTlsPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetSpecListenersTlsPtrType) ToXListenerSetSpecListenersTlsPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsPtrOutput)
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
type XListenerSetSpecListenersTlsOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTls)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsOutput) ToXListenerSetSpecListenersTlsOutput() XListenerSetSpecListenersTlsOutput {
	return o
}

func (o XListenerSetSpecListenersTlsOutput) ToXListenerSetSpecListenersTlsOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsOutput {
	return o
}

func (o XListenerSetSpecListenersTlsOutput) ToXListenerSetSpecListenersTlsPtrOutput() XListenerSetSpecListenersTlsPtrOutput {
	return o.ToXListenerSetSpecListenersTlsPtrOutputWithContext(context.Background())
}

func (o XListenerSetSpecListenersTlsOutput) ToXListenerSetSpecListenersTlsPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetSpecListenersTls) *XListenerSetSpecListenersTls {
		return &v
	}).(XListenerSetSpecListenersTlsPtrOutput)
}

// CertificateRefs contains a series of references to Kubernetes objects that
// contains TLS certificates and private keys. These certificates are used to
// establish a TLS handshake for requests that match the hostname of the
// associated listener.
//
// A single CertificateRef to a Kubernetes Secret has "Core" support.
// Implementations MAY choose to support attaching multiple certificates to
// a Listener, but this behavior is implementation-specific.
//
// References to a resource in different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
//
// This field is required to have at least one element when the mode is set
// to "Terminate" (default) and is optional otherwise.
//
// CertificateRefs can reference to standard Kubernetes resources, i.e.
// Secret, or implementation-specific custom resources.
//
// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
//
// Support: Implementation-specific (More than one reference or other resource types)
func (o XListenerSetSpecListenersTlsOutput) CertificateRefs() XListenerSetSpecListenersTlsCertificateRefsArrayOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTls) []XListenerSetSpecListenersTlsCertificateRefs {
		return v.CertificateRefs
	}).(XListenerSetSpecListenersTlsCertificateRefsArrayOutput)
}

func (o XListenerSetSpecListenersTlsOutput) FrontendValidation() XListenerSetSpecListenersTlsFrontendValidationPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTls) *XListenerSetSpecListenersTlsFrontendValidation {
		return v.FrontendValidation
	}).(XListenerSetSpecListenersTlsFrontendValidationPtrOutput)
}

// Mode defines the TLS behavior for the TLS session initiated by the client.
// There are two possible modes:
//
//   - Terminate: The TLS session between the downstream client and the
//     Gateway is terminated at the Gateway. This mode requires certificates
//     to be specified in some way, such as populating the certificateRefs
//     field.
//   - Passthrough: The TLS session is NOT terminated by the Gateway. This
//     implies that the Gateway can't decipher the TLS stream except for
//     the ClientHello message of the TLS protocol. The certificateRefs field
//     is ignored in this mode.
//
// Support: Core
func (o XListenerSetSpecListenersTlsOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTls) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
func (o XListenerSetSpecListenersTlsOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTls) map[string]string { return v.Options }).(pulumi.StringMapOutput)
}

type XListenerSetSpecListenersTlsPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersTls)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsPtrOutput) ToXListenerSetSpecListenersTlsPtrOutput() XListenerSetSpecListenersTlsPtrOutput {
	return o
}

func (o XListenerSetSpecListenersTlsPtrOutput) ToXListenerSetSpecListenersTlsPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsPtrOutput {
	return o
}

func (o XListenerSetSpecListenersTlsPtrOutput) Elem() XListenerSetSpecListenersTlsOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersTls) XListenerSetSpecListenersTls {
		if v != nil {
			return *v
		}
		var ret XListenerSetSpecListenersTls
		return ret
	}).(XListenerSetSpecListenersTlsOutput)
}

// CertificateRefs contains a series of references to Kubernetes objects that
// contains TLS certificates and private keys. These certificates are used to
// establish a TLS handshake for requests that match the hostname of the
// associated listener.
//
// A single CertificateRef to a Kubernetes Secret has "Core" support.
// Implementations MAY choose to support attaching multiple certificates to
// a Listener, but this behavior is implementation-specific.
//
// References to a resource in different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
//
// This field is required to have at least one element when the mode is set
// to "Terminate" (default) and is optional otherwise.
//
// CertificateRefs can reference to standard Kubernetes resources, i.e.
// Secret, or implementation-specific custom resources.
//
// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
//
// Support: Implementation-specific (More than one reference or other resource types)
func (o XListenerSetSpecListenersTlsPtrOutput) CertificateRefs() XListenerSetSpecListenersTlsCertificateRefsArrayOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersTls) []XListenerSetSpecListenersTlsCertificateRefs {
		if v == nil {
			return nil
		}
		return v.CertificateRefs
	}).(XListenerSetSpecListenersTlsCertificateRefsArrayOutput)
}

func (o XListenerSetSpecListenersTlsPtrOutput) FrontendValidation() XListenerSetSpecListenersTlsFrontendValidationPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersTls) *XListenerSetSpecListenersTlsFrontendValidation {
		if v == nil {
			return nil
		}
		return v.FrontendValidation
	}).(XListenerSetSpecListenersTlsFrontendValidationPtrOutput)
}

// Mode defines the TLS behavior for the TLS session initiated by the client.
// There are two possible modes:
//
//   - Terminate: The TLS session between the downstream client and the
//     Gateway is terminated at the Gateway. This mode requires certificates
//     to be specified in some way, such as populating the certificateRefs
//     field.
//   - Passthrough: The TLS session is NOT terminated by the Gateway. This
//     implies that the Gateway can't decipher the TLS stream except for
//     the ClientHello message of the TLS protocol. The certificateRefs field
//     is ignored in this mode.
//
// Support: Core
func (o XListenerSetSpecListenersTlsPtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersTls) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
func (o XListenerSetSpecListenersTlsPtrOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersTls) map[string]string {
		if v == nil {
			return nil
		}
		return v.Options
	}).(pulumi.StringMapOutput)
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type XListenerSetSpecListenersTlsCertificateRefs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "Secret".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
}

// XListenerSetSpecListenersTlsCertificateRefsInput is an input type that accepts XListenerSetSpecListenersTlsCertificateRefsArgs and XListenerSetSpecListenersTlsCertificateRefsOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsCertificateRefsInput` via:
//
//	XListenerSetSpecListenersTlsCertificateRefsArgs{...}
type XListenerSetSpecListenersTlsCertificateRefsInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsCertificateRefsOutput() XListenerSetSpecListenersTlsCertificateRefsOutput
	ToXListenerSetSpecListenersTlsCertificateRefsOutputWithContext(context.Context) XListenerSetSpecListenersTlsCertificateRefsOutput
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type XListenerSetSpecListenersTlsCertificateRefsArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "Secret".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (XListenerSetSpecListenersTlsCertificateRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (i XListenerSetSpecListenersTlsCertificateRefsArgs) ToXListenerSetSpecListenersTlsCertificateRefsOutput() XListenerSetSpecListenersTlsCertificateRefsOutput {
	return i.ToXListenerSetSpecListenersTlsCertificateRefsOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsCertificateRefsArgs) ToXListenerSetSpecListenersTlsCertificateRefsOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsCertificateRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsCertificateRefsOutput)
}

// XListenerSetSpecListenersTlsCertificateRefsArrayInput is an input type that accepts XListenerSetSpecListenersTlsCertificateRefsArray and XListenerSetSpecListenersTlsCertificateRefsArrayOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsCertificateRefsArrayInput` via:
//
//	XListenerSetSpecListenersTlsCertificateRefsArray{ XListenerSetSpecListenersTlsCertificateRefsArgs{...} }
type XListenerSetSpecListenersTlsCertificateRefsArrayInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsCertificateRefsArrayOutput() XListenerSetSpecListenersTlsCertificateRefsArrayOutput
	ToXListenerSetSpecListenersTlsCertificateRefsArrayOutputWithContext(context.Context) XListenerSetSpecListenersTlsCertificateRefsArrayOutput
}

type XListenerSetSpecListenersTlsCertificateRefsArray []XListenerSetSpecListenersTlsCertificateRefsInput

func (XListenerSetSpecListenersTlsCertificateRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (i XListenerSetSpecListenersTlsCertificateRefsArray) ToXListenerSetSpecListenersTlsCertificateRefsArrayOutput() XListenerSetSpecListenersTlsCertificateRefsArrayOutput {
	return i.ToXListenerSetSpecListenersTlsCertificateRefsArrayOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsCertificateRefsArray) ToXListenerSetSpecListenersTlsCertificateRefsArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsCertificateRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsCertificateRefsArrayOutput)
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type XListenerSetSpecListenersTlsCertificateRefsOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsCertificateRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsCertificateRefsOutput) ToXListenerSetSpecListenersTlsCertificateRefsOutput() XListenerSetSpecListenersTlsCertificateRefsOutput {
	return o
}

func (o XListenerSetSpecListenersTlsCertificateRefsOutput) ToXListenerSetSpecListenersTlsCertificateRefsOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsCertificateRefsOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o XListenerSetSpecListenersTlsCertificateRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsCertificateRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "Secret".
func (o XListenerSetSpecListenersTlsCertificateRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsCertificateRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o XListenerSetSpecListenersTlsCertificateRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsCertificateRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referenced object. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o XListenerSetSpecListenersTlsCertificateRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsCertificateRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type XListenerSetSpecListenersTlsCertificateRefsArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsCertificateRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersTlsCertificateRefs)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsCertificateRefsArrayOutput) ToXListenerSetSpecListenersTlsCertificateRefsArrayOutput() XListenerSetSpecListenersTlsCertificateRefsArrayOutput {
	return o
}

func (o XListenerSetSpecListenersTlsCertificateRefsArrayOutput) ToXListenerSetSpecListenersTlsCertificateRefsArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsCertificateRefsArrayOutput {
	return o
}

func (o XListenerSetSpecListenersTlsCertificateRefsArrayOutput) Index(i pulumi.IntInput) XListenerSetSpecListenersTlsCertificateRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetSpecListenersTlsCertificateRefs {
		return vs[0].([]XListenerSetSpecListenersTlsCertificateRefs)[vs[1].(int)]
	}).(XListenerSetSpecListenersTlsCertificateRefsOutput)
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type XListenerSetSpecListenersTlsCertificateRefsPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "Secret".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
}

// XListenerSetSpecListenersTlsCertificateRefsPatchInput is an input type that accepts XListenerSetSpecListenersTlsCertificateRefsPatchArgs and XListenerSetSpecListenersTlsCertificateRefsPatchOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsCertificateRefsPatchInput` via:
//
//	XListenerSetSpecListenersTlsCertificateRefsPatchArgs{...}
type XListenerSetSpecListenersTlsCertificateRefsPatchInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsCertificateRefsPatchOutput() XListenerSetSpecListenersTlsCertificateRefsPatchOutput
	ToXListenerSetSpecListenersTlsCertificateRefsPatchOutputWithContext(context.Context) XListenerSetSpecListenersTlsCertificateRefsPatchOutput
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type XListenerSetSpecListenersTlsCertificateRefsPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "Secret".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (XListenerSetSpecListenersTlsCertificateRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTlsCertificateRefsPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersTlsCertificateRefsPatchArgs) ToXListenerSetSpecListenersTlsCertificateRefsPatchOutput() XListenerSetSpecListenersTlsCertificateRefsPatchOutput {
	return i.ToXListenerSetSpecListenersTlsCertificateRefsPatchOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsCertificateRefsPatchArgs) ToXListenerSetSpecListenersTlsCertificateRefsPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsCertificateRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsCertificateRefsPatchOutput)
}

// XListenerSetSpecListenersTlsCertificateRefsPatchArrayInput is an input type that accepts XListenerSetSpecListenersTlsCertificateRefsPatchArray and XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsCertificateRefsPatchArrayInput` via:
//
//	XListenerSetSpecListenersTlsCertificateRefsPatchArray{ XListenerSetSpecListenersTlsCertificateRefsPatchArgs{...} }
type XListenerSetSpecListenersTlsCertificateRefsPatchArrayInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput() XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput
	ToXListenerSetSpecListenersTlsCertificateRefsPatchArrayOutputWithContext(context.Context) XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput
}

type XListenerSetSpecListenersTlsCertificateRefsPatchArray []XListenerSetSpecListenersTlsCertificateRefsPatchInput

func (XListenerSetSpecListenersTlsCertificateRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersTlsCertificateRefsPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersTlsCertificateRefsPatchArray) ToXListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput() XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput {
	return i.ToXListenerSetSpecListenersTlsCertificateRefsPatchArrayOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsCertificateRefsPatchArray) ToXListenerSetSpecListenersTlsCertificateRefsPatchArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput)
}

// SecretObjectReference identifies an API object including its namespace,
// defaulting to Secret.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type XListenerSetSpecListenersTlsCertificateRefsPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsCertificateRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTlsCertificateRefsPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsCertificateRefsPatchOutput) ToXListenerSetSpecListenersTlsCertificateRefsPatchOutput() XListenerSetSpecListenersTlsCertificateRefsPatchOutput {
	return o
}

func (o XListenerSetSpecListenersTlsCertificateRefsPatchOutput) ToXListenerSetSpecListenersTlsCertificateRefsPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsCertificateRefsPatchOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o XListenerSetSpecListenersTlsCertificateRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsCertificateRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "Secret".
func (o XListenerSetSpecListenersTlsCertificateRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsCertificateRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o XListenerSetSpecListenersTlsCertificateRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsCertificateRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referenced object. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o XListenerSetSpecListenersTlsCertificateRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsCertificateRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersTlsCertificateRefsPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput) ToXListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput() XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput {
	return o
}

func (o XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput) ToXListenerSetSpecListenersTlsCertificateRefsPatchArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput {
	return o
}

func (o XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput) Index(i pulumi.IntInput) XListenerSetSpecListenersTlsCertificateRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetSpecListenersTlsCertificateRefsPatch {
		return vs[0].([]XListenerSetSpecListenersTlsCertificateRefsPatch)[vs[1].(int)]
	}).(XListenerSetSpecListenersTlsCertificateRefsPatchOutput)
}

// FrontendValidation holds configuration information for validating the frontend (client).
// Setting this field will require clients to send a client certificate
// required for validation during the TLS handshake. In browsers this may result in a dialog appearing
// that requests a user to specify the client certificate.
// The maximum depth of a certificate chain accepted in verification is Implementation specific.
//
// Support: Extended
type XListenerSetSpecListenersTlsFrontendValidation struct {
	// CACertificateRefs contains one or more references to
	// Kubernetes objects that contain TLS certificates of
	// the Certificate Authorities that can be used
	// as a trust anchor to validate the certificates presented by the client.
	//
	// A single CA certificate reference to a Kubernetes ConfigMap
	// has "Core" support.
	// Implementations MAY choose to support attaching multiple CA certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// Support: Core - A single reference to a Kubernetes ConfigMap
	// with the CA certificate in a key named `ca.crt`.
	//
	// Support: Implementation-specific (More than one reference, or other kinds
	// of resources).
	//
	// References to a resource in a different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	CaCertificateRefs []XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs `pulumi:"caCertificateRefs"`
}

// XListenerSetSpecListenersTlsFrontendValidationInput is an input type that accepts XListenerSetSpecListenersTlsFrontendValidationArgs and XListenerSetSpecListenersTlsFrontendValidationOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsFrontendValidationInput` via:
//
//	XListenerSetSpecListenersTlsFrontendValidationArgs{...}
type XListenerSetSpecListenersTlsFrontendValidationInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsFrontendValidationOutput() XListenerSetSpecListenersTlsFrontendValidationOutput
	ToXListenerSetSpecListenersTlsFrontendValidationOutputWithContext(context.Context) XListenerSetSpecListenersTlsFrontendValidationOutput
}

// FrontendValidation holds configuration information for validating the frontend (client).
// Setting this field will require clients to send a client certificate
// required for validation during the TLS handshake. In browsers this may result in a dialog appearing
// that requests a user to specify the client certificate.
// The maximum depth of a certificate chain accepted in verification is Implementation specific.
//
// Support: Extended
type XListenerSetSpecListenersTlsFrontendValidationArgs struct {
	// CACertificateRefs contains one or more references to
	// Kubernetes objects that contain TLS certificates of
	// the Certificate Authorities that can be used
	// as a trust anchor to validate the certificates presented by the client.
	//
	// A single CA certificate reference to a Kubernetes ConfigMap
	// has "Core" support.
	// Implementations MAY choose to support attaching multiple CA certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// Support: Core - A single reference to a Kubernetes ConfigMap
	// with the CA certificate in a key named `ca.crt`.
	//
	// Support: Implementation-specific (More than one reference, or other kinds
	// of resources).
	//
	// References to a resource in a different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	CaCertificateRefs XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayInput `pulumi:"caCertificateRefs"`
}

func (XListenerSetSpecListenersTlsFrontendValidationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidation)(nil)).Elem()
}

func (i XListenerSetSpecListenersTlsFrontendValidationArgs) ToXListenerSetSpecListenersTlsFrontendValidationOutput() XListenerSetSpecListenersTlsFrontendValidationOutput {
	return i.ToXListenerSetSpecListenersTlsFrontendValidationOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsFrontendValidationArgs) ToXListenerSetSpecListenersTlsFrontendValidationOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsFrontendValidationOutput)
}

func (i XListenerSetSpecListenersTlsFrontendValidationArgs) ToXListenerSetSpecListenersTlsFrontendValidationPtrOutput() XListenerSetSpecListenersTlsFrontendValidationPtrOutput {
	return i.ToXListenerSetSpecListenersTlsFrontendValidationPtrOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsFrontendValidationArgs) ToXListenerSetSpecListenersTlsFrontendValidationPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsFrontendValidationOutput).ToXListenerSetSpecListenersTlsFrontendValidationPtrOutputWithContext(ctx)
}

// XListenerSetSpecListenersTlsFrontendValidationPtrInput is an input type that accepts XListenerSetSpecListenersTlsFrontendValidationArgs, XListenerSetSpecListenersTlsFrontendValidationPtr and XListenerSetSpecListenersTlsFrontendValidationPtrOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsFrontendValidationPtrInput` via:
//
//	        XListenerSetSpecListenersTlsFrontendValidationArgs{...}
//
//	or:
//
//	        nil
type XListenerSetSpecListenersTlsFrontendValidationPtrInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsFrontendValidationPtrOutput() XListenerSetSpecListenersTlsFrontendValidationPtrOutput
	ToXListenerSetSpecListenersTlsFrontendValidationPtrOutputWithContext(context.Context) XListenerSetSpecListenersTlsFrontendValidationPtrOutput
}

type xlistenerSetSpecListenersTlsFrontendValidationPtrType XListenerSetSpecListenersTlsFrontendValidationArgs

func XListenerSetSpecListenersTlsFrontendValidationPtr(v *XListenerSetSpecListenersTlsFrontendValidationArgs) XListenerSetSpecListenersTlsFrontendValidationPtrInput {
	return (*xlistenerSetSpecListenersTlsFrontendValidationPtrType)(v)
}

func (*xlistenerSetSpecListenersTlsFrontendValidationPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersTlsFrontendValidation)(nil)).Elem()
}

func (i *xlistenerSetSpecListenersTlsFrontendValidationPtrType) ToXListenerSetSpecListenersTlsFrontendValidationPtrOutput() XListenerSetSpecListenersTlsFrontendValidationPtrOutput {
	return i.ToXListenerSetSpecListenersTlsFrontendValidationPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetSpecListenersTlsFrontendValidationPtrType) ToXListenerSetSpecListenersTlsFrontendValidationPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsFrontendValidationPtrOutput)
}

// FrontendValidation holds configuration information for validating the frontend (client).
// Setting this field will require clients to send a client certificate
// required for validation during the TLS handshake. In browsers this may result in a dialog appearing
// that requests a user to specify the client certificate.
// The maximum depth of a certificate chain accepted in verification is Implementation specific.
//
// Support: Extended
type XListenerSetSpecListenersTlsFrontendValidationOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsFrontendValidationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidation)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsFrontendValidationOutput) ToXListenerSetSpecListenersTlsFrontendValidationOutput() XListenerSetSpecListenersTlsFrontendValidationOutput {
	return o
}

func (o XListenerSetSpecListenersTlsFrontendValidationOutput) ToXListenerSetSpecListenersTlsFrontendValidationOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationOutput {
	return o
}

func (o XListenerSetSpecListenersTlsFrontendValidationOutput) ToXListenerSetSpecListenersTlsFrontendValidationPtrOutput() XListenerSetSpecListenersTlsFrontendValidationPtrOutput {
	return o.ToXListenerSetSpecListenersTlsFrontendValidationPtrOutputWithContext(context.Background())
}

func (o XListenerSetSpecListenersTlsFrontendValidationOutput) ToXListenerSetSpecListenersTlsFrontendValidationPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetSpecListenersTlsFrontendValidation) *XListenerSetSpecListenersTlsFrontendValidation {
		return &v
	}).(XListenerSetSpecListenersTlsFrontendValidationPtrOutput)
}

// CACertificateRefs contains one or more references to
// Kubernetes objects that contain TLS certificates of
// the Certificate Authorities that can be used
// as a trust anchor to validate the certificates presented by the client.
//
// A single CA certificate reference to a Kubernetes ConfigMap
// has "Core" support.
// Implementations MAY choose to support attaching multiple CA certificates to
// a Listener, but this behavior is implementation-specific.
//
// Support: Core - A single reference to a Kubernetes ConfigMap
// with the CA certificate in a key named `ca.crt`.
//
// Support: Implementation-specific (More than one reference, or other kinds
// of resources).
//
// References to a resource in a different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
func (o XListenerSetSpecListenersTlsFrontendValidationOutput) CaCertificateRefs() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsFrontendValidation) []XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs {
		return v.CaCertificateRefs
	}).(XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput)
}

type XListenerSetSpecListenersTlsFrontendValidationPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsFrontendValidationPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersTlsFrontendValidation)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsFrontendValidationPtrOutput) ToXListenerSetSpecListenersTlsFrontendValidationPtrOutput() XListenerSetSpecListenersTlsFrontendValidationPtrOutput {
	return o
}

func (o XListenerSetSpecListenersTlsFrontendValidationPtrOutput) ToXListenerSetSpecListenersTlsFrontendValidationPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationPtrOutput {
	return o
}

func (o XListenerSetSpecListenersTlsFrontendValidationPtrOutput) Elem() XListenerSetSpecListenersTlsFrontendValidationOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersTlsFrontendValidation) XListenerSetSpecListenersTlsFrontendValidation {
		if v != nil {
			return *v
		}
		var ret XListenerSetSpecListenersTlsFrontendValidation
		return ret
	}).(XListenerSetSpecListenersTlsFrontendValidationOutput)
}

// CACertificateRefs contains one or more references to
// Kubernetes objects that contain TLS certificates of
// the Certificate Authorities that can be used
// as a trust anchor to validate the certificates presented by the client.
//
// A single CA certificate reference to a Kubernetes ConfigMap
// has "Core" support.
// Implementations MAY choose to support attaching multiple CA certificates to
// a Listener, but this behavior is implementation-specific.
//
// Support: Core - A single reference to a Kubernetes ConfigMap
// with the CA certificate in a key named `ca.crt`.
//
// Support: Implementation-specific (More than one reference, or other kinds
// of resources).
//
// References to a resource in a different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
func (o XListenerSetSpecListenersTlsFrontendValidationPtrOutput) CaCertificateRefs() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersTlsFrontendValidation) []XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs {
		if v == nil {
			return nil
		}
		return v.CaCertificateRefs
	}).(XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput)
}

// ObjectReference identifies an API object including its namespace.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When set to the empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "ConfigMap" or "Service".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
}

// XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsInput is an input type that accepts XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArgs and XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsInput` via:
//
//	XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArgs{...}
type XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput
	ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutputWithContext(context.Context) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput
}

// ObjectReference identifies an API object including its namespace.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When set to the empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "ConfigMap" or "Service".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs)(nil)).Elem()
}

func (i XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArgs) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput {
	return i.ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArgs) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput)
}

// XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayInput is an input type that accepts XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArray and XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayInput` via:
//
//	XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArray{ XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArgs{...} }
type XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput
	ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutputWithContext(context.Context) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput
}

type XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArray []XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsInput

func (XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs)(nil)).Elem()
}

func (i XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArray) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput {
	return i.ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArray) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput)
}

// ObjectReference identifies an API object including its namespace.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput {
	return o
}

func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When set to the empty string, core API group is inferred.
func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "ConfigMap" or "Service".
func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referenced object. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput {
	return o
}

func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput {
	return o
}

func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput) Index(i pulumi.IntInput) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs {
		return vs[0].([]XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefs)[vs[1].(int)]
	}).(XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput)
}

// ObjectReference identifies an API object including its namespace.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When set to the empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "ConfigMap" or "Service".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
}

// XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchInput is an input type that accepts XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArgs and XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchInput` via:
//
//	XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArgs{...}
type XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput
	ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutputWithContext(context.Context) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput
}

// ObjectReference identifies an API object including its namespace.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When set to the empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "ConfigMap" or "Service".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referenced object. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArgs) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput {
	return i.ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArgs) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput)
}

// XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayInput is an input type that accepts XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArray and XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayInput` via:
//
//	XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArray{ XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArgs{...} }
type XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput
	ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutputWithContext(context.Context) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput
}

type XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArray []XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchInput

func (XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArray) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput {
	return i.ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArray) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput)
}

// ObjectReference identifies an API object including its namespace.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
//
// References to objects with invalid Group and Kind are not valid, and must
// be rejected by the implementation, with appropriate Conditions set
// on the containing object.
type XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput {
	return o
}

func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When set to the empty string, core API group is inferred.
func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "ConfigMap" or "Service".
func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referenced object. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatch) *string {
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

type XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput {
	return o
}

func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput) ToXListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput {
	return o
}

func (o XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput) Index(i pulumi.IntInput) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatch {
		return vs[0].([]XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatch)[vs[1].(int)]
	}).(XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput)
}

// FrontendValidation holds configuration information for validating the frontend (client).
// Setting this field will require clients to send a client certificate
// required for validation during the TLS handshake. In browsers this may result in a dialog appearing
// that requests a user to specify the client certificate.
// The maximum depth of a certificate chain accepted in verification is Implementation specific.
//
// Support: Extended
type XListenerSetSpecListenersTlsFrontendValidationPatch struct {
	// CACertificateRefs contains one or more references to
	// Kubernetes objects that contain TLS certificates of
	// the Certificate Authorities that can be used
	// as a trust anchor to validate the certificates presented by the client.
	//
	// A single CA certificate reference to a Kubernetes ConfigMap
	// has "Core" support.
	// Implementations MAY choose to support attaching multiple CA certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// Support: Core - A single reference to a Kubernetes ConfigMap
	// with the CA certificate in a key named `ca.crt`.
	//
	// Support: Implementation-specific (More than one reference, or other kinds
	// of resources).
	//
	// References to a resource in a different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	CaCertificateRefs []XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatch `pulumi:"caCertificateRefs"`
}

// XListenerSetSpecListenersTlsFrontendValidationPatchInput is an input type that accepts XListenerSetSpecListenersTlsFrontendValidationPatchArgs and XListenerSetSpecListenersTlsFrontendValidationPatchOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsFrontendValidationPatchInput` via:
//
//	XListenerSetSpecListenersTlsFrontendValidationPatchArgs{...}
type XListenerSetSpecListenersTlsFrontendValidationPatchInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsFrontendValidationPatchOutput() XListenerSetSpecListenersTlsFrontendValidationPatchOutput
	ToXListenerSetSpecListenersTlsFrontendValidationPatchOutputWithContext(context.Context) XListenerSetSpecListenersTlsFrontendValidationPatchOutput
}

// FrontendValidation holds configuration information for validating the frontend (client).
// Setting this field will require clients to send a client certificate
// required for validation during the TLS handshake. In browsers this may result in a dialog appearing
// that requests a user to specify the client certificate.
// The maximum depth of a certificate chain accepted in verification is Implementation specific.
//
// Support: Extended
type XListenerSetSpecListenersTlsFrontendValidationPatchArgs struct {
	// CACertificateRefs contains one or more references to
	// Kubernetes objects that contain TLS certificates of
	// the Certificate Authorities that can be used
	// as a trust anchor to validate the certificates presented by the client.
	//
	// A single CA certificate reference to a Kubernetes ConfigMap
	// has "Core" support.
	// Implementations MAY choose to support attaching multiple CA certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// Support: Core - A single reference to a Kubernetes ConfigMap
	// with the CA certificate in a key named `ca.crt`.
	//
	// Support: Implementation-specific (More than one reference, or other kinds
	// of resources).
	//
	// References to a resource in a different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	CaCertificateRefs XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayInput `pulumi:"caCertificateRefs"`
}

func (XListenerSetSpecListenersTlsFrontendValidationPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidationPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersTlsFrontendValidationPatchArgs) ToXListenerSetSpecListenersTlsFrontendValidationPatchOutput() XListenerSetSpecListenersTlsFrontendValidationPatchOutput {
	return i.ToXListenerSetSpecListenersTlsFrontendValidationPatchOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsFrontendValidationPatchArgs) ToXListenerSetSpecListenersTlsFrontendValidationPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsFrontendValidationPatchOutput)
}

func (i XListenerSetSpecListenersTlsFrontendValidationPatchArgs) ToXListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput() XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput {
	return i.ToXListenerSetSpecListenersTlsFrontendValidationPatchPtrOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsFrontendValidationPatchArgs) ToXListenerSetSpecListenersTlsFrontendValidationPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsFrontendValidationPatchOutput).ToXListenerSetSpecListenersTlsFrontendValidationPatchPtrOutputWithContext(ctx)
}

// XListenerSetSpecListenersTlsFrontendValidationPatchPtrInput is an input type that accepts XListenerSetSpecListenersTlsFrontendValidationPatchArgs, XListenerSetSpecListenersTlsFrontendValidationPatchPtr and XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsFrontendValidationPatchPtrInput` via:
//
//	        XListenerSetSpecListenersTlsFrontendValidationPatchArgs{...}
//
//	or:
//
//	        nil
type XListenerSetSpecListenersTlsFrontendValidationPatchPtrInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput() XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput
	ToXListenerSetSpecListenersTlsFrontendValidationPatchPtrOutputWithContext(context.Context) XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput
}

type xlistenerSetSpecListenersTlsFrontendValidationPatchPtrType XListenerSetSpecListenersTlsFrontendValidationPatchArgs

func XListenerSetSpecListenersTlsFrontendValidationPatchPtr(v *XListenerSetSpecListenersTlsFrontendValidationPatchArgs) XListenerSetSpecListenersTlsFrontendValidationPatchPtrInput {
	return (*xlistenerSetSpecListenersTlsFrontendValidationPatchPtrType)(v)
}

func (*xlistenerSetSpecListenersTlsFrontendValidationPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersTlsFrontendValidationPatch)(nil)).Elem()
}

func (i *xlistenerSetSpecListenersTlsFrontendValidationPatchPtrType) ToXListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput() XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput {
	return i.ToXListenerSetSpecListenersTlsFrontendValidationPatchPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetSpecListenersTlsFrontendValidationPatchPtrType) ToXListenerSetSpecListenersTlsFrontendValidationPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput)
}

// FrontendValidation holds configuration information for validating the frontend (client).
// Setting this field will require clients to send a client certificate
// required for validation during the TLS handshake. In browsers this may result in a dialog appearing
// that requests a user to specify the client certificate.
// The maximum depth of a certificate chain accepted in verification is Implementation specific.
//
// Support: Extended
type XListenerSetSpecListenersTlsFrontendValidationPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsFrontendValidationPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidationPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsFrontendValidationPatchOutput) ToXListenerSetSpecListenersTlsFrontendValidationPatchOutput() XListenerSetSpecListenersTlsFrontendValidationPatchOutput {
	return o
}

func (o XListenerSetSpecListenersTlsFrontendValidationPatchOutput) ToXListenerSetSpecListenersTlsFrontendValidationPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationPatchOutput {
	return o
}

func (o XListenerSetSpecListenersTlsFrontendValidationPatchOutput) ToXListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput() XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput {
	return o.ToXListenerSetSpecListenersTlsFrontendValidationPatchPtrOutputWithContext(context.Background())
}

func (o XListenerSetSpecListenersTlsFrontendValidationPatchOutput) ToXListenerSetSpecListenersTlsFrontendValidationPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetSpecListenersTlsFrontendValidationPatch) *XListenerSetSpecListenersTlsFrontendValidationPatch {
		return &v
	}).(XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput)
}

// CACertificateRefs contains one or more references to
// Kubernetes objects that contain TLS certificates of
// the Certificate Authorities that can be used
// as a trust anchor to validate the certificates presented by the client.
//
// A single CA certificate reference to a Kubernetes ConfigMap
// has "Core" support.
// Implementations MAY choose to support attaching multiple CA certificates to
// a Listener, but this behavior is implementation-specific.
//
// Support: Core - A single reference to a Kubernetes ConfigMap
// with the CA certificate in a key named `ca.crt`.
//
// Support: Implementation-specific (More than one reference, or other kinds
// of resources).
//
// References to a resource in a different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
func (o XListenerSetSpecListenersTlsFrontendValidationPatchOutput) CaCertificateRefs() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsFrontendValidationPatch) []XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatch {
		return v.CaCertificateRefs
	}).(XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput)
}

type XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersTlsFrontendValidationPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput) ToXListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput() XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput {
	return o
}

func (o XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput) ToXListenerSetSpecListenersTlsFrontendValidationPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput {
	return o
}

func (o XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput) Elem() XListenerSetSpecListenersTlsFrontendValidationPatchOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersTlsFrontendValidationPatch) XListenerSetSpecListenersTlsFrontendValidationPatch {
		if v != nil {
			return *v
		}
		var ret XListenerSetSpecListenersTlsFrontendValidationPatch
		return ret
	}).(XListenerSetSpecListenersTlsFrontendValidationPatchOutput)
}

// CACertificateRefs contains one or more references to
// Kubernetes objects that contain TLS certificates of
// the Certificate Authorities that can be used
// as a trust anchor to validate the certificates presented by the client.
//
// A single CA certificate reference to a Kubernetes ConfigMap
// has "Core" support.
// Implementations MAY choose to support attaching multiple CA certificates to
// a Listener, but this behavior is implementation-specific.
//
// Support: Core - A single reference to a Kubernetes ConfigMap
// with the CA certificate in a key named `ca.crt`.
//
// Support: Implementation-specific (More than one reference, or other kinds
// of resources).
//
// References to a resource in a different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
func (o XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput) CaCertificateRefs() XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersTlsFrontendValidationPatch) []XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatch {
		if v == nil {
			return nil
		}
		return v.CaCertificateRefs
	}).(XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput)
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
type XListenerSetSpecListenersTlsPatch struct {
	// CertificateRefs contains a series of references to Kubernetes objects that
	// contains TLS certificates and private keys. These certificates are used to
	// establish a TLS handshake for requests that match the hostname of the
	// associated listener.
	//
	// A single CertificateRef to a Kubernetes Secret has "Core" support.
	// Implementations MAY choose to support attaching multiple certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// References to a resource in different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	//
	// This field is required to have at least one element when the mode is set
	// to "Terminate" (default) and is optional otherwise.
	//
	// CertificateRefs can reference to standard Kubernetes resources, i.e.
	// Secret, or implementation-specific custom resources.
	//
	// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
	//
	// Support: Implementation-specific (More than one reference or other resource types)
	CertificateRefs    []XListenerSetSpecListenersTlsCertificateRefsPatch   `pulumi:"certificateRefs"`
	FrontendValidation *XListenerSetSpecListenersTlsFrontendValidationPatch `pulumi:"frontendValidation"`
	// Mode defines the TLS behavior for the TLS session initiated by the client.
	// There are two possible modes:
	//
	// - Terminate: The TLS session between the downstream client and the
	//   Gateway is terminated at the Gateway. This mode requires certificates
	//   to be specified in some way, such as populating the certificateRefs
	//   field.
	// - Passthrough: The TLS session is NOT terminated by the Gateway. This
	//   implies that the Gateway can't decipher the TLS stream except for
	//   the ClientHello message of the TLS protocol. The certificateRefs field
	//   is ignored in this mode.
	//
	// Support: Core
	Mode *string `pulumi:"mode"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options map[string]string `pulumi:"options"`
}

// XListenerSetSpecListenersTlsPatchInput is an input type that accepts XListenerSetSpecListenersTlsPatchArgs and XListenerSetSpecListenersTlsPatchOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsPatchInput` via:
//
//	XListenerSetSpecListenersTlsPatchArgs{...}
type XListenerSetSpecListenersTlsPatchInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsPatchOutput() XListenerSetSpecListenersTlsPatchOutput
	ToXListenerSetSpecListenersTlsPatchOutputWithContext(context.Context) XListenerSetSpecListenersTlsPatchOutput
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
type XListenerSetSpecListenersTlsPatchArgs struct {
	// CertificateRefs contains a series of references to Kubernetes objects that
	// contains TLS certificates and private keys. These certificates are used to
	// establish a TLS handshake for requests that match the hostname of the
	// associated listener.
	//
	// A single CertificateRef to a Kubernetes Secret has "Core" support.
	// Implementations MAY choose to support attaching multiple certificates to
	// a Listener, but this behavior is implementation-specific.
	//
	// References to a resource in different namespace are invalid UNLESS there
	// is a ReferenceGrant in the target namespace that allows the certificate
	// to be attached. If a ReferenceGrant does not allow this reference, the
	// "ResolvedRefs" condition MUST be set to False for this listener with the
	// "RefNotPermitted" reason.
	//
	// This field is required to have at least one element when the mode is set
	// to "Terminate" (default) and is optional otherwise.
	//
	// CertificateRefs can reference to standard Kubernetes resources, i.e.
	// Secret, or implementation-specific custom resources.
	//
	// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
	//
	// Support: Implementation-specific (More than one reference or other resource types)
	CertificateRefs    XListenerSetSpecListenersTlsCertificateRefsPatchArrayInput  `pulumi:"certificateRefs"`
	FrontendValidation XListenerSetSpecListenersTlsFrontendValidationPatchPtrInput `pulumi:"frontendValidation"`
	// Mode defines the TLS behavior for the TLS session initiated by the client.
	// There are two possible modes:
	//
	// - Terminate: The TLS session between the downstream client and the
	//   Gateway is terminated at the Gateway. This mode requires certificates
	//   to be specified in some way, such as populating the certificateRefs
	//   field.
	// - Passthrough: The TLS session is NOT terminated by the Gateway. This
	//   implies that the Gateway can't decipher the TLS stream except for
	//   the ClientHello message of the TLS protocol. The certificateRefs field
	//   is ignored in this mode.
	//
	// Support: Core
	Mode pulumi.StringPtrInput `pulumi:"mode"`
	// Options are a list of key/value pairs to enable extended TLS
	// configuration for each implementation. For example, configuring the
	// minimum TLS version or supported cipher suites.
	//
	// A set of common keys MAY be defined by the API in the future. To avoid
	// any ambiguity, implementation-specific definitions MUST use
	// domain-prefixed names, such as `example.com/my-custom-option`.
	// Un-prefixed names are reserved for key names defined by Gateway API.
	//
	// Support: Implementation-specific
	Options pulumi.StringMapInput `pulumi:"options"`
}

func (XListenerSetSpecListenersTlsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTlsPatch)(nil)).Elem()
}

func (i XListenerSetSpecListenersTlsPatchArgs) ToXListenerSetSpecListenersTlsPatchOutput() XListenerSetSpecListenersTlsPatchOutput {
	return i.ToXListenerSetSpecListenersTlsPatchOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsPatchArgs) ToXListenerSetSpecListenersTlsPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsPatchOutput)
}

func (i XListenerSetSpecListenersTlsPatchArgs) ToXListenerSetSpecListenersTlsPatchPtrOutput() XListenerSetSpecListenersTlsPatchPtrOutput {
	return i.ToXListenerSetSpecListenersTlsPatchPtrOutputWithContext(context.Background())
}

func (i XListenerSetSpecListenersTlsPatchArgs) ToXListenerSetSpecListenersTlsPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsPatchOutput).ToXListenerSetSpecListenersTlsPatchPtrOutputWithContext(ctx)
}

// XListenerSetSpecListenersTlsPatchPtrInput is an input type that accepts XListenerSetSpecListenersTlsPatchArgs, XListenerSetSpecListenersTlsPatchPtr and XListenerSetSpecListenersTlsPatchPtrOutput values.
// You can construct a concrete instance of `XListenerSetSpecListenersTlsPatchPtrInput` via:
//
//	        XListenerSetSpecListenersTlsPatchArgs{...}
//
//	or:
//
//	        nil
type XListenerSetSpecListenersTlsPatchPtrInput interface {
	pulumi.Input

	ToXListenerSetSpecListenersTlsPatchPtrOutput() XListenerSetSpecListenersTlsPatchPtrOutput
	ToXListenerSetSpecListenersTlsPatchPtrOutputWithContext(context.Context) XListenerSetSpecListenersTlsPatchPtrOutput
}

type xlistenerSetSpecListenersTlsPatchPtrType XListenerSetSpecListenersTlsPatchArgs

func XListenerSetSpecListenersTlsPatchPtr(v *XListenerSetSpecListenersTlsPatchArgs) XListenerSetSpecListenersTlsPatchPtrInput {
	return (*xlistenerSetSpecListenersTlsPatchPtrType)(v)
}

func (*xlistenerSetSpecListenersTlsPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersTlsPatch)(nil)).Elem()
}

func (i *xlistenerSetSpecListenersTlsPatchPtrType) ToXListenerSetSpecListenersTlsPatchPtrOutput() XListenerSetSpecListenersTlsPatchPtrOutput {
	return i.ToXListenerSetSpecListenersTlsPatchPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetSpecListenersTlsPatchPtrType) ToXListenerSetSpecListenersTlsPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecListenersTlsPatchPtrOutput)
}

// TLS is the TLS configuration for the Listener. This field is required if
// the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
// if the Protocol field is "HTTP", "TCP", or "UDP".
//
// The association of SNIs to Certificate defined in GatewayTLSConfig is
// defined based on the Hostname field for this listener.
//
// The GatewayClass MUST use the longest matching SNI out of all
// available certificates for any TLS handshake.
type XListenerSetSpecListenersTlsPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecListenersTlsPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsPatchOutput) ToXListenerSetSpecListenersTlsPatchOutput() XListenerSetSpecListenersTlsPatchOutput {
	return o
}

func (o XListenerSetSpecListenersTlsPatchOutput) ToXListenerSetSpecListenersTlsPatchOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsPatchOutput {
	return o
}

func (o XListenerSetSpecListenersTlsPatchOutput) ToXListenerSetSpecListenersTlsPatchPtrOutput() XListenerSetSpecListenersTlsPatchPtrOutput {
	return o.ToXListenerSetSpecListenersTlsPatchPtrOutputWithContext(context.Background())
}

func (o XListenerSetSpecListenersTlsPatchOutput) ToXListenerSetSpecListenersTlsPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetSpecListenersTlsPatch) *XListenerSetSpecListenersTlsPatch {
		return &v
	}).(XListenerSetSpecListenersTlsPatchPtrOutput)
}

// CertificateRefs contains a series of references to Kubernetes objects that
// contains TLS certificates and private keys. These certificates are used to
// establish a TLS handshake for requests that match the hostname of the
// associated listener.
//
// A single CertificateRef to a Kubernetes Secret has "Core" support.
// Implementations MAY choose to support attaching multiple certificates to
// a Listener, but this behavior is implementation-specific.
//
// References to a resource in different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
//
// This field is required to have at least one element when the mode is set
// to "Terminate" (default) and is optional otherwise.
//
// CertificateRefs can reference to standard Kubernetes resources, i.e.
// Secret, or implementation-specific custom resources.
//
// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
//
// Support: Implementation-specific (More than one reference or other resource types)
func (o XListenerSetSpecListenersTlsPatchOutput) CertificateRefs() XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsPatch) []XListenerSetSpecListenersTlsCertificateRefsPatch {
		return v.CertificateRefs
	}).(XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput)
}

func (o XListenerSetSpecListenersTlsPatchOutput) FrontendValidation() XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsPatch) *XListenerSetSpecListenersTlsFrontendValidationPatch {
		return v.FrontendValidation
	}).(XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput)
}

// Mode defines the TLS behavior for the TLS session initiated by the client.
// There are two possible modes:
//
//   - Terminate: The TLS session between the downstream client and the
//     Gateway is terminated at the Gateway. This mode requires certificates
//     to be specified in some way, such as populating the certificateRefs
//     field.
//   - Passthrough: The TLS session is NOT terminated by the Gateway. This
//     implies that the Gateway can't decipher the TLS stream except for
//     the ClientHello message of the TLS protocol. The certificateRefs field
//     is ignored in this mode.
//
// Support: Core
func (o XListenerSetSpecListenersTlsPatchOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsPatch) *string { return v.Mode }).(pulumi.StringPtrOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
func (o XListenerSetSpecListenersTlsPatchOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v XListenerSetSpecListenersTlsPatch) map[string]string { return v.Options }).(pulumi.StringMapOutput)
}

type XListenerSetSpecListenersTlsPatchPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecListenersTlsPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecListenersTlsPatch)(nil)).Elem()
}

func (o XListenerSetSpecListenersTlsPatchPtrOutput) ToXListenerSetSpecListenersTlsPatchPtrOutput() XListenerSetSpecListenersTlsPatchPtrOutput {
	return o
}

func (o XListenerSetSpecListenersTlsPatchPtrOutput) ToXListenerSetSpecListenersTlsPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecListenersTlsPatchPtrOutput {
	return o
}

func (o XListenerSetSpecListenersTlsPatchPtrOutput) Elem() XListenerSetSpecListenersTlsPatchOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersTlsPatch) XListenerSetSpecListenersTlsPatch {
		if v != nil {
			return *v
		}
		var ret XListenerSetSpecListenersTlsPatch
		return ret
	}).(XListenerSetSpecListenersTlsPatchOutput)
}

// CertificateRefs contains a series of references to Kubernetes objects that
// contains TLS certificates and private keys. These certificates are used to
// establish a TLS handshake for requests that match the hostname of the
// associated listener.
//
// A single CertificateRef to a Kubernetes Secret has "Core" support.
// Implementations MAY choose to support attaching multiple certificates to
// a Listener, but this behavior is implementation-specific.
//
// References to a resource in different namespace are invalid UNLESS there
// is a ReferenceGrant in the target namespace that allows the certificate
// to be attached. If a ReferenceGrant does not allow this reference, the
// "ResolvedRefs" condition MUST be set to False for this listener with the
// "RefNotPermitted" reason.
//
// This field is required to have at least one element when the mode is set
// to "Terminate" (default) and is optional otherwise.
//
// CertificateRefs can reference to standard Kubernetes resources, i.e.
// Secret, or implementation-specific custom resources.
//
// Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
//
// Support: Implementation-specific (More than one reference or other resource types)
func (o XListenerSetSpecListenersTlsPatchPtrOutput) CertificateRefs() XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersTlsPatch) []XListenerSetSpecListenersTlsCertificateRefsPatch {
		if v == nil {
			return nil
		}
		return v.CertificateRefs
	}).(XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput)
}

func (o XListenerSetSpecListenersTlsPatchPtrOutput) FrontendValidation() XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersTlsPatch) *XListenerSetSpecListenersTlsFrontendValidationPatch {
		if v == nil {
			return nil
		}
		return v.FrontendValidation
	}).(XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput)
}

// Mode defines the TLS behavior for the TLS session initiated by the client.
// There are two possible modes:
//
//   - Terminate: The TLS session between the downstream client and the
//     Gateway is terminated at the Gateway. This mode requires certificates
//     to be specified in some way, such as populating the certificateRefs
//     field.
//   - Passthrough: The TLS session is NOT terminated by the Gateway. This
//     implies that the Gateway can't decipher the TLS stream except for
//     the ClientHello message of the TLS protocol. The certificateRefs field
//     is ignored in this mode.
//
// Support: Core
func (o XListenerSetSpecListenersTlsPatchPtrOutput) Mode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersTlsPatch) *string {
		if v == nil {
			return nil
		}
		return v.Mode
	}).(pulumi.StringPtrOutput)
}

// Options are a list of key/value pairs to enable extended TLS
// configuration for each implementation. For example, configuring the
// minimum TLS version or supported cipher suites.
//
// A set of common keys MAY be defined by the API in the future. To avoid
// any ambiguity, implementation-specific definitions MUST use
// domain-prefixed names, such as `example.com/my-custom-option`.
// Un-prefixed names are reserved for key names defined by Gateway API.
//
// Support: Implementation-specific
func (o XListenerSetSpecListenersTlsPatchPtrOutput) Options() pulumi.StringMapOutput {
	return o.ApplyT(func(v *XListenerSetSpecListenersTlsPatch) map[string]string {
		if v == nil {
			return nil
		}
		return v.Options
	}).(pulumi.StringMapOutput)
}

// ParentRef references the Gateway that the listeners are attached to.
type XListenerSetSpecParentRef struct {
	// Group is the group of the referent.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "Gateway".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent.  If not present,
	// the namespace of the referent is assumed to be the same as
	// the namespace of the referring object.
	Namespace *string `pulumi:"namespace"`
}

// XListenerSetSpecParentRefInput is an input type that accepts XListenerSetSpecParentRefArgs and XListenerSetSpecParentRefOutput values.
// You can construct a concrete instance of `XListenerSetSpecParentRefInput` via:
//
//	XListenerSetSpecParentRefArgs{...}
type XListenerSetSpecParentRefInput interface {
	pulumi.Input

	ToXListenerSetSpecParentRefOutput() XListenerSetSpecParentRefOutput
	ToXListenerSetSpecParentRefOutputWithContext(context.Context) XListenerSetSpecParentRefOutput
}

// ParentRef references the Gateway that the listeners are attached to.
type XListenerSetSpecParentRefArgs struct {
	// Group is the group of the referent.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "Gateway".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent.  If not present,
	// the namespace of the referent is assumed to be the same as
	// the namespace of the referring object.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (XListenerSetSpecParentRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecParentRef)(nil)).Elem()
}

func (i XListenerSetSpecParentRefArgs) ToXListenerSetSpecParentRefOutput() XListenerSetSpecParentRefOutput {
	return i.ToXListenerSetSpecParentRefOutputWithContext(context.Background())
}

func (i XListenerSetSpecParentRefArgs) ToXListenerSetSpecParentRefOutputWithContext(ctx context.Context) XListenerSetSpecParentRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecParentRefOutput)
}

func (i XListenerSetSpecParentRefArgs) ToXListenerSetSpecParentRefPtrOutput() XListenerSetSpecParentRefPtrOutput {
	return i.ToXListenerSetSpecParentRefPtrOutputWithContext(context.Background())
}

func (i XListenerSetSpecParentRefArgs) ToXListenerSetSpecParentRefPtrOutputWithContext(ctx context.Context) XListenerSetSpecParentRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecParentRefOutput).ToXListenerSetSpecParentRefPtrOutputWithContext(ctx)
}

// XListenerSetSpecParentRefPtrInput is an input type that accepts XListenerSetSpecParentRefArgs, XListenerSetSpecParentRefPtr and XListenerSetSpecParentRefPtrOutput values.
// You can construct a concrete instance of `XListenerSetSpecParentRefPtrInput` via:
//
//	        XListenerSetSpecParentRefArgs{...}
//
//	or:
//
//	        nil
type XListenerSetSpecParentRefPtrInput interface {
	pulumi.Input

	ToXListenerSetSpecParentRefPtrOutput() XListenerSetSpecParentRefPtrOutput
	ToXListenerSetSpecParentRefPtrOutputWithContext(context.Context) XListenerSetSpecParentRefPtrOutput
}

type xlistenerSetSpecParentRefPtrType XListenerSetSpecParentRefArgs

func XListenerSetSpecParentRefPtr(v *XListenerSetSpecParentRefArgs) XListenerSetSpecParentRefPtrInput {
	return (*xlistenerSetSpecParentRefPtrType)(v)
}

func (*xlistenerSetSpecParentRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecParentRef)(nil)).Elem()
}

func (i *xlistenerSetSpecParentRefPtrType) ToXListenerSetSpecParentRefPtrOutput() XListenerSetSpecParentRefPtrOutput {
	return i.ToXListenerSetSpecParentRefPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetSpecParentRefPtrType) ToXListenerSetSpecParentRefPtrOutputWithContext(ctx context.Context) XListenerSetSpecParentRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecParentRefPtrOutput)
}

// ParentRef references the Gateway that the listeners are attached to.
type XListenerSetSpecParentRefOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecParentRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecParentRef)(nil)).Elem()
}

func (o XListenerSetSpecParentRefOutput) ToXListenerSetSpecParentRefOutput() XListenerSetSpecParentRefOutput {
	return o
}

func (o XListenerSetSpecParentRefOutput) ToXListenerSetSpecParentRefOutputWithContext(ctx context.Context) XListenerSetSpecParentRefOutput {
	return o
}

func (o XListenerSetSpecParentRefOutput) ToXListenerSetSpecParentRefPtrOutput() XListenerSetSpecParentRefPtrOutput {
	return o.ToXListenerSetSpecParentRefPtrOutputWithContext(context.Background())
}

func (o XListenerSetSpecParentRefOutput) ToXListenerSetSpecParentRefPtrOutputWithContext(ctx context.Context) XListenerSetSpecParentRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetSpecParentRef) *XListenerSetSpecParentRef {
		return &v
	}).(XListenerSetSpecParentRefPtrOutput)
}

// Group is the group of the referent.
func (o XListenerSetSpecParentRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecParentRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "Gateway".
func (o XListenerSetSpecParentRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecParentRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o XListenerSetSpecParentRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecParentRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.  If not present,
// the namespace of the referent is assumed to be the same as
// the namespace of the referring object.
func (o XListenerSetSpecParentRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecParentRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type XListenerSetSpecParentRefPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecParentRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecParentRef)(nil)).Elem()
}

func (o XListenerSetSpecParentRefPtrOutput) ToXListenerSetSpecParentRefPtrOutput() XListenerSetSpecParentRefPtrOutput {
	return o
}

func (o XListenerSetSpecParentRefPtrOutput) ToXListenerSetSpecParentRefPtrOutputWithContext(ctx context.Context) XListenerSetSpecParentRefPtrOutput {
	return o
}

func (o XListenerSetSpecParentRefPtrOutput) Elem() XListenerSetSpecParentRefOutput {
	return o.ApplyT(func(v *XListenerSetSpecParentRef) XListenerSetSpecParentRef {
		if v != nil {
			return *v
		}
		var ret XListenerSetSpecParentRef
		return ret
	}).(XListenerSetSpecParentRefOutput)
}

// Group is the group of the referent.
func (o XListenerSetSpecParentRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "Gateway".
func (o XListenerSetSpecParentRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o XListenerSetSpecParentRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.  If not present,
// the namespace of the referent is assumed to be the same as
// the namespace of the referring object.
func (o XListenerSetSpecParentRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// ParentRef references the Gateway that the listeners are attached to.
type XListenerSetSpecParentRefPatch struct {
	// Group is the group of the referent.
	Group *string `pulumi:"group"`
	// Kind is kind of the referent. For example "Gateway".
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent.  If not present,
	// the namespace of the referent is assumed to be the same as
	// the namespace of the referring object.
	Namespace *string `pulumi:"namespace"`
}

// XListenerSetSpecParentRefPatchInput is an input type that accepts XListenerSetSpecParentRefPatchArgs and XListenerSetSpecParentRefPatchOutput values.
// You can construct a concrete instance of `XListenerSetSpecParentRefPatchInput` via:
//
//	XListenerSetSpecParentRefPatchArgs{...}
type XListenerSetSpecParentRefPatchInput interface {
	pulumi.Input

	ToXListenerSetSpecParentRefPatchOutput() XListenerSetSpecParentRefPatchOutput
	ToXListenerSetSpecParentRefPatchOutputWithContext(context.Context) XListenerSetSpecParentRefPatchOutput
}

// ParentRef references the Gateway that the listeners are attached to.
type XListenerSetSpecParentRefPatchArgs struct {
	// Group is the group of the referent.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent. For example "Gateway".
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent.  If not present,
	// the namespace of the referent is assumed to be the same as
	// the namespace of the referring object.
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
}

func (XListenerSetSpecParentRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecParentRefPatch)(nil)).Elem()
}

func (i XListenerSetSpecParentRefPatchArgs) ToXListenerSetSpecParentRefPatchOutput() XListenerSetSpecParentRefPatchOutput {
	return i.ToXListenerSetSpecParentRefPatchOutputWithContext(context.Background())
}

func (i XListenerSetSpecParentRefPatchArgs) ToXListenerSetSpecParentRefPatchOutputWithContext(ctx context.Context) XListenerSetSpecParentRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecParentRefPatchOutput)
}

func (i XListenerSetSpecParentRefPatchArgs) ToXListenerSetSpecParentRefPatchPtrOutput() XListenerSetSpecParentRefPatchPtrOutput {
	return i.ToXListenerSetSpecParentRefPatchPtrOutputWithContext(context.Background())
}

func (i XListenerSetSpecParentRefPatchArgs) ToXListenerSetSpecParentRefPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecParentRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecParentRefPatchOutput).ToXListenerSetSpecParentRefPatchPtrOutputWithContext(ctx)
}

// XListenerSetSpecParentRefPatchPtrInput is an input type that accepts XListenerSetSpecParentRefPatchArgs, XListenerSetSpecParentRefPatchPtr and XListenerSetSpecParentRefPatchPtrOutput values.
// You can construct a concrete instance of `XListenerSetSpecParentRefPatchPtrInput` via:
//
//	        XListenerSetSpecParentRefPatchArgs{...}
//
//	or:
//
//	        nil
type XListenerSetSpecParentRefPatchPtrInput interface {
	pulumi.Input

	ToXListenerSetSpecParentRefPatchPtrOutput() XListenerSetSpecParentRefPatchPtrOutput
	ToXListenerSetSpecParentRefPatchPtrOutputWithContext(context.Context) XListenerSetSpecParentRefPatchPtrOutput
}

type xlistenerSetSpecParentRefPatchPtrType XListenerSetSpecParentRefPatchArgs

func XListenerSetSpecParentRefPatchPtr(v *XListenerSetSpecParentRefPatchArgs) XListenerSetSpecParentRefPatchPtrInput {
	return (*xlistenerSetSpecParentRefPatchPtrType)(v)
}

func (*xlistenerSetSpecParentRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecParentRefPatch)(nil)).Elem()
}

func (i *xlistenerSetSpecParentRefPatchPtrType) ToXListenerSetSpecParentRefPatchPtrOutput() XListenerSetSpecParentRefPatchPtrOutput {
	return i.ToXListenerSetSpecParentRefPatchPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetSpecParentRefPatchPtrType) ToXListenerSetSpecParentRefPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecParentRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecParentRefPatchPtrOutput)
}

// ParentRef references the Gateway that the listeners are attached to.
type XListenerSetSpecParentRefPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecParentRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecParentRefPatch)(nil)).Elem()
}

func (o XListenerSetSpecParentRefPatchOutput) ToXListenerSetSpecParentRefPatchOutput() XListenerSetSpecParentRefPatchOutput {
	return o
}

func (o XListenerSetSpecParentRefPatchOutput) ToXListenerSetSpecParentRefPatchOutputWithContext(ctx context.Context) XListenerSetSpecParentRefPatchOutput {
	return o
}

func (o XListenerSetSpecParentRefPatchOutput) ToXListenerSetSpecParentRefPatchPtrOutput() XListenerSetSpecParentRefPatchPtrOutput {
	return o.ToXListenerSetSpecParentRefPatchPtrOutputWithContext(context.Background())
}

func (o XListenerSetSpecParentRefPatchOutput) ToXListenerSetSpecParentRefPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecParentRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetSpecParentRefPatch) *XListenerSetSpecParentRefPatch {
		return &v
	}).(XListenerSetSpecParentRefPatchPtrOutput)
}

// Group is the group of the referent.
func (o XListenerSetSpecParentRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecParentRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "Gateway".
func (o XListenerSetSpecParentRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecParentRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o XListenerSetSpecParentRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecParentRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.  If not present,
// the namespace of the referent is assumed to be the same as
// the namespace of the referring object.
func (o XListenerSetSpecParentRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecParentRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

type XListenerSetSpecParentRefPatchPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecParentRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecParentRefPatch)(nil)).Elem()
}

func (o XListenerSetSpecParentRefPatchPtrOutput) ToXListenerSetSpecParentRefPatchPtrOutput() XListenerSetSpecParentRefPatchPtrOutput {
	return o
}

func (o XListenerSetSpecParentRefPatchPtrOutput) ToXListenerSetSpecParentRefPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecParentRefPatchPtrOutput {
	return o
}

func (o XListenerSetSpecParentRefPatchPtrOutput) Elem() XListenerSetSpecParentRefPatchOutput {
	return o.ApplyT(func(v *XListenerSetSpecParentRefPatch) XListenerSetSpecParentRefPatch {
		if v != nil {
			return *v
		}
		var ret XListenerSetSpecParentRefPatch
		return ret
	}).(XListenerSetSpecParentRefPatchOutput)
}

// Group is the group of the referent.
func (o XListenerSetSpecParentRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent. For example "Gateway".
func (o XListenerSetSpecParentRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o XListenerSetSpecParentRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent.  If not present,
// the namespace of the referent is assumed to be the same as
// the namespace of the referring object.
func (o XListenerSetSpecParentRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Spec defines the desired state of ListenerSet.
type XListenerSetSpecPatch struct {
	// Listeners associated with this ListenerSet. Listeners define
	// logical endpoints that are bound on this referenced parent Gateway's addresses.
	//
	// Listeners in a `Gateway` and their attached `ListenerSets` are concatenated
	// as a list when programming the underlying infrastructure. Each listener
	// name does not need to be unique across the Gateway and ListenerSets.
	// See ListenerEntry.Name for more details.
	//
	// Implementations MUST treat the parent Gateway as having the merged
	// list of all listeners from itself and attached ListenerSets using
	// the following precedence:
	//
	// 1. "parent" Gateway
	// 2. ListenerSet ordered by creation time (oldest first)
	// 3. ListenerSet ordered alphabetically by “{namespace}/{name}”.
	//
	// An implementation MAY reject listeners by setting the ListenerEntryStatus
	// ` Accepted`` condition to False with the Reason  `TooManyListeners`
	//
	// If a listener has a conflict, this will be reported in the
	// Status.ListenerEntryStatus setting the `Conflicted` condition to True.
	//
	// Implementations SHOULD be cautious about what information from the
	// parent or siblings are reported to avoid accidentally leaking
	// sensitive information that the child would not otherwise have access
	// to. This can include contents of secrets etc.
	Listeners []XListenerSetSpecListenersPatch `pulumi:"listeners"`
	ParentRef *XListenerSetSpecParentRefPatch  `pulumi:"parentRef"`
}

// XListenerSetSpecPatchInput is an input type that accepts XListenerSetSpecPatchArgs and XListenerSetSpecPatchOutput values.
// You can construct a concrete instance of `XListenerSetSpecPatchInput` via:
//
//	XListenerSetSpecPatchArgs{...}
type XListenerSetSpecPatchInput interface {
	pulumi.Input

	ToXListenerSetSpecPatchOutput() XListenerSetSpecPatchOutput
	ToXListenerSetSpecPatchOutputWithContext(context.Context) XListenerSetSpecPatchOutput
}

// Spec defines the desired state of ListenerSet.
type XListenerSetSpecPatchArgs struct {
	// Listeners associated with this ListenerSet. Listeners define
	// logical endpoints that are bound on this referenced parent Gateway's addresses.
	//
	// Listeners in a `Gateway` and their attached `ListenerSets` are concatenated
	// as a list when programming the underlying infrastructure. Each listener
	// name does not need to be unique across the Gateway and ListenerSets.
	// See ListenerEntry.Name for more details.
	//
	// Implementations MUST treat the parent Gateway as having the merged
	// list of all listeners from itself and attached ListenerSets using
	// the following precedence:
	//
	// 1. "parent" Gateway
	// 2. ListenerSet ordered by creation time (oldest first)
	// 3. ListenerSet ordered alphabetically by “{namespace}/{name}”.
	//
	// An implementation MAY reject listeners by setting the ListenerEntryStatus
	// ` Accepted`` condition to False with the Reason  `TooManyListeners`
	//
	// If a listener has a conflict, this will be reported in the
	// Status.ListenerEntryStatus setting the `Conflicted` condition to True.
	//
	// Implementations SHOULD be cautious about what information from the
	// parent or siblings are reported to avoid accidentally leaking
	// sensitive information that the child would not otherwise have access
	// to. This can include contents of secrets etc.
	Listeners XListenerSetSpecListenersPatchArrayInput `pulumi:"listeners"`
	ParentRef XListenerSetSpecParentRefPatchPtrInput   `pulumi:"parentRef"`
}

func (XListenerSetSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecPatch)(nil)).Elem()
}

func (i XListenerSetSpecPatchArgs) ToXListenerSetSpecPatchOutput() XListenerSetSpecPatchOutput {
	return i.ToXListenerSetSpecPatchOutputWithContext(context.Background())
}

func (i XListenerSetSpecPatchArgs) ToXListenerSetSpecPatchOutputWithContext(ctx context.Context) XListenerSetSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecPatchOutput)
}

func (i XListenerSetSpecPatchArgs) ToXListenerSetSpecPatchPtrOutput() XListenerSetSpecPatchPtrOutput {
	return i.ToXListenerSetSpecPatchPtrOutputWithContext(context.Background())
}

func (i XListenerSetSpecPatchArgs) ToXListenerSetSpecPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecPatchOutput).ToXListenerSetSpecPatchPtrOutputWithContext(ctx)
}

// XListenerSetSpecPatchPtrInput is an input type that accepts XListenerSetSpecPatchArgs, XListenerSetSpecPatchPtr and XListenerSetSpecPatchPtrOutput values.
// You can construct a concrete instance of `XListenerSetSpecPatchPtrInput` via:
//
//	        XListenerSetSpecPatchArgs{...}
//
//	or:
//
//	        nil
type XListenerSetSpecPatchPtrInput interface {
	pulumi.Input

	ToXListenerSetSpecPatchPtrOutput() XListenerSetSpecPatchPtrOutput
	ToXListenerSetSpecPatchPtrOutputWithContext(context.Context) XListenerSetSpecPatchPtrOutput
}

type xlistenerSetSpecPatchPtrType XListenerSetSpecPatchArgs

func XListenerSetSpecPatchPtr(v *XListenerSetSpecPatchArgs) XListenerSetSpecPatchPtrInput {
	return (*xlistenerSetSpecPatchPtrType)(v)
}

func (*xlistenerSetSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecPatch)(nil)).Elem()
}

func (i *xlistenerSetSpecPatchPtrType) ToXListenerSetSpecPatchPtrOutput() XListenerSetSpecPatchPtrOutput {
	return i.ToXListenerSetSpecPatchPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetSpecPatchPtrType) ToXListenerSetSpecPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetSpecPatchPtrOutput)
}

// Spec defines the desired state of ListenerSet.
type XListenerSetSpecPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetSpecPatch)(nil)).Elem()
}

func (o XListenerSetSpecPatchOutput) ToXListenerSetSpecPatchOutput() XListenerSetSpecPatchOutput {
	return o
}

func (o XListenerSetSpecPatchOutput) ToXListenerSetSpecPatchOutputWithContext(ctx context.Context) XListenerSetSpecPatchOutput {
	return o
}

func (o XListenerSetSpecPatchOutput) ToXListenerSetSpecPatchPtrOutput() XListenerSetSpecPatchPtrOutput {
	return o.ToXListenerSetSpecPatchPtrOutputWithContext(context.Background())
}

func (o XListenerSetSpecPatchOutput) ToXListenerSetSpecPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetSpecPatch) *XListenerSetSpecPatch {
		return &v
	}).(XListenerSetSpecPatchPtrOutput)
}

// Listeners associated with this ListenerSet. Listeners define
// logical endpoints that are bound on this referenced parent Gateway's addresses.
//
// Listeners in a `Gateway` and their attached `ListenerSets` are concatenated
// as a list when programming the underlying infrastructure. Each listener
// name does not need to be unique across the Gateway and ListenerSets.
// See ListenerEntry.Name for more details.
//
// Implementations MUST treat the parent Gateway as having the merged
// list of all listeners from itself and attached ListenerSets using
// the following precedence:
//
// 1. "parent" Gateway
// 2. ListenerSet ordered by creation time (oldest first)
// 3. ListenerSet ordered alphabetically by “{namespace}/{name}”.
//
// An implementation MAY reject listeners by setting the ListenerEntryStatus
// ` Accepted“ condition to False with the Reason  `TooManyListeners`
//
// If a listener has a conflict, this will be reported in the
// Status.ListenerEntryStatus setting the `Conflicted` condition to True.
//
// Implementations SHOULD be cautious about what information from the
// parent or siblings are reported to avoid accidentally leaking
// sensitive information that the child would not otherwise have access
// to. This can include contents of secrets etc.
func (o XListenerSetSpecPatchOutput) Listeners() XListenerSetSpecListenersPatchArrayOutput {
	return o.ApplyT(func(v XListenerSetSpecPatch) []XListenerSetSpecListenersPatch { return v.Listeners }).(XListenerSetSpecListenersPatchArrayOutput)
}

func (o XListenerSetSpecPatchOutput) ParentRef() XListenerSetSpecParentRefPatchPtrOutput {
	return o.ApplyT(func(v XListenerSetSpecPatch) *XListenerSetSpecParentRefPatch { return v.ParentRef }).(XListenerSetSpecParentRefPatchPtrOutput)
}

type XListenerSetSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetSpecPatch)(nil)).Elem()
}

func (o XListenerSetSpecPatchPtrOutput) ToXListenerSetSpecPatchPtrOutput() XListenerSetSpecPatchPtrOutput {
	return o
}

func (o XListenerSetSpecPatchPtrOutput) ToXListenerSetSpecPatchPtrOutputWithContext(ctx context.Context) XListenerSetSpecPatchPtrOutput {
	return o
}

func (o XListenerSetSpecPatchPtrOutput) Elem() XListenerSetSpecPatchOutput {
	return o.ApplyT(func(v *XListenerSetSpecPatch) XListenerSetSpecPatch {
		if v != nil {
			return *v
		}
		var ret XListenerSetSpecPatch
		return ret
	}).(XListenerSetSpecPatchOutput)
}

// Listeners associated with this ListenerSet. Listeners define
// logical endpoints that are bound on this referenced parent Gateway's addresses.
//
// Listeners in a `Gateway` and their attached `ListenerSets` are concatenated
// as a list when programming the underlying infrastructure. Each listener
// name does not need to be unique across the Gateway and ListenerSets.
// See ListenerEntry.Name for more details.
//
// Implementations MUST treat the parent Gateway as having the merged
// list of all listeners from itself and attached ListenerSets using
// the following precedence:
//
// 1. "parent" Gateway
// 2. ListenerSet ordered by creation time (oldest first)
// 3. ListenerSet ordered alphabetically by “{namespace}/{name}”.
//
// An implementation MAY reject listeners by setting the ListenerEntryStatus
// ` Accepted“ condition to False with the Reason  `TooManyListeners`
//
// If a listener has a conflict, this will be reported in the
// Status.ListenerEntryStatus setting the `Conflicted` condition to True.
//
// Implementations SHOULD be cautious about what information from the
// parent or siblings are reported to avoid accidentally leaking
// sensitive information that the child would not otherwise have access
// to. This can include contents of secrets etc.
func (o XListenerSetSpecPatchPtrOutput) Listeners() XListenerSetSpecListenersPatchArrayOutput {
	return o.ApplyT(func(v *XListenerSetSpecPatch) []XListenerSetSpecListenersPatch {
		if v == nil {
			return nil
		}
		return v.Listeners
	}).(XListenerSetSpecListenersPatchArrayOutput)
}

func (o XListenerSetSpecPatchPtrOutput) ParentRef() XListenerSetSpecParentRefPatchPtrOutput {
	return o.ApplyT(func(v *XListenerSetSpecPatch) *XListenerSetSpecParentRefPatch {
		if v == nil {
			return nil
		}
		return v.ParentRef
	}).(XListenerSetSpecParentRefPatchPtrOutput)
}

// Status defines the current state of ListenerSet.
type XListenerSetStatus struct {
	// Conditions describe the current conditions of the ListenerSet.
	//
	// Implementations MUST express ListenerSet conditions using the
	// `ListenerSetConditionType` and `ListenerSetConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe ListenerSet state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	Conditions []XListenerSetStatusConditions `pulumi:"conditions"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners []XListenerSetStatusListeners `pulumi:"listeners"`
}

// XListenerSetStatusInput is an input type that accepts XListenerSetStatusArgs and XListenerSetStatusOutput values.
// You can construct a concrete instance of `XListenerSetStatusInput` via:
//
//	XListenerSetStatusArgs{...}
type XListenerSetStatusInput interface {
	pulumi.Input

	ToXListenerSetStatusOutput() XListenerSetStatusOutput
	ToXListenerSetStatusOutputWithContext(context.Context) XListenerSetStatusOutput
}

// Status defines the current state of ListenerSet.
type XListenerSetStatusArgs struct {
	// Conditions describe the current conditions of the ListenerSet.
	//
	// Implementations MUST express ListenerSet conditions using the
	// `ListenerSetConditionType` and `ListenerSetConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe ListenerSet state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	Conditions XListenerSetStatusConditionsArrayInput `pulumi:"conditions"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners XListenerSetStatusListenersArrayInput `pulumi:"listeners"`
}

func (XListenerSetStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatus)(nil)).Elem()
}

func (i XListenerSetStatusArgs) ToXListenerSetStatusOutput() XListenerSetStatusOutput {
	return i.ToXListenerSetStatusOutputWithContext(context.Background())
}

func (i XListenerSetStatusArgs) ToXListenerSetStatusOutputWithContext(ctx context.Context) XListenerSetStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusOutput)
}

func (i XListenerSetStatusArgs) ToXListenerSetStatusPtrOutput() XListenerSetStatusPtrOutput {
	return i.ToXListenerSetStatusPtrOutputWithContext(context.Background())
}

func (i XListenerSetStatusArgs) ToXListenerSetStatusPtrOutputWithContext(ctx context.Context) XListenerSetStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusOutput).ToXListenerSetStatusPtrOutputWithContext(ctx)
}

// XListenerSetStatusPtrInput is an input type that accepts XListenerSetStatusArgs, XListenerSetStatusPtr and XListenerSetStatusPtrOutput values.
// You can construct a concrete instance of `XListenerSetStatusPtrInput` via:
//
//	        XListenerSetStatusArgs{...}
//
//	or:
//
//	        nil
type XListenerSetStatusPtrInput interface {
	pulumi.Input

	ToXListenerSetStatusPtrOutput() XListenerSetStatusPtrOutput
	ToXListenerSetStatusPtrOutputWithContext(context.Context) XListenerSetStatusPtrOutput
}

type xlistenerSetStatusPtrType XListenerSetStatusArgs

func XListenerSetStatusPtr(v *XListenerSetStatusArgs) XListenerSetStatusPtrInput {
	return (*xlistenerSetStatusPtrType)(v)
}

func (*xlistenerSetStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetStatus)(nil)).Elem()
}

func (i *xlistenerSetStatusPtrType) ToXListenerSetStatusPtrOutput() XListenerSetStatusPtrOutput {
	return i.ToXListenerSetStatusPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetStatusPtrType) ToXListenerSetStatusPtrOutputWithContext(ctx context.Context) XListenerSetStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusPtrOutput)
}

// Status defines the current state of ListenerSet.
type XListenerSetStatusOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatus)(nil)).Elem()
}

func (o XListenerSetStatusOutput) ToXListenerSetStatusOutput() XListenerSetStatusOutput {
	return o
}

func (o XListenerSetStatusOutput) ToXListenerSetStatusOutputWithContext(ctx context.Context) XListenerSetStatusOutput {
	return o
}

func (o XListenerSetStatusOutput) ToXListenerSetStatusPtrOutput() XListenerSetStatusPtrOutput {
	return o.ToXListenerSetStatusPtrOutputWithContext(context.Background())
}

func (o XListenerSetStatusOutput) ToXListenerSetStatusPtrOutputWithContext(ctx context.Context) XListenerSetStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetStatus) *XListenerSetStatus {
		return &v
	}).(XListenerSetStatusPtrOutput)
}

// Conditions describe the current conditions of the ListenerSet.
//
// Implementations MUST express ListenerSet conditions using the
// `ListenerSetConditionType` and `ListenerSetConditionReason`
// constants so that operators and tools can converge on a common
// vocabulary to describe ListenerSet state.
//
// Known condition types are:
//
// * "Accepted"
// * "Programmed"
func (o XListenerSetStatusOutput) Conditions() XListenerSetStatusConditionsArrayOutput {
	return o.ApplyT(func(v XListenerSetStatus) []XListenerSetStatusConditions { return v.Conditions }).(XListenerSetStatusConditionsArrayOutput)
}

// Listeners provide status for each unique listener port defined in the Spec.
func (o XListenerSetStatusOutput) Listeners() XListenerSetStatusListenersArrayOutput {
	return o.ApplyT(func(v XListenerSetStatus) []XListenerSetStatusListeners { return v.Listeners }).(XListenerSetStatusListenersArrayOutput)
}

type XListenerSetStatusPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetStatus)(nil)).Elem()
}

func (o XListenerSetStatusPtrOutput) ToXListenerSetStatusPtrOutput() XListenerSetStatusPtrOutput {
	return o
}

func (o XListenerSetStatusPtrOutput) ToXListenerSetStatusPtrOutputWithContext(ctx context.Context) XListenerSetStatusPtrOutput {
	return o
}

func (o XListenerSetStatusPtrOutput) Elem() XListenerSetStatusOutput {
	return o.ApplyT(func(v *XListenerSetStatus) XListenerSetStatus {
		if v != nil {
			return *v
		}
		var ret XListenerSetStatus
		return ret
	}).(XListenerSetStatusOutput)
}

// Conditions describe the current conditions of the ListenerSet.
//
// Implementations MUST express ListenerSet conditions using the
// `ListenerSetConditionType` and `ListenerSetConditionReason`
// constants so that operators and tools can converge on a common
// vocabulary to describe ListenerSet state.
//
// Known condition types are:
//
// * "Accepted"
// * "Programmed"
func (o XListenerSetStatusPtrOutput) Conditions() XListenerSetStatusConditionsArrayOutput {
	return o.ApplyT(func(v *XListenerSetStatus) []XListenerSetStatusConditions {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(XListenerSetStatusConditionsArrayOutput)
}

// Listeners provide status for each unique listener port defined in the Spec.
func (o XListenerSetStatusPtrOutput) Listeners() XListenerSetStatusListenersArrayOutput {
	return o.ApplyT(func(v *XListenerSetStatus) []XListenerSetStatusListeners {
		if v == nil {
			return nil
		}
		return v.Listeners
	}).(XListenerSetStatusListenersArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type XListenerSetStatusConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type *string `pulumi:"type"`
}

// XListenerSetStatusConditionsInput is an input type that accepts XListenerSetStatusConditionsArgs and XListenerSetStatusConditionsOutput values.
// You can construct a concrete instance of `XListenerSetStatusConditionsInput` via:
//
//	XListenerSetStatusConditionsArgs{...}
type XListenerSetStatusConditionsInput interface {
	pulumi.Input

	ToXListenerSetStatusConditionsOutput() XListenerSetStatusConditionsOutput
	ToXListenerSetStatusConditionsOutputWithContext(context.Context) XListenerSetStatusConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
type XListenerSetStatusConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (XListenerSetStatusConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusConditions)(nil)).Elem()
}

func (i XListenerSetStatusConditionsArgs) ToXListenerSetStatusConditionsOutput() XListenerSetStatusConditionsOutput {
	return i.ToXListenerSetStatusConditionsOutputWithContext(context.Background())
}

func (i XListenerSetStatusConditionsArgs) ToXListenerSetStatusConditionsOutputWithContext(ctx context.Context) XListenerSetStatusConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusConditionsOutput)
}

// XListenerSetStatusConditionsArrayInput is an input type that accepts XListenerSetStatusConditionsArray and XListenerSetStatusConditionsArrayOutput values.
// You can construct a concrete instance of `XListenerSetStatusConditionsArrayInput` via:
//
//	XListenerSetStatusConditionsArray{ XListenerSetStatusConditionsArgs{...} }
type XListenerSetStatusConditionsArrayInput interface {
	pulumi.Input

	ToXListenerSetStatusConditionsArrayOutput() XListenerSetStatusConditionsArrayOutput
	ToXListenerSetStatusConditionsArrayOutputWithContext(context.Context) XListenerSetStatusConditionsArrayOutput
}

type XListenerSetStatusConditionsArray []XListenerSetStatusConditionsInput

func (XListenerSetStatusConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusConditions)(nil)).Elem()
}

func (i XListenerSetStatusConditionsArray) ToXListenerSetStatusConditionsArrayOutput() XListenerSetStatusConditionsArrayOutput {
	return i.ToXListenerSetStatusConditionsArrayOutputWithContext(context.Background())
}

func (i XListenerSetStatusConditionsArray) ToXListenerSetStatusConditionsArrayOutputWithContext(ctx context.Context) XListenerSetStatusConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type XListenerSetStatusConditionsOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusConditions)(nil)).Elem()
}

func (o XListenerSetStatusConditionsOutput) ToXListenerSetStatusConditionsOutput() XListenerSetStatusConditionsOutput {
	return o
}

func (o XListenerSetStatusConditionsOutput) ToXListenerSetStatusConditionsOutputWithContext(ctx context.Context) XListenerSetStatusConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o XListenerSetStatusConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o XListenerSetStatusConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o XListenerSetStatusConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o XListenerSetStatusConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o XListenerSetStatusConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
func (o XListenerSetStatusConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type XListenerSetStatusConditionsArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusConditions)(nil)).Elem()
}

func (o XListenerSetStatusConditionsArrayOutput) ToXListenerSetStatusConditionsArrayOutput() XListenerSetStatusConditionsArrayOutput {
	return o
}

func (o XListenerSetStatusConditionsArrayOutput) ToXListenerSetStatusConditionsArrayOutputWithContext(ctx context.Context) XListenerSetStatusConditionsArrayOutput {
	return o
}

func (o XListenerSetStatusConditionsArrayOutput) Index(i pulumi.IntInput) XListenerSetStatusConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetStatusConditions {
		return vs[0].([]XListenerSetStatusConditions)[vs[1].(int)]
	}).(XListenerSetStatusConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type XListenerSetStatusConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type *string `pulumi:"type"`
}

// XListenerSetStatusConditionsPatchInput is an input type that accepts XListenerSetStatusConditionsPatchArgs and XListenerSetStatusConditionsPatchOutput values.
// You can construct a concrete instance of `XListenerSetStatusConditionsPatchInput` via:
//
//	XListenerSetStatusConditionsPatchArgs{...}
type XListenerSetStatusConditionsPatchInput interface {
	pulumi.Input

	ToXListenerSetStatusConditionsPatchOutput() XListenerSetStatusConditionsPatchOutput
	ToXListenerSetStatusConditionsPatchOutputWithContext(context.Context) XListenerSetStatusConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
type XListenerSetStatusConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (XListenerSetStatusConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusConditionsPatch)(nil)).Elem()
}

func (i XListenerSetStatusConditionsPatchArgs) ToXListenerSetStatusConditionsPatchOutput() XListenerSetStatusConditionsPatchOutput {
	return i.ToXListenerSetStatusConditionsPatchOutputWithContext(context.Background())
}

func (i XListenerSetStatusConditionsPatchArgs) ToXListenerSetStatusConditionsPatchOutputWithContext(ctx context.Context) XListenerSetStatusConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusConditionsPatchOutput)
}

// XListenerSetStatusConditionsPatchArrayInput is an input type that accepts XListenerSetStatusConditionsPatchArray and XListenerSetStatusConditionsPatchArrayOutput values.
// You can construct a concrete instance of `XListenerSetStatusConditionsPatchArrayInput` via:
//
//	XListenerSetStatusConditionsPatchArray{ XListenerSetStatusConditionsPatchArgs{...} }
type XListenerSetStatusConditionsPatchArrayInput interface {
	pulumi.Input

	ToXListenerSetStatusConditionsPatchArrayOutput() XListenerSetStatusConditionsPatchArrayOutput
	ToXListenerSetStatusConditionsPatchArrayOutputWithContext(context.Context) XListenerSetStatusConditionsPatchArrayOutput
}

type XListenerSetStatusConditionsPatchArray []XListenerSetStatusConditionsPatchInput

func (XListenerSetStatusConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusConditionsPatch)(nil)).Elem()
}

func (i XListenerSetStatusConditionsPatchArray) ToXListenerSetStatusConditionsPatchArrayOutput() XListenerSetStatusConditionsPatchArrayOutput {
	return i.ToXListenerSetStatusConditionsPatchArrayOutputWithContext(context.Background())
}

func (i XListenerSetStatusConditionsPatchArray) ToXListenerSetStatusConditionsPatchArrayOutputWithContext(ctx context.Context) XListenerSetStatusConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type XListenerSetStatusConditionsPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusConditionsPatch)(nil)).Elem()
}

func (o XListenerSetStatusConditionsPatchOutput) ToXListenerSetStatusConditionsPatchOutput() XListenerSetStatusConditionsPatchOutput {
	return o
}

func (o XListenerSetStatusConditionsPatchOutput) ToXListenerSetStatusConditionsPatchOutputWithContext(ctx context.Context) XListenerSetStatusConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o XListenerSetStatusConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o XListenerSetStatusConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o XListenerSetStatusConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o XListenerSetStatusConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o XListenerSetStatusConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
func (o XListenerSetStatusConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type XListenerSetStatusConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusConditionsPatch)(nil)).Elem()
}

func (o XListenerSetStatusConditionsPatchArrayOutput) ToXListenerSetStatusConditionsPatchArrayOutput() XListenerSetStatusConditionsPatchArrayOutput {
	return o
}

func (o XListenerSetStatusConditionsPatchArrayOutput) ToXListenerSetStatusConditionsPatchArrayOutputWithContext(ctx context.Context) XListenerSetStatusConditionsPatchArrayOutput {
	return o
}

func (o XListenerSetStatusConditionsPatchArrayOutput) Index(i pulumi.IntInput) XListenerSetStatusConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetStatusConditionsPatch {
		return vs[0].([]XListenerSetStatusConditionsPatch)[vs[1].(int)]
	}).(XListenerSetStatusConditionsPatchOutput)
}

// ListenerStatus is the status associated with a Listener.
type XListenerSetStatusListeners struct {
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners with condition Accepted: false and MUST count successfully
	// attached Routes that may themselves have Accepted: false conditions.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes *int `pulumi:"attachedRoutes"`
	// Conditions describe the current condition of this listener.
	Conditions []XListenerSetStatusListenersConditions `pulumi:"conditions"`
	// Name is the name of the Listener that this status corresponds to.
	Name *string `pulumi:"name"`
	// Port is the network port the listener is configured to listen on.
	Port *int `pulumi:"port"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds an implementation supports for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds []XListenerSetStatusListenersSupportedKinds `pulumi:"supportedKinds"`
}

// XListenerSetStatusListenersInput is an input type that accepts XListenerSetStatusListenersArgs and XListenerSetStatusListenersOutput values.
// You can construct a concrete instance of `XListenerSetStatusListenersInput` via:
//
//	XListenerSetStatusListenersArgs{...}
type XListenerSetStatusListenersInput interface {
	pulumi.Input

	ToXListenerSetStatusListenersOutput() XListenerSetStatusListenersOutput
	ToXListenerSetStatusListenersOutputWithContext(context.Context) XListenerSetStatusListenersOutput
}

// ListenerStatus is the status associated with a Listener.
type XListenerSetStatusListenersArgs struct {
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners with condition Accepted: false and MUST count successfully
	// attached Routes that may themselves have Accepted: false conditions.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes pulumi.IntPtrInput `pulumi:"attachedRoutes"`
	// Conditions describe the current condition of this listener.
	Conditions XListenerSetStatusListenersConditionsArrayInput `pulumi:"conditions"`
	// Name is the name of the Listener that this status corresponds to.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Port is the network port the listener is configured to listen on.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds an implementation supports for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds XListenerSetStatusListenersSupportedKindsArrayInput `pulumi:"supportedKinds"`
}

func (XListenerSetStatusListenersArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusListeners)(nil)).Elem()
}

func (i XListenerSetStatusListenersArgs) ToXListenerSetStatusListenersOutput() XListenerSetStatusListenersOutput {
	return i.ToXListenerSetStatusListenersOutputWithContext(context.Background())
}

func (i XListenerSetStatusListenersArgs) ToXListenerSetStatusListenersOutputWithContext(ctx context.Context) XListenerSetStatusListenersOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusListenersOutput)
}

// XListenerSetStatusListenersArrayInput is an input type that accepts XListenerSetStatusListenersArray and XListenerSetStatusListenersArrayOutput values.
// You can construct a concrete instance of `XListenerSetStatusListenersArrayInput` via:
//
//	XListenerSetStatusListenersArray{ XListenerSetStatusListenersArgs{...} }
type XListenerSetStatusListenersArrayInput interface {
	pulumi.Input

	ToXListenerSetStatusListenersArrayOutput() XListenerSetStatusListenersArrayOutput
	ToXListenerSetStatusListenersArrayOutputWithContext(context.Context) XListenerSetStatusListenersArrayOutput
}

type XListenerSetStatusListenersArray []XListenerSetStatusListenersInput

func (XListenerSetStatusListenersArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusListeners)(nil)).Elem()
}

func (i XListenerSetStatusListenersArray) ToXListenerSetStatusListenersArrayOutput() XListenerSetStatusListenersArrayOutput {
	return i.ToXListenerSetStatusListenersArrayOutputWithContext(context.Background())
}

func (i XListenerSetStatusListenersArray) ToXListenerSetStatusListenersArrayOutputWithContext(ctx context.Context) XListenerSetStatusListenersArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusListenersArrayOutput)
}

// ListenerStatus is the status associated with a Listener.
type XListenerSetStatusListenersOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusListenersOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusListeners)(nil)).Elem()
}

func (o XListenerSetStatusListenersOutput) ToXListenerSetStatusListenersOutput() XListenerSetStatusListenersOutput {
	return o
}

func (o XListenerSetStatusListenersOutput) ToXListenerSetStatusListenersOutputWithContext(ctx context.Context) XListenerSetStatusListenersOutput {
	return o
}

// AttachedRoutes represents the total number of Routes that have been
// successfully attached to this Listener.
//
// Successful attachment of a Route to a Listener is based solely on the
// combination of the AllowedRoutes field on the corresponding Listener
// and the Route's ParentRefs field. A Route is successfully attached to
// a Listener when it is selected by the Listener's AllowedRoutes field
// AND the Route has a valid ParentRef selecting the whole Gateway
// resource or a specific Listener as a parent resource (more detail on
// attachment semantics can be found in the documentation on the various
// Route kinds ParentRefs fields). Listener or Route status does not impact
// successful attachment, i.e. the AttachedRoutes field count MUST be set
// for Listeners with condition Accepted: false and MUST count successfully
// attached Routes that may themselves have Accepted: false conditions.
//
// Uses for this field include troubleshooting Route attachment and
// measuring blast radius/impact of changes to a Listener.
func (o XListenerSetStatusListenersOutput) AttachedRoutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListeners) *int { return v.AttachedRoutes }).(pulumi.IntPtrOutput)
}

// Conditions describe the current condition of this listener.
func (o XListenerSetStatusListenersOutput) Conditions() XListenerSetStatusListenersConditionsArrayOutput {
	return o.ApplyT(func(v XListenerSetStatusListeners) []XListenerSetStatusListenersConditions { return v.Conditions }).(XListenerSetStatusListenersConditionsArrayOutput)
}

// Name is the name of the Listener that this status corresponds to.
func (o XListenerSetStatusListenersOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListeners) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Port is the network port the listener is configured to listen on.
func (o XListenerSetStatusListenersOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListeners) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SupportedKinds is the list indicating the Kinds supported by this
// listener. This MUST represent the kinds an implementation supports for
// that Listener configuration.
//
// If kinds are specified in Spec that are not supported, they MUST NOT
// appear in this list and an implementation MUST set the "ResolvedRefs"
// condition to "False" with the "InvalidRouteKinds" reason. If both valid
// and invalid Route kinds are specified, the implementation MUST
// reference the valid Route kinds that have been specified.
func (o XListenerSetStatusListenersOutput) SupportedKinds() XListenerSetStatusListenersSupportedKindsArrayOutput {
	return o.ApplyT(func(v XListenerSetStatusListeners) []XListenerSetStatusListenersSupportedKinds {
		return v.SupportedKinds
	}).(XListenerSetStatusListenersSupportedKindsArrayOutput)
}

type XListenerSetStatusListenersArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusListenersArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusListeners)(nil)).Elem()
}

func (o XListenerSetStatusListenersArrayOutput) ToXListenerSetStatusListenersArrayOutput() XListenerSetStatusListenersArrayOutput {
	return o
}

func (o XListenerSetStatusListenersArrayOutput) ToXListenerSetStatusListenersArrayOutputWithContext(ctx context.Context) XListenerSetStatusListenersArrayOutput {
	return o
}

func (o XListenerSetStatusListenersArrayOutput) Index(i pulumi.IntInput) XListenerSetStatusListenersOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetStatusListeners {
		return vs[0].([]XListenerSetStatusListeners)[vs[1].(int)]
	}).(XListenerSetStatusListenersOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type XListenerSetStatusListenersConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type *string `pulumi:"type"`
}

// XListenerSetStatusListenersConditionsInput is an input type that accepts XListenerSetStatusListenersConditionsArgs and XListenerSetStatusListenersConditionsOutput values.
// You can construct a concrete instance of `XListenerSetStatusListenersConditionsInput` via:
//
//	XListenerSetStatusListenersConditionsArgs{...}
type XListenerSetStatusListenersConditionsInput interface {
	pulumi.Input

	ToXListenerSetStatusListenersConditionsOutput() XListenerSetStatusListenersConditionsOutput
	ToXListenerSetStatusListenersConditionsOutputWithContext(context.Context) XListenerSetStatusListenersConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
type XListenerSetStatusListenersConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (XListenerSetStatusListenersConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusListenersConditions)(nil)).Elem()
}

func (i XListenerSetStatusListenersConditionsArgs) ToXListenerSetStatusListenersConditionsOutput() XListenerSetStatusListenersConditionsOutput {
	return i.ToXListenerSetStatusListenersConditionsOutputWithContext(context.Background())
}

func (i XListenerSetStatusListenersConditionsArgs) ToXListenerSetStatusListenersConditionsOutputWithContext(ctx context.Context) XListenerSetStatusListenersConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusListenersConditionsOutput)
}

// XListenerSetStatusListenersConditionsArrayInput is an input type that accepts XListenerSetStatusListenersConditionsArray and XListenerSetStatusListenersConditionsArrayOutput values.
// You can construct a concrete instance of `XListenerSetStatusListenersConditionsArrayInput` via:
//
//	XListenerSetStatusListenersConditionsArray{ XListenerSetStatusListenersConditionsArgs{...} }
type XListenerSetStatusListenersConditionsArrayInput interface {
	pulumi.Input

	ToXListenerSetStatusListenersConditionsArrayOutput() XListenerSetStatusListenersConditionsArrayOutput
	ToXListenerSetStatusListenersConditionsArrayOutputWithContext(context.Context) XListenerSetStatusListenersConditionsArrayOutput
}

type XListenerSetStatusListenersConditionsArray []XListenerSetStatusListenersConditionsInput

func (XListenerSetStatusListenersConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusListenersConditions)(nil)).Elem()
}

func (i XListenerSetStatusListenersConditionsArray) ToXListenerSetStatusListenersConditionsArrayOutput() XListenerSetStatusListenersConditionsArrayOutput {
	return i.ToXListenerSetStatusListenersConditionsArrayOutputWithContext(context.Background())
}

func (i XListenerSetStatusListenersConditionsArray) ToXListenerSetStatusListenersConditionsArrayOutputWithContext(ctx context.Context) XListenerSetStatusListenersConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusListenersConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type XListenerSetStatusListenersConditionsOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusListenersConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusListenersConditions)(nil)).Elem()
}

func (o XListenerSetStatusListenersConditionsOutput) ToXListenerSetStatusListenersConditionsOutput() XListenerSetStatusListenersConditionsOutput {
	return o
}

func (o XListenerSetStatusListenersConditionsOutput) ToXListenerSetStatusListenersConditionsOutputWithContext(ctx context.Context) XListenerSetStatusListenersConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o XListenerSetStatusListenersConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o XListenerSetStatusListenersConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o XListenerSetStatusListenersConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o XListenerSetStatusListenersConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o XListenerSetStatusListenersConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
func (o XListenerSetStatusListenersConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type XListenerSetStatusListenersConditionsArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusListenersConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusListenersConditions)(nil)).Elem()
}

func (o XListenerSetStatusListenersConditionsArrayOutput) ToXListenerSetStatusListenersConditionsArrayOutput() XListenerSetStatusListenersConditionsArrayOutput {
	return o
}

func (o XListenerSetStatusListenersConditionsArrayOutput) ToXListenerSetStatusListenersConditionsArrayOutputWithContext(ctx context.Context) XListenerSetStatusListenersConditionsArrayOutput {
	return o
}

func (o XListenerSetStatusListenersConditionsArrayOutput) Index(i pulumi.IntInput) XListenerSetStatusListenersConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetStatusListenersConditions {
		return vs[0].([]XListenerSetStatusListenersConditions)[vs[1].(int)]
	}).(XListenerSetStatusListenersConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type XListenerSetStatusListenersConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type *string `pulumi:"type"`
}

// XListenerSetStatusListenersConditionsPatchInput is an input type that accepts XListenerSetStatusListenersConditionsPatchArgs and XListenerSetStatusListenersConditionsPatchOutput values.
// You can construct a concrete instance of `XListenerSetStatusListenersConditionsPatchInput` via:
//
//	XListenerSetStatusListenersConditionsPatchArgs{...}
type XListenerSetStatusListenersConditionsPatchInput interface {
	pulumi.Input

	ToXListenerSetStatusListenersConditionsPatchOutput() XListenerSetStatusListenersConditionsPatchOutput
	ToXListenerSetStatusListenersConditionsPatchOutputWithContext(context.Context) XListenerSetStatusListenersConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
type XListenerSetStatusListenersConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (XListenerSetStatusListenersConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusListenersConditionsPatch)(nil)).Elem()
}

func (i XListenerSetStatusListenersConditionsPatchArgs) ToXListenerSetStatusListenersConditionsPatchOutput() XListenerSetStatusListenersConditionsPatchOutput {
	return i.ToXListenerSetStatusListenersConditionsPatchOutputWithContext(context.Background())
}

func (i XListenerSetStatusListenersConditionsPatchArgs) ToXListenerSetStatusListenersConditionsPatchOutputWithContext(ctx context.Context) XListenerSetStatusListenersConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusListenersConditionsPatchOutput)
}

// XListenerSetStatusListenersConditionsPatchArrayInput is an input type that accepts XListenerSetStatusListenersConditionsPatchArray and XListenerSetStatusListenersConditionsPatchArrayOutput values.
// You can construct a concrete instance of `XListenerSetStatusListenersConditionsPatchArrayInput` via:
//
//	XListenerSetStatusListenersConditionsPatchArray{ XListenerSetStatusListenersConditionsPatchArgs{...} }
type XListenerSetStatusListenersConditionsPatchArrayInput interface {
	pulumi.Input

	ToXListenerSetStatusListenersConditionsPatchArrayOutput() XListenerSetStatusListenersConditionsPatchArrayOutput
	ToXListenerSetStatusListenersConditionsPatchArrayOutputWithContext(context.Context) XListenerSetStatusListenersConditionsPatchArrayOutput
}

type XListenerSetStatusListenersConditionsPatchArray []XListenerSetStatusListenersConditionsPatchInput

func (XListenerSetStatusListenersConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusListenersConditionsPatch)(nil)).Elem()
}

func (i XListenerSetStatusListenersConditionsPatchArray) ToXListenerSetStatusListenersConditionsPatchArrayOutput() XListenerSetStatusListenersConditionsPatchArrayOutput {
	return i.ToXListenerSetStatusListenersConditionsPatchArrayOutputWithContext(context.Background())
}

func (i XListenerSetStatusListenersConditionsPatchArray) ToXListenerSetStatusListenersConditionsPatchArrayOutputWithContext(ctx context.Context) XListenerSetStatusListenersConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusListenersConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type XListenerSetStatusListenersConditionsPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusListenersConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusListenersConditionsPatch)(nil)).Elem()
}

func (o XListenerSetStatusListenersConditionsPatchOutput) ToXListenerSetStatusListenersConditionsPatchOutput() XListenerSetStatusListenersConditionsPatchOutput {
	return o
}

func (o XListenerSetStatusListenersConditionsPatchOutput) ToXListenerSetStatusListenersConditionsPatchOutputWithContext(ctx context.Context) XListenerSetStatusListenersConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o XListenerSetStatusListenersConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o XListenerSetStatusListenersConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o XListenerSetStatusListenersConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o XListenerSetStatusListenersConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o XListenerSetStatusListenersConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
func (o XListenerSetStatusListenersConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type XListenerSetStatusListenersConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusListenersConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusListenersConditionsPatch)(nil)).Elem()
}

func (o XListenerSetStatusListenersConditionsPatchArrayOutput) ToXListenerSetStatusListenersConditionsPatchArrayOutput() XListenerSetStatusListenersConditionsPatchArrayOutput {
	return o
}

func (o XListenerSetStatusListenersConditionsPatchArrayOutput) ToXListenerSetStatusListenersConditionsPatchArrayOutputWithContext(ctx context.Context) XListenerSetStatusListenersConditionsPatchArrayOutput {
	return o
}

func (o XListenerSetStatusListenersConditionsPatchArrayOutput) Index(i pulumi.IntInput) XListenerSetStatusListenersConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetStatusListenersConditionsPatch {
		return vs[0].([]XListenerSetStatusListenersConditionsPatch)[vs[1].(int)]
	}).(XListenerSetStatusListenersConditionsPatchOutput)
}

// ListenerStatus is the status associated with a Listener.
type XListenerSetStatusListenersPatch struct {
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners with condition Accepted: false and MUST count successfully
	// attached Routes that may themselves have Accepted: false conditions.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes *int `pulumi:"attachedRoutes"`
	// Conditions describe the current condition of this listener.
	Conditions []XListenerSetStatusListenersConditionsPatch `pulumi:"conditions"`
	// Name is the name of the Listener that this status corresponds to.
	Name *string `pulumi:"name"`
	// Port is the network port the listener is configured to listen on.
	Port *int `pulumi:"port"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds an implementation supports for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds []XListenerSetStatusListenersSupportedKindsPatch `pulumi:"supportedKinds"`
}

// XListenerSetStatusListenersPatchInput is an input type that accepts XListenerSetStatusListenersPatchArgs and XListenerSetStatusListenersPatchOutput values.
// You can construct a concrete instance of `XListenerSetStatusListenersPatchInput` via:
//
//	XListenerSetStatusListenersPatchArgs{...}
type XListenerSetStatusListenersPatchInput interface {
	pulumi.Input

	ToXListenerSetStatusListenersPatchOutput() XListenerSetStatusListenersPatchOutput
	ToXListenerSetStatusListenersPatchOutputWithContext(context.Context) XListenerSetStatusListenersPatchOutput
}

// ListenerStatus is the status associated with a Listener.
type XListenerSetStatusListenersPatchArgs struct {
	// AttachedRoutes represents the total number of Routes that have been
	// successfully attached to this Listener.
	//
	// Successful attachment of a Route to a Listener is based solely on the
	// combination of the AllowedRoutes field on the corresponding Listener
	// and the Route's ParentRefs field. A Route is successfully attached to
	// a Listener when it is selected by the Listener's AllowedRoutes field
	// AND the Route has a valid ParentRef selecting the whole Gateway
	// resource or a specific Listener as a parent resource (more detail on
	// attachment semantics can be found in the documentation on the various
	// Route kinds ParentRefs fields). Listener or Route status does not impact
	// successful attachment, i.e. the AttachedRoutes field count MUST be set
	// for Listeners with condition Accepted: false and MUST count successfully
	// attached Routes that may themselves have Accepted: false conditions.
	//
	// Uses for this field include troubleshooting Route attachment and
	// measuring blast radius/impact of changes to a Listener.
	AttachedRoutes pulumi.IntPtrInput `pulumi:"attachedRoutes"`
	// Conditions describe the current condition of this listener.
	Conditions XListenerSetStatusListenersConditionsPatchArrayInput `pulumi:"conditions"`
	// Name is the name of the Listener that this status corresponds to.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Port is the network port the listener is configured to listen on.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SupportedKinds is the list indicating the Kinds supported by this
	// listener. This MUST represent the kinds an implementation supports for
	// that Listener configuration.
	//
	// If kinds are specified in Spec that are not supported, they MUST NOT
	// appear in this list and an implementation MUST set the "ResolvedRefs"
	// condition to "False" with the "InvalidRouteKinds" reason. If both valid
	// and invalid Route kinds are specified, the implementation MUST
	// reference the valid Route kinds that have been specified.
	SupportedKinds XListenerSetStatusListenersSupportedKindsPatchArrayInput `pulumi:"supportedKinds"`
}

func (XListenerSetStatusListenersPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusListenersPatch)(nil)).Elem()
}

func (i XListenerSetStatusListenersPatchArgs) ToXListenerSetStatusListenersPatchOutput() XListenerSetStatusListenersPatchOutput {
	return i.ToXListenerSetStatusListenersPatchOutputWithContext(context.Background())
}

func (i XListenerSetStatusListenersPatchArgs) ToXListenerSetStatusListenersPatchOutputWithContext(ctx context.Context) XListenerSetStatusListenersPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusListenersPatchOutput)
}

// XListenerSetStatusListenersPatchArrayInput is an input type that accepts XListenerSetStatusListenersPatchArray and XListenerSetStatusListenersPatchArrayOutput values.
// You can construct a concrete instance of `XListenerSetStatusListenersPatchArrayInput` via:
//
//	XListenerSetStatusListenersPatchArray{ XListenerSetStatusListenersPatchArgs{...} }
type XListenerSetStatusListenersPatchArrayInput interface {
	pulumi.Input

	ToXListenerSetStatusListenersPatchArrayOutput() XListenerSetStatusListenersPatchArrayOutput
	ToXListenerSetStatusListenersPatchArrayOutputWithContext(context.Context) XListenerSetStatusListenersPatchArrayOutput
}

type XListenerSetStatusListenersPatchArray []XListenerSetStatusListenersPatchInput

func (XListenerSetStatusListenersPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusListenersPatch)(nil)).Elem()
}

func (i XListenerSetStatusListenersPatchArray) ToXListenerSetStatusListenersPatchArrayOutput() XListenerSetStatusListenersPatchArrayOutput {
	return i.ToXListenerSetStatusListenersPatchArrayOutputWithContext(context.Background())
}

func (i XListenerSetStatusListenersPatchArray) ToXListenerSetStatusListenersPatchArrayOutputWithContext(ctx context.Context) XListenerSetStatusListenersPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusListenersPatchArrayOutput)
}

// ListenerStatus is the status associated with a Listener.
type XListenerSetStatusListenersPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusListenersPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusListenersPatch)(nil)).Elem()
}

func (o XListenerSetStatusListenersPatchOutput) ToXListenerSetStatusListenersPatchOutput() XListenerSetStatusListenersPatchOutput {
	return o
}

func (o XListenerSetStatusListenersPatchOutput) ToXListenerSetStatusListenersPatchOutputWithContext(ctx context.Context) XListenerSetStatusListenersPatchOutput {
	return o
}

// AttachedRoutes represents the total number of Routes that have been
// successfully attached to this Listener.
//
// Successful attachment of a Route to a Listener is based solely on the
// combination of the AllowedRoutes field on the corresponding Listener
// and the Route's ParentRefs field. A Route is successfully attached to
// a Listener when it is selected by the Listener's AllowedRoutes field
// AND the Route has a valid ParentRef selecting the whole Gateway
// resource or a specific Listener as a parent resource (more detail on
// attachment semantics can be found in the documentation on the various
// Route kinds ParentRefs fields). Listener or Route status does not impact
// successful attachment, i.e. the AttachedRoutes field count MUST be set
// for Listeners with condition Accepted: false and MUST count successfully
// attached Routes that may themselves have Accepted: false conditions.
//
// Uses for this field include troubleshooting Route attachment and
// measuring blast radius/impact of changes to a Listener.
func (o XListenerSetStatusListenersPatchOutput) AttachedRoutes() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersPatch) *int { return v.AttachedRoutes }).(pulumi.IntPtrOutput)
}

// Conditions describe the current condition of this listener.
func (o XListenerSetStatusListenersPatchOutput) Conditions() XListenerSetStatusListenersConditionsPatchArrayOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersPatch) []XListenerSetStatusListenersConditionsPatch {
		return v.Conditions
	}).(XListenerSetStatusListenersConditionsPatchArrayOutput)
}

// Name is the name of the Listener that this status corresponds to.
func (o XListenerSetStatusListenersPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Port is the network port the listener is configured to listen on.
func (o XListenerSetStatusListenersPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SupportedKinds is the list indicating the Kinds supported by this
// listener. This MUST represent the kinds an implementation supports for
// that Listener configuration.
//
// If kinds are specified in Spec that are not supported, they MUST NOT
// appear in this list and an implementation MUST set the "ResolvedRefs"
// condition to "False" with the "InvalidRouteKinds" reason. If both valid
// and invalid Route kinds are specified, the implementation MUST
// reference the valid Route kinds that have been specified.
func (o XListenerSetStatusListenersPatchOutput) SupportedKinds() XListenerSetStatusListenersSupportedKindsPatchArrayOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersPatch) []XListenerSetStatusListenersSupportedKindsPatch {
		return v.SupportedKinds
	}).(XListenerSetStatusListenersSupportedKindsPatchArrayOutput)
}

type XListenerSetStatusListenersPatchArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusListenersPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusListenersPatch)(nil)).Elem()
}

func (o XListenerSetStatusListenersPatchArrayOutput) ToXListenerSetStatusListenersPatchArrayOutput() XListenerSetStatusListenersPatchArrayOutput {
	return o
}

func (o XListenerSetStatusListenersPatchArrayOutput) ToXListenerSetStatusListenersPatchArrayOutputWithContext(ctx context.Context) XListenerSetStatusListenersPatchArrayOutput {
	return o
}

func (o XListenerSetStatusListenersPatchArrayOutput) Index(i pulumi.IntInput) XListenerSetStatusListenersPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetStatusListenersPatch {
		return vs[0].([]XListenerSetStatusListenersPatch)[vs[1].(int)]
	}).(XListenerSetStatusListenersPatchOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type XListenerSetStatusListenersSupportedKinds struct {
	// Group is the group of the Route.
	Group *string `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind *string `pulumi:"kind"`
}

// XListenerSetStatusListenersSupportedKindsInput is an input type that accepts XListenerSetStatusListenersSupportedKindsArgs and XListenerSetStatusListenersSupportedKindsOutput values.
// You can construct a concrete instance of `XListenerSetStatusListenersSupportedKindsInput` via:
//
//	XListenerSetStatusListenersSupportedKindsArgs{...}
type XListenerSetStatusListenersSupportedKindsInput interface {
	pulumi.Input

	ToXListenerSetStatusListenersSupportedKindsOutput() XListenerSetStatusListenersSupportedKindsOutput
	ToXListenerSetStatusListenersSupportedKindsOutputWithContext(context.Context) XListenerSetStatusListenersSupportedKindsOutput
}

// RouteGroupKind indicates the group and kind of a Route resource.
type XListenerSetStatusListenersSupportedKindsArgs struct {
	// Group is the group of the Route.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
}

func (XListenerSetStatusListenersSupportedKindsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusListenersSupportedKinds)(nil)).Elem()
}

func (i XListenerSetStatusListenersSupportedKindsArgs) ToXListenerSetStatusListenersSupportedKindsOutput() XListenerSetStatusListenersSupportedKindsOutput {
	return i.ToXListenerSetStatusListenersSupportedKindsOutputWithContext(context.Background())
}

func (i XListenerSetStatusListenersSupportedKindsArgs) ToXListenerSetStatusListenersSupportedKindsOutputWithContext(ctx context.Context) XListenerSetStatusListenersSupportedKindsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusListenersSupportedKindsOutput)
}

// XListenerSetStatusListenersSupportedKindsArrayInput is an input type that accepts XListenerSetStatusListenersSupportedKindsArray and XListenerSetStatusListenersSupportedKindsArrayOutput values.
// You can construct a concrete instance of `XListenerSetStatusListenersSupportedKindsArrayInput` via:
//
//	XListenerSetStatusListenersSupportedKindsArray{ XListenerSetStatusListenersSupportedKindsArgs{...} }
type XListenerSetStatusListenersSupportedKindsArrayInput interface {
	pulumi.Input

	ToXListenerSetStatusListenersSupportedKindsArrayOutput() XListenerSetStatusListenersSupportedKindsArrayOutput
	ToXListenerSetStatusListenersSupportedKindsArrayOutputWithContext(context.Context) XListenerSetStatusListenersSupportedKindsArrayOutput
}

type XListenerSetStatusListenersSupportedKindsArray []XListenerSetStatusListenersSupportedKindsInput

func (XListenerSetStatusListenersSupportedKindsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusListenersSupportedKinds)(nil)).Elem()
}

func (i XListenerSetStatusListenersSupportedKindsArray) ToXListenerSetStatusListenersSupportedKindsArrayOutput() XListenerSetStatusListenersSupportedKindsArrayOutput {
	return i.ToXListenerSetStatusListenersSupportedKindsArrayOutputWithContext(context.Background())
}

func (i XListenerSetStatusListenersSupportedKindsArray) ToXListenerSetStatusListenersSupportedKindsArrayOutputWithContext(ctx context.Context) XListenerSetStatusListenersSupportedKindsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusListenersSupportedKindsArrayOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type XListenerSetStatusListenersSupportedKindsOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusListenersSupportedKindsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusListenersSupportedKinds)(nil)).Elem()
}

func (o XListenerSetStatusListenersSupportedKindsOutput) ToXListenerSetStatusListenersSupportedKindsOutput() XListenerSetStatusListenersSupportedKindsOutput {
	return o
}

func (o XListenerSetStatusListenersSupportedKindsOutput) ToXListenerSetStatusListenersSupportedKindsOutputWithContext(ctx context.Context) XListenerSetStatusListenersSupportedKindsOutput {
	return o
}

// Group is the group of the Route.
func (o XListenerSetStatusListenersSupportedKindsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersSupportedKinds) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the Route.
func (o XListenerSetStatusListenersSupportedKindsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersSupportedKinds) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

type XListenerSetStatusListenersSupportedKindsArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusListenersSupportedKindsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusListenersSupportedKinds)(nil)).Elem()
}

func (o XListenerSetStatusListenersSupportedKindsArrayOutput) ToXListenerSetStatusListenersSupportedKindsArrayOutput() XListenerSetStatusListenersSupportedKindsArrayOutput {
	return o
}

func (o XListenerSetStatusListenersSupportedKindsArrayOutput) ToXListenerSetStatusListenersSupportedKindsArrayOutputWithContext(ctx context.Context) XListenerSetStatusListenersSupportedKindsArrayOutput {
	return o
}

func (o XListenerSetStatusListenersSupportedKindsArrayOutput) Index(i pulumi.IntInput) XListenerSetStatusListenersSupportedKindsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetStatusListenersSupportedKinds {
		return vs[0].([]XListenerSetStatusListenersSupportedKinds)[vs[1].(int)]
	}).(XListenerSetStatusListenersSupportedKindsOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type XListenerSetStatusListenersSupportedKindsPatch struct {
	// Group is the group of the Route.
	Group *string `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind *string `pulumi:"kind"`
}

// XListenerSetStatusListenersSupportedKindsPatchInput is an input type that accepts XListenerSetStatusListenersSupportedKindsPatchArgs and XListenerSetStatusListenersSupportedKindsPatchOutput values.
// You can construct a concrete instance of `XListenerSetStatusListenersSupportedKindsPatchInput` via:
//
//	XListenerSetStatusListenersSupportedKindsPatchArgs{...}
type XListenerSetStatusListenersSupportedKindsPatchInput interface {
	pulumi.Input

	ToXListenerSetStatusListenersSupportedKindsPatchOutput() XListenerSetStatusListenersSupportedKindsPatchOutput
	ToXListenerSetStatusListenersSupportedKindsPatchOutputWithContext(context.Context) XListenerSetStatusListenersSupportedKindsPatchOutput
}

// RouteGroupKind indicates the group and kind of a Route resource.
type XListenerSetStatusListenersSupportedKindsPatchArgs struct {
	// Group is the group of the Route.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the kind of the Route.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
}

func (XListenerSetStatusListenersSupportedKindsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusListenersSupportedKindsPatch)(nil)).Elem()
}

func (i XListenerSetStatusListenersSupportedKindsPatchArgs) ToXListenerSetStatusListenersSupportedKindsPatchOutput() XListenerSetStatusListenersSupportedKindsPatchOutput {
	return i.ToXListenerSetStatusListenersSupportedKindsPatchOutputWithContext(context.Background())
}

func (i XListenerSetStatusListenersSupportedKindsPatchArgs) ToXListenerSetStatusListenersSupportedKindsPatchOutputWithContext(ctx context.Context) XListenerSetStatusListenersSupportedKindsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusListenersSupportedKindsPatchOutput)
}

// XListenerSetStatusListenersSupportedKindsPatchArrayInput is an input type that accepts XListenerSetStatusListenersSupportedKindsPatchArray and XListenerSetStatusListenersSupportedKindsPatchArrayOutput values.
// You can construct a concrete instance of `XListenerSetStatusListenersSupportedKindsPatchArrayInput` via:
//
//	XListenerSetStatusListenersSupportedKindsPatchArray{ XListenerSetStatusListenersSupportedKindsPatchArgs{...} }
type XListenerSetStatusListenersSupportedKindsPatchArrayInput interface {
	pulumi.Input

	ToXListenerSetStatusListenersSupportedKindsPatchArrayOutput() XListenerSetStatusListenersSupportedKindsPatchArrayOutput
	ToXListenerSetStatusListenersSupportedKindsPatchArrayOutputWithContext(context.Context) XListenerSetStatusListenersSupportedKindsPatchArrayOutput
}

type XListenerSetStatusListenersSupportedKindsPatchArray []XListenerSetStatusListenersSupportedKindsPatchInput

func (XListenerSetStatusListenersSupportedKindsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusListenersSupportedKindsPatch)(nil)).Elem()
}

func (i XListenerSetStatusListenersSupportedKindsPatchArray) ToXListenerSetStatusListenersSupportedKindsPatchArrayOutput() XListenerSetStatusListenersSupportedKindsPatchArrayOutput {
	return i.ToXListenerSetStatusListenersSupportedKindsPatchArrayOutputWithContext(context.Background())
}

func (i XListenerSetStatusListenersSupportedKindsPatchArray) ToXListenerSetStatusListenersSupportedKindsPatchArrayOutputWithContext(ctx context.Context) XListenerSetStatusListenersSupportedKindsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusListenersSupportedKindsPatchArrayOutput)
}

// RouteGroupKind indicates the group and kind of a Route resource.
type XListenerSetStatusListenersSupportedKindsPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusListenersSupportedKindsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusListenersSupportedKindsPatch)(nil)).Elem()
}

func (o XListenerSetStatusListenersSupportedKindsPatchOutput) ToXListenerSetStatusListenersSupportedKindsPatchOutput() XListenerSetStatusListenersSupportedKindsPatchOutput {
	return o
}

func (o XListenerSetStatusListenersSupportedKindsPatchOutput) ToXListenerSetStatusListenersSupportedKindsPatchOutputWithContext(ctx context.Context) XListenerSetStatusListenersSupportedKindsPatchOutput {
	return o
}

// Group is the group of the Route.
func (o XListenerSetStatusListenersSupportedKindsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersSupportedKindsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the kind of the Route.
func (o XListenerSetStatusListenersSupportedKindsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v XListenerSetStatusListenersSupportedKindsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

type XListenerSetStatusListenersSupportedKindsPatchArrayOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusListenersSupportedKindsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]XListenerSetStatusListenersSupportedKindsPatch)(nil)).Elem()
}

func (o XListenerSetStatusListenersSupportedKindsPatchArrayOutput) ToXListenerSetStatusListenersSupportedKindsPatchArrayOutput() XListenerSetStatusListenersSupportedKindsPatchArrayOutput {
	return o
}

func (o XListenerSetStatusListenersSupportedKindsPatchArrayOutput) ToXListenerSetStatusListenersSupportedKindsPatchArrayOutputWithContext(ctx context.Context) XListenerSetStatusListenersSupportedKindsPatchArrayOutput {
	return o
}

func (o XListenerSetStatusListenersSupportedKindsPatchArrayOutput) Index(i pulumi.IntInput) XListenerSetStatusListenersSupportedKindsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) XListenerSetStatusListenersSupportedKindsPatch {
		return vs[0].([]XListenerSetStatusListenersSupportedKindsPatch)[vs[1].(int)]
	}).(XListenerSetStatusListenersSupportedKindsPatchOutput)
}

// Status defines the current state of ListenerSet.
type XListenerSetStatusPatch struct {
	// Conditions describe the current conditions of the ListenerSet.
	//
	// Implementations MUST express ListenerSet conditions using the
	// `ListenerSetConditionType` and `ListenerSetConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe ListenerSet state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	Conditions []XListenerSetStatusConditionsPatch `pulumi:"conditions"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners []XListenerSetStatusListenersPatch `pulumi:"listeners"`
}

// XListenerSetStatusPatchInput is an input type that accepts XListenerSetStatusPatchArgs and XListenerSetStatusPatchOutput values.
// You can construct a concrete instance of `XListenerSetStatusPatchInput` via:
//
//	XListenerSetStatusPatchArgs{...}
type XListenerSetStatusPatchInput interface {
	pulumi.Input

	ToXListenerSetStatusPatchOutput() XListenerSetStatusPatchOutput
	ToXListenerSetStatusPatchOutputWithContext(context.Context) XListenerSetStatusPatchOutput
}

// Status defines the current state of ListenerSet.
type XListenerSetStatusPatchArgs struct {
	// Conditions describe the current conditions of the ListenerSet.
	//
	// Implementations MUST express ListenerSet conditions using the
	// `ListenerSetConditionType` and `ListenerSetConditionReason`
	// constants so that operators and tools can converge on a common
	// vocabulary to describe ListenerSet state.
	//
	// Known condition types are:
	//
	// * "Accepted"
	// * "Programmed"
	Conditions XListenerSetStatusConditionsPatchArrayInput `pulumi:"conditions"`
	// Listeners provide status for each unique listener port defined in the Spec.
	Listeners XListenerSetStatusListenersPatchArrayInput `pulumi:"listeners"`
}

func (XListenerSetStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusPatch)(nil)).Elem()
}

func (i XListenerSetStatusPatchArgs) ToXListenerSetStatusPatchOutput() XListenerSetStatusPatchOutput {
	return i.ToXListenerSetStatusPatchOutputWithContext(context.Background())
}

func (i XListenerSetStatusPatchArgs) ToXListenerSetStatusPatchOutputWithContext(ctx context.Context) XListenerSetStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusPatchOutput)
}

func (i XListenerSetStatusPatchArgs) ToXListenerSetStatusPatchPtrOutput() XListenerSetStatusPatchPtrOutput {
	return i.ToXListenerSetStatusPatchPtrOutputWithContext(context.Background())
}

func (i XListenerSetStatusPatchArgs) ToXListenerSetStatusPatchPtrOutputWithContext(ctx context.Context) XListenerSetStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusPatchOutput).ToXListenerSetStatusPatchPtrOutputWithContext(ctx)
}

// XListenerSetStatusPatchPtrInput is an input type that accepts XListenerSetStatusPatchArgs, XListenerSetStatusPatchPtr and XListenerSetStatusPatchPtrOutput values.
// You can construct a concrete instance of `XListenerSetStatusPatchPtrInput` via:
//
//	        XListenerSetStatusPatchArgs{...}
//
//	or:
//
//	        nil
type XListenerSetStatusPatchPtrInput interface {
	pulumi.Input

	ToXListenerSetStatusPatchPtrOutput() XListenerSetStatusPatchPtrOutput
	ToXListenerSetStatusPatchPtrOutputWithContext(context.Context) XListenerSetStatusPatchPtrOutput
}

type xlistenerSetStatusPatchPtrType XListenerSetStatusPatchArgs

func XListenerSetStatusPatchPtr(v *XListenerSetStatusPatchArgs) XListenerSetStatusPatchPtrInput {
	return (*xlistenerSetStatusPatchPtrType)(v)
}

func (*xlistenerSetStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetStatusPatch)(nil)).Elem()
}

func (i *xlistenerSetStatusPatchPtrType) ToXListenerSetStatusPatchPtrOutput() XListenerSetStatusPatchPtrOutput {
	return i.ToXListenerSetStatusPatchPtrOutputWithContext(context.Background())
}

func (i *xlistenerSetStatusPatchPtrType) ToXListenerSetStatusPatchPtrOutputWithContext(ctx context.Context) XListenerSetStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(XListenerSetStatusPatchPtrOutput)
}

// Status defines the current state of ListenerSet.
type XListenerSetStatusPatchOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*XListenerSetStatusPatch)(nil)).Elem()
}

func (o XListenerSetStatusPatchOutput) ToXListenerSetStatusPatchOutput() XListenerSetStatusPatchOutput {
	return o
}

func (o XListenerSetStatusPatchOutput) ToXListenerSetStatusPatchOutputWithContext(ctx context.Context) XListenerSetStatusPatchOutput {
	return o
}

func (o XListenerSetStatusPatchOutput) ToXListenerSetStatusPatchPtrOutput() XListenerSetStatusPatchPtrOutput {
	return o.ToXListenerSetStatusPatchPtrOutputWithContext(context.Background())
}

func (o XListenerSetStatusPatchOutput) ToXListenerSetStatusPatchPtrOutputWithContext(ctx context.Context) XListenerSetStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v XListenerSetStatusPatch) *XListenerSetStatusPatch {
		return &v
	}).(XListenerSetStatusPatchPtrOutput)
}

// Conditions describe the current conditions of the ListenerSet.
//
// Implementations MUST express ListenerSet conditions using the
// `ListenerSetConditionType` and `ListenerSetConditionReason`
// constants so that operators and tools can converge on a common
// vocabulary to describe ListenerSet state.
//
// Known condition types are:
//
// * "Accepted"
// * "Programmed"
func (o XListenerSetStatusPatchOutput) Conditions() XListenerSetStatusConditionsPatchArrayOutput {
	return o.ApplyT(func(v XListenerSetStatusPatch) []XListenerSetStatusConditionsPatch { return v.Conditions }).(XListenerSetStatusConditionsPatchArrayOutput)
}

// Listeners provide status for each unique listener port defined in the Spec.
func (o XListenerSetStatusPatchOutput) Listeners() XListenerSetStatusListenersPatchArrayOutput {
	return o.ApplyT(func(v XListenerSetStatusPatch) []XListenerSetStatusListenersPatch { return v.Listeners }).(XListenerSetStatusListenersPatchArrayOutput)
}

type XListenerSetStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (XListenerSetStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**XListenerSetStatusPatch)(nil)).Elem()
}

func (o XListenerSetStatusPatchPtrOutput) ToXListenerSetStatusPatchPtrOutput() XListenerSetStatusPatchPtrOutput {
	return o
}

func (o XListenerSetStatusPatchPtrOutput) ToXListenerSetStatusPatchPtrOutputWithContext(ctx context.Context) XListenerSetStatusPatchPtrOutput {
	return o
}

func (o XListenerSetStatusPatchPtrOutput) Elem() XListenerSetStatusPatchOutput {
	return o.ApplyT(func(v *XListenerSetStatusPatch) XListenerSetStatusPatch {
		if v != nil {
			return *v
		}
		var ret XListenerSetStatusPatch
		return ret
	}).(XListenerSetStatusPatchOutput)
}

// Conditions describe the current conditions of the ListenerSet.
//
// Implementations MUST express ListenerSet conditions using the
// `ListenerSetConditionType` and `ListenerSetConditionReason`
// constants so that operators and tools can converge on a common
// vocabulary to describe ListenerSet state.
//
// Known condition types are:
//
// * "Accepted"
// * "Programmed"
func (o XListenerSetStatusPatchPtrOutput) Conditions() XListenerSetStatusConditionsPatchArrayOutput {
	return o.ApplyT(func(v *XListenerSetStatusPatch) []XListenerSetStatusConditionsPatch {
		if v == nil {
			return nil
		}
		return v.Conditions
	}).(XListenerSetStatusConditionsPatchArrayOutput)
}

// Listeners provide status for each unique listener port defined in the Spec.
func (o XListenerSetStatusPatchPtrOutput) Listeners() XListenerSetStatusListenersPatchArrayOutput {
	return o.ApplyT(func(v *XListenerSetStatusPatch) []XListenerSetStatusListenersPatch {
		if v == nil {
			return nil
		}
		return v.Listeners
	}).(XListenerSetStatusListenersPatchArrayOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyTypeInput)(nil)).Elem(), XBackendTrafficPolicyTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyTypeArrayInput)(nil)).Elem(), XBackendTrafficPolicyTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyListTypeInput)(nil)).Elem(), XBackendTrafficPolicyListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyPatchTypeInput)(nil)).Elem(), XBackendTrafficPolicyPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecInput)(nil)).Elem(), XBackendTrafficPolicySpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecPtrInput)(nil)).Elem(), XBackendTrafficPolicySpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecPatchInput)(nil)).Elem(), XBackendTrafficPolicySpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecPatchPtrInput)(nil)).Elem(), XBackendTrafficPolicySpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintInput)(nil)).Elem(), XBackendTrafficPolicySpecRetryConstraintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintPtrInput)(nil)).Elem(), XBackendTrafficPolicySpecRetryConstraintArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintBudgetInput)(nil)).Elem(), XBackendTrafficPolicySpecRetryConstraintBudgetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintBudgetPtrInput)(nil)).Elem(), XBackendTrafficPolicySpecRetryConstraintBudgetArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintBudgetPatchInput)(nil)).Elem(), XBackendTrafficPolicySpecRetryConstraintBudgetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrInput)(nil)).Elem(), XBackendTrafficPolicySpecRetryConstraintBudgetPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintMinRetryRateInput)(nil)).Elem(), XBackendTrafficPolicySpecRetryConstraintMinRetryRateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrInput)(nil)).Elem(), XBackendTrafficPolicySpecRetryConstraintMinRetryRateArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchInput)(nil)).Elem(), XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrInput)(nil)).Elem(), XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintPatchInput)(nil)).Elem(), XBackendTrafficPolicySpecRetryConstraintPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecRetryConstraintPatchPtrInput)(nil)).Elem(), XBackendTrafficPolicySpecRetryConstraintPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistenceInput)(nil)).Elem(), XBackendTrafficPolicySpecSessionPersistenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistencePtrInput)(nil)).Elem(), XBackendTrafficPolicySpecSessionPersistenceArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistenceCookieConfigInput)(nil)).Elem(), XBackendTrafficPolicySpecSessionPersistenceCookieConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrInput)(nil)).Elem(), XBackendTrafficPolicySpecSessionPersistenceCookieConfigArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchInput)(nil)).Elem(), XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrInput)(nil)).Elem(), XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistencePatchInput)(nil)).Elem(), XBackendTrafficPolicySpecSessionPersistencePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecSessionPersistencePatchPtrInput)(nil)).Elem(), XBackendTrafficPolicySpecSessionPersistencePatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecTargetRefsInput)(nil)).Elem(), XBackendTrafficPolicySpecTargetRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecTargetRefsArrayInput)(nil)).Elem(), XBackendTrafficPolicySpecTargetRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecTargetRefsPatchInput)(nil)).Elem(), XBackendTrafficPolicySpecTargetRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicySpecTargetRefsPatchArrayInput)(nil)).Elem(), XBackendTrafficPolicySpecTargetRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusInput)(nil)).Elem(), XBackendTrafficPolicyStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusPtrInput)(nil)).Elem(), XBackendTrafficPolicyStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsInput)(nil)).Elem(), XBackendTrafficPolicyStatusAncestorsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsArrayInput)(nil)).Elem(), XBackendTrafficPolicyStatusAncestorsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsAncestorRefInput)(nil)).Elem(), XBackendTrafficPolicyStatusAncestorsAncestorRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsAncestorRefPtrInput)(nil)).Elem(), XBackendTrafficPolicyStatusAncestorsAncestorRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsAncestorRefPatchInput)(nil)).Elem(), XBackendTrafficPolicyStatusAncestorsAncestorRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrInput)(nil)).Elem(), XBackendTrafficPolicyStatusAncestorsAncestorRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsConditionsInput)(nil)).Elem(), XBackendTrafficPolicyStatusAncestorsConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsConditionsArrayInput)(nil)).Elem(), XBackendTrafficPolicyStatusAncestorsConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsConditionsPatchInput)(nil)).Elem(), XBackendTrafficPolicyStatusAncestorsConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayInput)(nil)).Elem(), XBackendTrafficPolicyStatusAncestorsConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsPatchInput)(nil)).Elem(), XBackendTrafficPolicyStatusAncestorsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusAncestorsPatchArrayInput)(nil)).Elem(), XBackendTrafficPolicyStatusAncestorsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusPatchInput)(nil)).Elem(), XBackendTrafficPolicyStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XBackendTrafficPolicyStatusPatchPtrInput)(nil)).Elem(), XBackendTrafficPolicyStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetTypeInput)(nil)).Elem(), XListenerSetTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetTypeArrayInput)(nil)).Elem(), XListenerSetTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetListTypeInput)(nil)).Elem(), XListenerSetListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetPatchTypeInput)(nil)).Elem(), XListenerSetPatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecInput)(nil)).Elem(), XListenerSetSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecPtrInput)(nil)).Elem(), XListenerSetSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersInput)(nil)).Elem(), XListenerSetSpecListenersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersArrayInput)(nil)).Elem(), XListenerSetSpecListenersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesPtrInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesKindsInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesKindsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesKindsArrayInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesKindsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesKindsPatchInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesKindsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesKindsPatchArrayInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesKindsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesNamespacesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesPtrInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesNamespacesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesPatchInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesNamespacesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesNamespacesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelectorInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesNamespacesSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesNamespacesSelectorArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesPatchInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersAllowedRoutesPatchPtrInput)(nil)).Elem(), XListenerSetSpecListenersAllowedRoutesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersPatchInput)(nil)).Elem(), XListenerSetSpecListenersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersPatchArrayInput)(nil)).Elem(), XListenerSetSpecListenersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsInput)(nil)).Elem(), XListenerSetSpecListenersTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsPtrInput)(nil)).Elem(), XListenerSetSpecListenersTlsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsCertificateRefsInput)(nil)).Elem(), XListenerSetSpecListenersTlsCertificateRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsCertificateRefsArrayInput)(nil)).Elem(), XListenerSetSpecListenersTlsCertificateRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsCertificateRefsPatchInput)(nil)).Elem(), XListenerSetSpecListenersTlsCertificateRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsCertificateRefsPatchArrayInput)(nil)).Elem(), XListenerSetSpecListenersTlsCertificateRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidationInput)(nil)).Elem(), XListenerSetSpecListenersTlsFrontendValidationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidationPtrInput)(nil)).Elem(), XListenerSetSpecListenersTlsFrontendValidationArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsInput)(nil)).Elem(), XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayInput)(nil)).Elem(), XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchInput)(nil)).Elem(), XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayInput)(nil)).Elem(), XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidationPatchInput)(nil)).Elem(), XListenerSetSpecListenersTlsFrontendValidationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsFrontendValidationPatchPtrInput)(nil)).Elem(), XListenerSetSpecListenersTlsFrontendValidationPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsPatchInput)(nil)).Elem(), XListenerSetSpecListenersTlsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecListenersTlsPatchPtrInput)(nil)).Elem(), XListenerSetSpecListenersTlsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecParentRefInput)(nil)).Elem(), XListenerSetSpecParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecParentRefPtrInput)(nil)).Elem(), XListenerSetSpecParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecParentRefPatchInput)(nil)).Elem(), XListenerSetSpecParentRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecParentRefPatchPtrInput)(nil)).Elem(), XListenerSetSpecParentRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecPatchInput)(nil)).Elem(), XListenerSetSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetSpecPatchPtrInput)(nil)).Elem(), XListenerSetSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusInput)(nil)).Elem(), XListenerSetStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusPtrInput)(nil)).Elem(), XListenerSetStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusConditionsInput)(nil)).Elem(), XListenerSetStatusConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusConditionsArrayInput)(nil)).Elem(), XListenerSetStatusConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusConditionsPatchInput)(nil)).Elem(), XListenerSetStatusConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusConditionsPatchArrayInput)(nil)).Elem(), XListenerSetStatusConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusListenersInput)(nil)).Elem(), XListenerSetStatusListenersArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusListenersArrayInput)(nil)).Elem(), XListenerSetStatusListenersArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusListenersConditionsInput)(nil)).Elem(), XListenerSetStatusListenersConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusListenersConditionsArrayInput)(nil)).Elem(), XListenerSetStatusListenersConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusListenersConditionsPatchInput)(nil)).Elem(), XListenerSetStatusListenersConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusListenersConditionsPatchArrayInput)(nil)).Elem(), XListenerSetStatusListenersConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusListenersPatchInput)(nil)).Elem(), XListenerSetStatusListenersPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusListenersPatchArrayInput)(nil)).Elem(), XListenerSetStatusListenersPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusListenersSupportedKindsInput)(nil)).Elem(), XListenerSetStatusListenersSupportedKindsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusListenersSupportedKindsArrayInput)(nil)).Elem(), XListenerSetStatusListenersSupportedKindsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusListenersSupportedKindsPatchInput)(nil)).Elem(), XListenerSetStatusListenersSupportedKindsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusListenersSupportedKindsPatchArrayInput)(nil)).Elem(), XListenerSetStatusListenersSupportedKindsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusPatchInput)(nil)).Elem(), XListenerSetStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*XListenerSetStatusPatchPtrInput)(nil)).Elem(), XListenerSetStatusPatchArgs{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyTypeOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyTypeArrayOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyListTypeOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyPatchTypeOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecPtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecPatchOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecPatchPtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecRetryConstraintOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecRetryConstraintPtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecRetryConstraintBudgetOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecRetryConstraintBudgetPtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecRetryConstraintBudgetPatchOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecRetryConstraintBudgetPatchPtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecRetryConstraintMinRetryRateOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecRetryConstraintMinRetryRatePtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecRetryConstraintMinRetryRatePatchPtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecRetryConstraintPatchOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecRetryConstraintPatchPtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecSessionPersistenceOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecSessionPersistencePtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecSessionPersistenceCookieConfigOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecSessionPersistenceCookieConfigPtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecSessionPersistenceCookieConfigPatchPtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecSessionPersistencePatchOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecSessionPersistencePatchPtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecTargetRefsOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecTargetRefsArrayOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecTargetRefsPatchOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicySpecTargetRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusPtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusAncestorsOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusAncestorsArrayOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusAncestorsAncestorRefOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusAncestorsAncestorRefPtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusAncestorsAncestorRefPatchOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusAncestorsAncestorRefPatchPtrOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusAncestorsConditionsOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusAncestorsConditionsArrayOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusAncestorsConditionsPatchOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusAncestorsConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusAncestorsPatchOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusAncestorsPatchArrayOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusPatchOutput{})
	pulumi.RegisterOutputType(XBackendTrafficPolicyStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetTypeOutput{})
	pulumi.RegisterOutputType(XListenerSetTypeArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetListTypeOutput{})
	pulumi.RegisterOutputType(XListenerSetPatchTypeOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesKindsOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesKindsArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesKindsPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesKindsPatchArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesNamespacesOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesNamespacesPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesNamespacesPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesNamespacesPatchPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorMatchExpressionsPatchArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesNamespacesSelectorPatchPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersAllowedRoutesPatchPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersPatchArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsCertificateRefsOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsCertificateRefsArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsCertificateRefsPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsCertificateRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsFrontendValidationOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsFrontendValidationPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsFrontendValidationCaCertificateRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsFrontendValidationPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsFrontendValidationPatchPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecListenersTlsPatchPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecParentRefOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecParentRefPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecParentRefPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecParentRefPatchPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusPtrOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusConditionsOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusConditionsArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusConditionsPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusListenersOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusListenersArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusListenersConditionsOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusListenersConditionsArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusListenersConditionsPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusListenersConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusListenersPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusListenersPatchArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusListenersSupportedKindsOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusListenersSupportedKindsArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusListenersSupportedKindsPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusListenersSupportedKindsPatchArrayOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusPatchOutput{})
	pulumi.RegisterOutputType(XListenerSetStatusPatchPtrOutput{})
}
