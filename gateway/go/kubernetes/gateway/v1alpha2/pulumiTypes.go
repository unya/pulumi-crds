// Code generated by crd2pulumi DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package v1alpha2

import (
	"context"
	"reflect"

	metav1 "github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/meta/v1"
	"github.com/pulumi/pulumi-kubernetes/sdk/v4/go/kubernetes/utilities"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

var _ = utilities.GetEnvOrDefault

// TCPRoute provides a way to route TCP requests. When combined with a Gateway
// listener, it can be used to forward connections on the port specified by the
// listener to a set of backends specified by the TCPRoute.
type TCPRouteType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	Spec     *TCPRouteSpec      `pulumi:"spec"`
	Status   *TCPRouteStatus    `pulumi:"status"`
}

// TCPRouteTypeInput is an input type that accepts TCPRouteTypeArgs and TCPRouteTypeOutput values.
// You can construct a concrete instance of `TCPRouteTypeInput` via:
//
//	TCPRouteTypeArgs{...}
type TCPRouteTypeInput interface {
	pulumi.Input

	ToTCPRouteTypeOutput() TCPRouteTypeOutput
	ToTCPRouteTypeOutputWithContext(context.Context) TCPRouteTypeOutput
}

// TCPRoute provides a way to route TCP requests. When combined with a Gateway
// listener, it can be used to forward connections on the port specified by the
// listener to a set of backends specified by the TCPRoute.
type TCPRouteTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	Spec     TCPRouteSpecPtrInput      `pulumi:"spec"`
	Status   TCPRouteStatusPtrInput    `pulumi:"status"`
}

func (TCPRouteTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteType)(nil)).Elem()
}

func (i TCPRouteTypeArgs) ToTCPRouteTypeOutput() TCPRouteTypeOutput {
	return i.ToTCPRouteTypeOutputWithContext(context.Background())
}

func (i TCPRouteTypeArgs) ToTCPRouteTypeOutputWithContext(ctx context.Context) TCPRouteTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteTypeOutput)
}

// TCPRouteTypeArrayInput is an input type that accepts TCPRouteTypeArray and TCPRouteTypeArrayOutput values.
// You can construct a concrete instance of `TCPRouteTypeArrayInput` via:
//
//	TCPRouteTypeArray{ TCPRouteTypeArgs{...} }
type TCPRouteTypeArrayInput interface {
	pulumi.Input

	ToTCPRouteTypeArrayOutput() TCPRouteTypeArrayOutput
	ToTCPRouteTypeArrayOutputWithContext(context.Context) TCPRouteTypeArrayOutput
}

type TCPRouteTypeArray []TCPRouteTypeInput

func (TCPRouteTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteType)(nil)).Elem()
}

func (i TCPRouteTypeArray) ToTCPRouteTypeArrayOutput() TCPRouteTypeArrayOutput {
	return i.ToTCPRouteTypeArrayOutputWithContext(context.Background())
}

func (i TCPRouteTypeArray) ToTCPRouteTypeArrayOutputWithContext(ctx context.Context) TCPRouteTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteTypeArrayOutput)
}

// TCPRoute provides a way to route TCP requests. When combined with a Gateway
// listener, it can be used to forward connections on the port specified by the
// listener to a set of backends specified by the TCPRoute.
type TCPRouteTypeOutput struct{ *pulumi.OutputState }

func (TCPRouteTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteType)(nil)).Elem()
}

func (o TCPRouteTypeOutput) ToTCPRouteTypeOutput() TCPRouteTypeOutput {
	return o
}

func (o TCPRouteTypeOutput) ToTCPRouteTypeOutputWithContext(ctx context.Context) TCPRouteTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o TCPRouteTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o TCPRouteTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o TCPRouteTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v TCPRouteType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o TCPRouteTypeOutput) Spec() TCPRouteSpecPtrOutput {
	return o.ApplyT(func(v TCPRouteType) *TCPRouteSpec { return v.Spec }).(TCPRouteSpecPtrOutput)
}

func (o TCPRouteTypeOutput) Status() TCPRouteStatusPtrOutput {
	return o.ApplyT(func(v TCPRouteType) *TCPRouteStatus { return v.Status }).(TCPRouteStatusPtrOutput)
}

type TCPRouteTypeArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteType)(nil)).Elem()
}

func (o TCPRouteTypeArrayOutput) ToTCPRouteTypeArrayOutput() TCPRouteTypeArrayOutput {
	return o
}

func (o TCPRouteTypeArrayOutput) ToTCPRouteTypeArrayOutputWithContext(ctx context.Context) TCPRouteTypeArrayOutput {
	return o
}

func (o TCPRouteTypeArrayOutput) Index(i pulumi.IntInput) TCPRouteTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteType {
		return vs[0].([]TCPRouteType)[vs[1].(int)]
	}).(TCPRouteTypeOutput)
}

// TCPRouteList is a list of TCPRoute
type TCPRouteListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of tcproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []TCPRouteType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// TCPRouteListTypeInput is an input type that accepts TCPRouteListTypeArgs and TCPRouteListTypeOutput values.
// You can construct a concrete instance of `TCPRouteListTypeInput` via:
//
//	TCPRouteListTypeArgs{...}
type TCPRouteListTypeInput interface {
	pulumi.Input

	ToTCPRouteListTypeOutput() TCPRouteListTypeOutput
	ToTCPRouteListTypeOutputWithContext(context.Context) TCPRouteListTypeOutput
}

// TCPRouteList is a list of TCPRoute
type TCPRouteListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of tcproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items TCPRouteTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (TCPRouteListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteListType)(nil)).Elem()
}

func (i TCPRouteListTypeArgs) ToTCPRouteListTypeOutput() TCPRouteListTypeOutput {
	return i.ToTCPRouteListTypeOutputWithContext(context.Background())
}

func (i TCPRouteListTypeArgs) ToTCPRouteListTypeOutputWithContext(ctx context.Context) TCPRouteListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteListTypeOutput)
}

// TCPRouteList is a list of TCPRoute
type TCPRouteListTypeOutput struct{ *pulumi.OutputState }

func (TCPRouteListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteListType)(nil)).Elem()
}

func (o TCPRouteListTypeOutput) ToTCPRouteListTypeOutput() TCPRouteListTypeOutput {
	return o
}

func (o TCPRouteListTypeOutput) ToTCPRouteListTypeOutputWithContext(ctx context.Context) TCPRouteListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o TCPRouteListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of tcproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o TCPRouteListTypeOutput) Items() TCPRouteTypeArrayOutput {
	return o.ApplyT(func(v TCPRouteListType) []TCPRouteType { return v.Items }).(TCPRouteTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o TCPRouteListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o TCPRouteListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v TCPRouteListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// TCPRoute provides a way to route TCP requests. When combined with a Gateway
// listener, it can be used to forward connections on the port specified by the
// listener to a set of backends specified by the TCPRoute.
type TCPRoutePatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	Spec     *TCPRouteSpecPatch      `pulumi:"spec"`
	Status   *TCPRouteStatusPatch    `pulumi:"status"`
}

// TCPRoutePatchTypeInput is an input type that accepts TCPRoutePatchTypeArgs and TCPRoutePatchTypeOutput values.
// You can construct a concrete instance of `TCPRoutePatchTypeInput` via:
//
//	TCPRoutePatchTypeArgs{...}
type TCPRoutePatchTypeInput interface {
	pulumi.Input

	ToTCPRoutePatchTypeOutput() TCPRoutePatchTypeOutput
	ToTCPRoutePatchTypeOutputWithContext(context.Context) TCPRoutePatchTypeOutput
}

// TCPRoute provides a way to route TCP requests. When combined with a Gateway
// listener, it can be used to forward connections on the port specified by the
// listener to a set of backends specified by the TCPRoute.
type TCPRoutePatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	Spec     TCPRouteSpecPatchPtrInput      `pulumi:"spec"`
	Status   TCPRouteStatusPatchPtrInput    `pulumi:"status"`
}

func (TCPRoutePatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRoutePatchType)(nil)).Elem()
}

func (i TCPRoutePatchTypeArgs) ToTCPRoutePatchTypeOutput() TCPRoutePatchTypeOutput {
	return i.ToTCPRoutePatchTypeOutputWithContext(context.Background())
}

func (i TCPRoutePatchTypeArgs) ToTCPRoutePatchTypeOutputWithContext(ctx context.Context) TCPRoutePatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRoutePatchTypeOutput)
}

// TCPRoute provides a way to route TCP requests. When combined with a Gateway
// listener, it can be used to forward connections on the port specified by the
// listener to a set of backends specified by the TCPRoute.
type TCPRoutePatchTypeOutput struct{ *pulumi.OutputState }

func (TCPRoutePatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRoutePatchType)(nil)).Elem()
}

func (o TCPRoutePatchTypeOutput) ToTCPRoutePatchTypeOutput() TCPRoutePatchTypeOutput {
	return o
}

func (o TCPRoutePatchTypeOutput) ToTCPRoutePatchTypeOutputWithContext(ctx context.Context) TCPRoutePatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o TCPRoutePatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRoutePatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o TCPRoutePatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRoutePatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o TCPRoutePatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v TCPRoutePatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o TCPRoutePatchTypeOutput) Spec() TCPRouteSpecPatchPtrOutput {
	return o.ApplyT(func(v TCPRoutePatchType) *TCPRouteSpecPatch { return v.Spec }).(TCPRouteSpecPatchPtrOutput)
}

func (o TCPRoutePatchTypeOutput) Status() TCPRouteStatusPatchPtrOutput {
	return o.ApplyT(func(v TCPRoutePatchType) *TCPRouteStatusPatch { return v.Status }).(TCPRouteStatusPatchPtrOutput)
}

// Spec defines the desired state of TCPRoute.
type TCPRouteSpec struct {
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	ParentRefs []TCPRouteSpecParentRefs `pulumi:"parentRefs"`
	// Rules are a list of TCP matchers and actions.
	Rules []TCPRouteSpecRules `pulumi:"rules"`
}

// TCPRouteSpecInput is an input type that accepts TCPRouteSpecArgs and TCPRouteSpecOutput values.
// You can construct a concrete instance of `TCPRouteSpecInput` via:
//
//	TCPRouteSpecArgs{...}
type TCPRouteSpecInput interface {
	pulumi.Input

	ToTCPRouteSpecOutput() TCPRouteSpecOutput
	ToTCPRouteSpecOutputWithContext(context.Context) TCPRouteSpecOutput
}

// Spec defines the desired state of TCPRoute.
type TCPRouteSpecArgs struct {
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	ParentRefs TCPRouteSpecParentRefsArrayInput `pulumi:"parentRefs"`
	// Rules are a list of TCP matchers and actions.
	Rules TCPRouteSpecRulesArrayInput `pulumi:"rules"`
}

func (TCPRouteSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpec)(nil)).Elem()
}

func (i TCPRouteSpecArgs) ToTCPRouteSpecOutput() TCPRouteSpecOutput {
	return i.ToTCPRouteSpecOutputWithContext(context.Background())
}

func (i TCPRouteSpecArgs) ToTCPRouteSpecOutputWithContext(ctx context.Context) TCPRouteSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecOutput)
}

func (i TCPRouteSpecArgs) ToTCPRouteSpecPtrOutput() TCPRouteSpecPtrOutput {
	return i.ToTCPRouteSpecPtrOutputWithContext(context.Background())
}

func (i TCPRouteSpecArgs) ToTCPRouteSpecPtrOutputWithContext(ctx context.Context) TCPRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecOutput).ToTCPRouteSpecPtrOutputWithContext(ctx)
}

// TCPRouteSpecPtrInput is an input type that accepts TCPRouteSpecArgs, TCPRouteSpecPtr and TCPRouteSpecPtrOutput values.
// You can construct a concrete instance of `TCPRouteSpecPtrInput` via:
//
//	        TCPRouteSpecArgs{...}
//
//	or:
//
//	        nil
type TCPRouteSpecPtrInput interface {
	pulumi.Input

	ToTCPRouteSpecPtrOutput() TCPRouteSpecPtrOutput
	ToTCPRouteSpecPtrOutputWithContext(context.Context) TCPRouteSpecPtrOutput
}

type tcprouteSpecPtrType TCPRouteSpecArgs

func TCPRouteSpecPtr(v *TCPRouteSpecArgs) TCPRouteSpecPtrInput {
	return (*tcprouteSpecPtrType)(v)
}

func (*tcprouteSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteSpec)(nil)).Elem()
}

func (i *tcprouteSpecPtrType) ToTCPRouteSpecPtrOutput() TCPRouteSpecPtrOutput {
	return i.ToTCPRouteSpecPtrOutputWithContext(context.Background())
}

func (i *tcprouteSpecPtrType) ToTCPRouteSpecPtrOutputWithContext(ctx context.Context) TCPRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecPtrOutput)
}

// Spec defines the desired state of TCPRoute.
type TCPRouteSpecOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpec)(nil)).Elem()
}

func (o TCPRouteSpecOutput) ToTCPRouteSpecOutput() TCPRouteSpecOutput {
	return o
}

func (o TCPRouteSpecOutput) ToTCPRouteSpecOutputWithContext(ctx context.Context) TCPRouteSpecOutput {
	return o
}

func (o TCPRouteSpecOutput) ToTCPRouteSpecPtrOutput() TCPRouteSpecPtrOutput {
	return o.ToTCPRouteSpecPtrOutputWithContext(context.Background())
}

func (o TCPRouteSpecOutput) ToTCPRouteSpecPtrOutputWithContext(ctx context.Context) TCPRouteSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TCPRouteSpec) *TCPRouteSpec {
		return &v
	}).(TCPRouteSpecPtrOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
func (o TCPRouteSpecOutput) ParentRefs() TCPRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v TCPRouteSpec) []TCPRouteSpecParentRefs { return v.ParentRefs }).(TCPRouteSpecParentRefsArrayOutput)
}

// Rules are a list of TCP matchers and actions.
func (o TCPRouteSpecOutput) Rules() TCPRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v TCPRouteSpec) []TCPRouteSpecRules { return v.Rules }).(TCPRouteSpecRulesArrayOutput)
}

type TCPRouteSpecPtrOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteSpec)(nil)).Elem()
}

func (o TCPRouteSpecPtrOutput) ToTCPRouteSpecPtrOutput() TCPRouteSpecPtrOutput {
	return o
}

func (o TCPRouteSpecPtrOutput) ToTCPRouteSpecPtrOutputWithContext(ctx context.Context) TCPRouteSpecPtrOutput {
	return o
}

func (o TCPRouteSpecPtrOutput) Elem() TCPRouteSpecOutput {
	return o.ApplyT(func(v *TCPRouteSpec) TCPRouteSpec {
		if v != nil {
			return *v
		}
		var ret TCPRouteSpec
		return ret
	}).(TCPRouteSpecOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
func (o TCPRouteSpecPtrOutput) ParentRefs() TCPRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v *TCPRouteSpec) []TCPRouteSpecParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(TCPRouteSpecParentRefsArrayOutput)
}

// Rules are a list of TCP matchers and actions.
func (o TCPRouteSpecPtrOutput) Rules() TCPRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v *TCPRouteSpec) []TCPRouteSpecRules {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(TCPRouteSpecRulesArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type TCPRouteSpecParentRefs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// TCPRouteSpecParentRefsInput is an input type that accepts TCPRouteSpecParentRefsArgs and TCPRouteSpecParentRefsOutput values.
// You can construct a concrete instance of `TCPRouteSpecParentRefsInput` via:
//
//	TCPRouteSpecParentRefsArgs{...}
type TCPRouteSpecParentRefsInput interface {
	pulumi.Input

	ToTCPRouteSpecParentRefsOutput() TCPRouteSpecParentRefsOutput
	ToTCPRouteSpecParentRefsOutputWithContext(context.Context) TCPRouteSpecParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type TCPRouteSpecParentRefsArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (TCPRouteSpecParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecParentRefs)(nil)).Elem()
}

func (i TCPRouteSpecParentRefsArgs) ToTCPRouteSpecParentRefsOutput() TCPRouteSpecParentRefsOutput {
	return i.ToTCPRouteSpecParentRefsOutputWithContext(context.Background())
}

func (i TCPRouteSpecParentRefsArgs) ToTCPRouteSpecParentRefsOutputWithContext(ctx context.Context) TCPRouteSpecParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecParentRefsOutput)
}

// TCPRouteSpecParentRefsArrayInput is an input type that accepts TCPRouteSpecParentRefsArray and TCPRouteSpecParentRefsArrayOutput values.
// You can construct a concrete instance of `TCPRouteSpecParentRefsArrayInput` via:
//
//	TCPRouteSpecParentRefsArray{ TCPRouteSpecParentRefsArgs{...} }
type TCPRouteSpecParentRefsArrayInput interface {
	pulumi.Input

	ToTCPRouteSpecParentRefsArrayOutput() TCPRouteSpecParentRefsArrayOutput
	ToTCPRouteSpecParentRefsArrayOutputWithContext(context.Context) TCPRouteSpecParentRefsArrayOutput
}

type TCPRouteSpecParentRefsArray []TCPRouteSpecParentRefsInput

func (TCPRouteSpecParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecParentRefs)(nil)).Elem()
}

func (i TCPRouteSpecParentRefsArray) ToTCPRouteSpecParentRefsArrayOutput() TCPRouteSpecParentRefsArrayOutput {
	return i.ToTCPRouteSpecParentRefsArrayOutputWithContext(context.Background())
}

func (i TCPRouteSpecParentRefsArray) ToTCPRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) TCPRouteSpecParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type TCPRouteSpecParentRefsOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecParentRefs)(nil)).Elem()
}

func (o TCPRouteSpecParentRefsOutput) ToTCPRouteSpecParentRefsOutput() TCPRouteSpecParentRefsOutput {
	return o
}

func (o TCPRouteSpecParentRefsOutput) ToTCPRouteSpecParentRefsOutputWithContext(ctx context.Context) TCPRouteSpecParentRefsOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o TCPRouteSpecParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o TCPRouteSpecParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o TCPRouteSpecParentRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o TCPRouteSpecParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o TCPRouteSpecParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o TCPRouteSpecParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type TCPRouteSpecParentRefsArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecParentRefs)(nil)).Elem()
}

func (o TCPRouteSpecParentRefsArrayOutput) ToTCPRouteSpecParentRefsArrayOutput() TCPRouteSpecParentRefsArrayOutput {
	return o
}

func (o TCPRouteSpecParentRefsArrayOutput) ToTCPRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) TCPRouteSpecParentRefsArrayOutput {
	return o
}

func (o TCPRouteSpecParentRefsArrayOutput) Index(i pulumi.IntInput) TCPRouteSpecParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteSpecParentRefs {
		return vs[0].([]TCPRouteSpecParentRefs)[vs[1].(int)]
	}).(TCPRouteSpecParentRefsOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type TCPRouteSpecParentRefsPatch struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// TCPRouteSpecParentRefsPatchInput is an input type that accepts TCPRouteSpecParentRefsPatchArgs and TCPRouteSpecParentRefsPatchOutput values.
// You can construct a concrete instance of `TCPRouteSpecParentRefsPatchInput` via:
//
//	TCPRouteSpecParentRefsPatchArgs{...}
type TCPRouteSpecParentRefsPatchInput interface {
	pulumi.Input

	ToTCPRouteSpecParentRefsPatchOutput() TCPRouteSpecParentRefsPatchOutput
	ToTCPRouteSpecParentRefsPatchOutputWithContext(context.Context) TCPRouteSpecParentRefsPatchOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type TCPRouteSpecParentRefsPatchArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (TCPRouteSpecParentRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (i TCPRouteSpecParentRefsPatchArgs) ToTCPRouteSpecParentRefsPatchOutput() TCPRouteSpecParentRefsPatchOutput {
	return i.ToTCPRouteSpecParentRefsPatchOutputWithContext(context.Background())
}

func (i TCPRouteSpecParentRefsPatchArgs) ToTCPRouteSpecParentRefsPatchOutputWithContext(ctx context.Context) TCPRouteSpecParentRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecParentRefsPatchOutput)
}

// TCPRouteSpecParentRefsPatchArrayInput is an input type that accepts TCPRouteSpecParentRefsPatchArray and TCPRouteSpecParentRefsPatchArrayOutput values.
// You can construct a concrete instance of `TCPRouteSpecParentRefsPatchArrayInput` via:
//
//	TCPRouteSpecParentRefsPatchArray{ TCPRouteSpecParentRefsPatchArgs{...} }
type TCPRouteSpecParentRefsPatchArrayInput interface {
	pulumi.Input

	ToTCPRouteSpecParentRefsPatchArrayOutput() TCPRouteSpecParentRefsPatchArrayOutput
	ToTCPRouteSpecParentRefsPatchArrayOutputWithContext(context.Context) TCPRouteSpecParentRefsPatchArrayOutput
}

type TCPRouteSpecParentRefsPatchArray []TCPRouteSpecParentRefsPatchInput

func (TCPRouteSpecParentRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (i TCPRouteSpecParentRefsPatchArray) ToTCPRouteSpecParentRefsPatchArrayOutput() TCPRouteSpecParentRefsPatchArrayOutput {
	return i.ToTCPRouteSpecParentRefsPatchArrayOutputWithContext(context.Background())
}

func (i TCPRouteSpecParentRefsPatchArray) ToTCPRouteSpecParentRefsPatchArrayOutputWithContext(ctx context.Context) TCPRouteSpecParentRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecParentRefsPatchArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type TCPRouteSpecParentRefsPatchOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecParentRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (o TCPRouteSpecParentRefsPatchOutput) ToTCPRouteSpecParentRefsPatchOutput() TCPRouteSpecParentRefsPatchOutput {
	return o
}

func (o TCPRouteSpecParentRefsPatchOutput) ToTCPRouteSpecParentRefsPatchOutputWithContext(ctx context.Context) TCPRouteSpecParentRefsPatchOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o TCPRouteSpecParentRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o TCPRouteSpecParentRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o TCPRouteSpecParentRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o TCPRouteSpecParentRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o TCPRouteSpecParentRefsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o TCPRouteSpecParentRefsPatchOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecParentRefsPatch) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type TCPRouteSpecParentRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecParentRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (o TCPRouteSpecParentRefsPatchArrayOutput) ToTCPRouteSpecParentRefsPatchArrayOutput() TCPRouteSpecParentRefsPatchArrayOutput {
	return o
}

func (o TCPRouteSpecParentRefsPatchArrayOutput) ToTCPRouteSpecParentRefsPatchArrayOutputWithContext(ctx context.Context) TCPRouteSpecParentRefsPatchArrayOutput {
	return o
}

func (o TCPRouteSpecParentRefsPatchArrayOutput) Index(i pulumi.IntInput) TCPRouteSpecParentRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteSpecParentRefsPatch {
		return vs[0].([]TCPRouteSpecParentRefsPatch)[vs[1].(int)]
	}).(TCPRouteSpecParentRefsPatchOutput)
}

// Spec defines the desired state of TCPRoute.
type TCPRouteSpecPatch struct {
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	ParentRefs []TCPRouteSpecParentRefsPatch `pulumi:"parentRefs"`
	// Rules are a list of TCP matchers and actions.
	Rules []TCPRouteSpecRulesPatch `pulumi:"rules"`
}

// TCPRouteSpecPatchInput is an input type that accepts TCPRouteSpecPatchArgs and TCPRouteSpecPatchOutput values.
// You can construct a concrete instance of `TCPRouteSpecPatchInput` via:
//
//	TCPRouteSpecPatchArgs{...}
type TCPRouteSpecPatchInput interface {
	pulumi.Input

	ToTCPRouteSpecPatchOutput() TCPRouteSpecPatchOutput
	ToTCPRouteSpecPatchOutputWithContext(context.Context) TCPRouteSpecPatchOutput
}

// Spec defines the desired state of TCPRoute.
type TCPRouteSpecPatchArgs struct {
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	ParentRefs TCPRouteSpecParentRefsPatchArrayInput `pulumi:"parentRefs"`
	// Rules are a list of TCP matchers and actions.
	Rules TCPRouteSpecRulesPatchArrayInput `pulumi:"rules"`
}

func (TCPRouteSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecPatch)(nil)).Elem()
}

func (i TCPRouteSpecPatchArgs) ToTCPRouteSpecPatchOutput() TCPRouteSpecPatchOutput {
	return i.ToTCPRouteSpecPatchOutputWithContext(context.Background())
}

func (i TCPRouteSpecPatchArgs) ToTCPRouteSpecPatchOutputWithContext(ctx context.Context) TCPRouteSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecPatchOutput)
}

func (i TCPRouteSpecPatchArgs) ToTCPRouteSpecPatchPtrOutput() TCPRouteSpecPatchPtrOutput {
	return i.ToTCPRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (i TCPRouteSpecPatchArgs) ToTCPRouteSpecPatchPtrOutputWithContext(ctx context.Context) TCPRouteSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecPatchOutput).ToTCPRouteSpecPatchPtrOutputWithContext(ctx)
}

// TCPRouteSpecPatchPtrInput is an input type that accepts TCPRouteSpecPatchArgs, TCPRouteSpecPatchPtr and TCPRouteSpecPatchPtrOutput values.
// You can construct a concrete instance of `TCPRouteSpecPatchPtrInput` via:
//
//	        TCPRouteSpecPatchArgs{...}
//
//	or:
//
//	        nil
type TCPRouteSpecPatchPtrInput interface {
	pulumi.Input

	ToTCPRouteSpecPatchPtrOutput() TCPRouteSpecPatchPtrOutput
	ToTCPRouteSpecPatchPtrOutputWithContext(context.Context) TCPRouteSpecPatchPtrOutput
}

type tcprouteSpecPatchPtrType TCPRouteSpecPatchArgs

func TCPRouteSpecPatchPtr(v *TCPRouteSpecPatchArgs) TCPRouteSpecPatchPtrInput {
	return (*tcprouteSpecPatchPtrType)(v)
}

func (*tcprouteSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteSpecPatch)(nil)).Elem()
}

func (i *tcprouteSpecPatchPtrType) ToTCPRouteSpecPatchPtrOutput() TCPRouteSpecPatchPtrOutput {
	return i.ToTCPRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (i *tcprouteSpecPatchPtrType) ToTCPRouteSpecPatchPtrOutputWithContext(ctx context.Context) TCPRouteSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecPatchPtrOutput)
}

// Spec defines the desired state of TCPRoute.
type TCPRouteSpecPatchOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecPatch)(nil)).Elem()
}

func (o TCPRouteSpecPatchOutput) ToTCPRouteSpecPatchOutput() TCPRouteSpecPatchOutput {
	return o
}

func (o TCPRouteSpecPatchOutput) ToTCPRouteSpecPatchOutputWithContext(ctx context.Context) TCPRouteSpecPatchOutput {
	return o
}

func (o TCPRouteSpecPatchOutput) ToTCPRouteSpecPatchPtrOutput() TCPRouteSpecPatchPtrOutput {
	return o.ToTCPRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (o TCPRouteSpecPatchOutput) ToTCPRouteSpecPatchPtrOutputWithContext(ctx context.Context) TCPRouteSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TCPRouteSpecPatch) *TCPRouteSpecPatch {
		return &v
	}).(TCPRouteSpecPatchPtrOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
func (o TCPRouteSpecPatchOutput) ParentRefs() TCPRouteSpecParentRefsPatchArrayOutput {
	return o.ApplyT(func(v TCPRouteSpecPatch) []TCPRouteSpecParentRefsPatch { return v.ParentRefs }).(TCPRouteSpecParentRefsPatchArrayOutput)
}

// Rules are a list of TCP matchers and actions.
func (o TCPRouteSpecPatchOutput) Rules() TCPRouteSpecRulesPatchArrayOutput {
	return o.ApplyT(func(v TCPRouteSpecPatch) []TCPRouteSpecRulesPatch { return v.Rules }).(TCPRouteSpecRulesPatchArrayOutput)
}

type TCPRouteSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteSpecPatch)(nil)).Elem()
}

func (o TCPRouteSpecPatchPtrOutput) ToTCPRouteSpecPatchPtrOutput() TCPRouteSpecPatchPtrOutput {
	return o
}

func (o TCPRouteSpecPatchPtrOutput) ToTCPRouteSpecPatchPtrOutputWithContext(ctx context.Context) TCPRouteSpecPatchPtrOutput {
	return o
}

func (o TCPRouteSpecPatchPtrOutput) Elem() TCPRouteSpecPatchOutput {
	return o.ApplyT(func(v *TCPRouteSpecPatch) TCPRouteSpecPatch {
		if v != nil {
			return *v
		}
		var ret TCPRouteSpecPatch
		return ret
	}).(TCPRouteSpecPatchOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
func (o TCPRouteSpecPatchPtrOutput) ParentRefs() TCPRouteSpecParentRefsPatchArrayOutput {
	return o.ApplyT(func(v *TCPRouteSpecPatch) []TCPRouteSpecParentRefsPatch {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(TCPRouteSpecParentRefsPatchArrayOutput)
}

// Rules are a list of TCP matchers and actions.
func (o TCPRouteSpecPatchPtrOutput) Rules() TCPRouteSpecRulesPatchArrayOutput {
	return o.ApplyT(func(v *TCPRouteSpecPatch) []TCPRouteSpecRulesPatch {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(TCPRouteSpecRulesPatchArrayOutput)
}

// TCPRouteRule is the configuration for a given rule.
type TCPRouteSpecRules struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent. If unspecified or invalid (refers to a nonexistent resource or a
	// Service with no endpoints), the underlying implementation MUST actively
	// reject connection attempts to this backend. Connection rejections must
	// respect weight; if an invalid backend is requested to have 80% of
	// connections, then 80% of connections must be rejected instead.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Extended
	BackendRefs []TCPRouteSpecRulesBackendRefs `pulumi:"backendRefs"`
	// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
	//
	// Support: Extended
	Name *string `pulumi:"name"`
}

// TCPRouteSpecRulesInput is an input type that accepts TCPRouteSpecRulesArgs and TCPRouteSpecRulesOutput values.
// You can construct a concrete instance of `TCPRouteSpecRulesInput` via:
//
//	TCPRouteSpecRulesArgs{...}
type TCPRouteSpecRulesInput interface {
	pulumi.Input

	ToTCPRouteSpecRulesOutput() TCPRouteSpecRulesOutput
	ToTCPRouteSpecRulesOutputWithContext(context.Context) TCPRouteSpecRulesOutput
}

// TCPRouteRule is the configuration for a given rule.
type TCPRouteSpecRulesArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent. If unspecified or invalid (refers to a nonexistent resource or a
	// Service with no endpoints), the underlying implementation MUST actively
	// reject connection attempts to this backend. Connection rejections must
	// respect weight; if an invalid backend is requested to have 80% of
	// connections, then 80% of connections must be rejected instead.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Extended
	BackendRefs TCPRouteSpecRulesBackendRefsArrayInput `pulumi:"backendRefs"`
	// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
	//
	// Support: Extended
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (TCPRouteSpecRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecRules)(nil)).Elem()
}

func (i TCPRouteSpecRulesArgs) ToTCPRouteSpecRulesOutput() TCPRouteSpecRulesOutput {
	return i.ToTCPRouteSpecRulesOutputWithContext(context.Background())
}

func (i TCPRouteSpecRulesArgs) ToTCPRouteSpecRulesOutputWithContext(ctx context.Context) TCPRouteSpecRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecRulesOutput)
}

// TCPRouteSpecRulesArrayInput is an input type that accepts TCPRouteSpecRulesArray and TCPRouteSpecRulesArrayOutput values.
// You can construct a concrete instance of `TCPRouteSpecRulesArrayInput` via:
//
//	TCPRouteSpecRulesArray{ TCPRouteSpecRulesArgs{...} }
type TCPRouteSpecRulesArrayInput interface {
	pulumi.Input

	ToTCPRouteSpecRulesArrayOutput() TCPRouteSpecRulesArrayOutput
	ToTCPRouteSpecRulesArrayOutputWithContext(context.Context) TCPRouteSpecRulesArrayOutput
}

type TCPRouteSpecRulesArray []TCPRouteSpecRulesInput

func (TCPRouteSpecRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecRules)(nil)).Elem()
}

func (i TCPRouteSpecRulesArray) ToTCPRouteSpecRulesArrayOutput() TCPRouteSpecRulesArrayOutput {
	return i.ToTCPRouteSpecRulesArrayOutputWithContext(context.Background())
}

func (i TCPRouteSpecRulesArray) ToTCPRouteSpecRulesArrayOutputWithContext(ctx context.Context) TCPRouteSpecRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecRulesArrayOutput)
}

// TCPRouteRule is the configuration for a given rule.
type TCPRouteSpecRulesOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecRules)(nil)).Elem()
}

func (o TCPRouteSpecRulesOutput) ToTCPRouteSpecRulesOutput() TCPRouteSpecRulesOutput {
	return o
}

func (o TCPRouteSpecRulesOutput) ToTCPRouteSpecRulesOutputWithContext(ctx context.Context) TCPRouteSpecRulesOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be
// sent. If unspecified or invalid (refers to a nonexistent resource or a
// Service with no endpoints), the underlying implementation MUST actively
// reject connection attempts to this backend. Connection rejections must
// respect weight; if an invalid backend is requested to have 80% of
// connections, then 80% of connections must be rejected instead.
//
// Support: Core for Kubernetes Service
//
// Support: Extended for Kubernetes ServiceImport
//
// Support: Implementation-specific for any other resource
//
// Support for weight: Extended
func (o TCPRouteSpecRulesOutput) BackendRefs() TCPRouteSpecRulesBackendRefsArrayOutput {
	return o.ApplyT(func(v TCPRouteSpecRules) []TCPRouteSpecRulesBackendRefs { return v.BackendRefs }).(TCPRouteSpecRulesBackendRefsArrayOutput)
}

// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
//
// Support: Extended
func (o TCPRouteSpecRulesOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRules) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type TCPRouteSpecRulesArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecRules)(nil)).Elem()
}

func (o TCPRouteSpecRulesArrayOutput) ToTCPRouteSpecRulesArrayOutput() TCPRouteSpecRulesArrayOutput {
	return o
}

func (o TCPRouteSpecRulesArrayOutput) ToTCPRouteSpecRulesArrayOutputWithContext(ctx context.Context) TCPRouteSpecRulesArrayOutput {
	return o
}

func (o TCPRouteSpecRulesArrayOutput) Index(i pulumi.IntInput) TCPRouteSpecRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteSpecRules {
		return vs[0].([]TCPRouteSpecRules)[vs[1].(int)]
	}).(TCPRouteSpecRulesOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type TCPRouteSpecRulesBackendRefs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// TCPRouteSpecRulesBackendRefsInput is an input type that accepts TCPRouteSpecRulesBackendRefsArgs and TCPRouteSpecRulesBackendRefsOutput values.
// You can construct a concrete instance of `TCPRouteSpecRulesBackendRefsInput` via:
//
//	TCPRouteSpecRulesBackendRefsArgs{...}
type TCPRouteSpecRulesBackendRefsInput interface {
	pulumi.Input

	ToTCPRouteSpecRulesBackendRefsOutput() TCPRouteSpecRulesBackendRefsOutput
	ToTCPRouteSpecRulesBackendRefsOutputWithContext(context.Context) TCPRouteSpecRulesBackendRefsOutput
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type TCPRouteSpecRulesBackendRefsArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (TCPRouteSpecRulesBackendRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i TCPRouteSpecRulesBackendRefsArgs) ToTCPRouteSpecRulesBackendRefsOutput() TCPRouteSpecRulesBackendRefsOutput {
	return i.ToTCPRouteSpecRulesBackendRefsOutputWithContext(context.Background())
}

func (i TCPRouteSpecRulesBackendRefsArgs) ToTCPRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) TCPRouteSpecRulesBackendRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecRulesBackendRefsOutput)
}

// TCPRouteSpecRulesBackendRefsArrayInput is an input type that accepts TCPRouteSpecRulesBackendRefsArray and TCPRouteSpecRulesBackendRefsArrayOutput values.
// You can construct a concrete instance of `TCPRouteSpecRulesBackendRefsArrayInput` via:
//
//	TCPRouteSpecRulesBackendRefsArray{ TCPRouteSpecRulesBackendRefsArgs{...} }
type TCPRouteSpecRulesBackendRefsArrayInput interface {
	pulumi.Input

	ToTCPRouteSpecRulesBackendRefsArrayOutput() TCPRouteSpecRulesBackendRefsArrayOutput
	ToTCPRouteSpecRulesBackendRefsArrayOutputWithContext(context.Context) TCPRouteSpecRulesBackendRefsArrayOutput
}

type TCPRouteSpecRulesBackendRefsArray []TCPRouteSpecRulesBackendRefsInput

func (TCPRouteSpecRulesBackendRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i TCPRouteSpecRulesBackendRefsArray) ToTCPRouteSpecRulesBackendRefsArrayOutput() TCPRouteSpecRulesBackendRefsArrayOutput {
	return i.ToTCPRouteSpecRulesBackendRefsArrayOutputWithContext(context.Background())
}

func (i TCPRouteSpecRulesBackendRefsArray) ToTCPRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) TCPRouteSpecRulesBackendRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecRulesBackendRefsArrayOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type TCPRouteSpecRulesBackendRefsOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecRulesBackendRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o TCPRouteSpecRulesBackendRefsOutput) ToTCPRouteSpecRulesBackendRefsOutput() TCPRouteSpecRulesBackendRefsOutput {
	return o
}

func (o TCPRouteSpecRulesBackendRefsOutput) ToTCPRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) TCPRouteSpecRulesBackendRefsOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o TCPRouteSpecRulesBackendRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o TCPRouteSpecRulesBackendRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o TCPRouteSpecRulesBackendRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o TCPRouteSpecRulesBackendRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o TCPRouteSpecRulesBackendRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced
// backend. This is computed as weight/(sum of all weights in this
// BackendRefs list). For non-zero values, there may be some epsilon from
// the exact proportion defined here depending on the precision an
// implementation supports. Weight is not a percentage and the sum of
// weights does not need to equal 100.
//
// If only one backend is specified and it has a weight greater than 0, 100%
// of the traffic is forwarded to that backend. If weight is set to 0, no
// traffic should be forwarded for this entry. If unspecified, weight
// defaults to 1.
//
// Support for this field varies based on the context where used.
func (o TCPRouteSpecRulesBackendRefsOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefs) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type TCPRouteSpecRulesBackendRefsArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecRulesBackendRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o TCPRouteSpecRulesBackendRefsArrayOutput) ToTCPRouteSpecRulesBackendRefsArrayOutput() TCPRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o TCPRouteSpecRulesBackendRefsArrayOutput) ToTCPRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) TCPRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o TCPRouteSpecRulesBackendRefsArrayOutput) Index(i pulumi.IntInput) TCPRouteSpecRulesBackendRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteSpecRulesBackendRefs {
		return vs[0].([]TCPRouteSpecRulesBackendRefs)[vs[1].(int)]
	}).(TCPRouteSpecRulesBackendRefsOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type TCPRouteSpecRulesBackendRefsPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// TCPRouteSpecRulesBackendRefsPatchInput is an input type that accepts TCPRouteSpecRulesBackendRefsPatchArgs and TCPRouteSpecRulesBackendRefsPatchOutput values.
// You can construct a concrete instance of `TCPRouteSpecRulesBackendRefsPatchInput` via:
//
//	TCPRouteSpecRulesBackendRefsPatchArgs{...}
type TCPRouteSpecRulesBackendRefsPatchInput interface {
	pulumi.Input

	ToTCPRouteSpecRulesBackendRefsPatchOutput() TCPRouteSpecRulesBackendRefsPatchOutput
	ToTCPRouteSpecRulesBackendRefsPatchOutputWithContext(context.Context) TCPRouteSpecRulesBackendRefsPatchOutput
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type TCPRouteSpecRulesBackendRefsPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (TCPRouteSpecRulesBackendRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (i TCPRouteSpecRulesBackendRefsPatchArgs) ToTCPRouteSpecRulesBackendRefsPatchOutput() TCPRouteSpecRulesBackendRefsPatchOutput {
	return i.ToTCPRouteSpecRulesBackendRefsPatchOutputWithContext(context.Background())
}

func (i TCPRouteSpecRulesBackendRefsPatchArgs) ToTCPRouteSpecRulesBackendRefsPatchOutputWithContext(ctx context.Context) TCPRouteSpecRulesBackendRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecRulesBackendRefsPatchOutput)
}

// TCPRouteSpecRulesBackendRefsPatchArrayInput is an input type that accepts TCPRouteSpecRulesBackendRefsPatchArray and TCPRouteSpecRulesBackendRefsPatchArrayOutput values.
// You can construct a concrete instance of `TCPRouteSpecRulesBackendRefsPatchArrayInput` via:
//
//	TCPRouteSpecRulesBackendRefsPatchArray{ TCPRouteSpecRulesBackendRefsPatchArgs{...} }
type TCPRouteSpecRulesBackendRefsPatchArrayInput interface {
	pulumi.Input

	ToTCPRouteSpecRulesBackendRefsPatchArrayOutput() TCPRouteSpecRulesBackendRefsPatchArrayOutput
	ToTCPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(context.Context) TCPRouteSpecRulesBackendRefsPatchArrayOutput
}

type TCPRouteSpecRulesBackendRefsPatchArray []TCPRouteSpecRulesBackendRefsPatchInput

func (TCPRouteSpecRulesBackendRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (i TCPRouteSpecRulesBackendRefsPatchArray) ToTCPRouteSpecRulesBackendRefsPatchArrayOutput() TCPRouteSpecRulesBackendRefsPatchArrayOutput {
	return i.ToTCPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(context.Background())
}

func (i TCPRouteSpecRulesBackendRefsPatchArray) ToTCPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(ctx context.Context) TCPRouteSpecRulesBackendRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecRulesBackendRefsPatchArrayOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type TCPRouteSpecRulesBackendRefsPatchOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecRulesBackendRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (o TCPRouteSpecRulesBackendRefsPatchOutput) ToTCPRouteSpecRulesBackendRefsPatchOutput() TCPRouteSpecRulesBackendRefsPatchOutput {
	return o
}

func (o TCPRouteSpecRulesBackendRefsPatchOutput) ToTCPRouteSpecRulesBackendRefsPatchOutputWithContext(ctx context.Context) TCPRouteSpecRulesBackendRefsPatchOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o TCPRouteSpecRulesBackendRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o TCPRouteSpecRulesBackendRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o TCPRouteSpecRulesBackendRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o TCPRouteSpecRulesBackendRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o TCPRouteSpecRulesBackendRefsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced
// backend. This is computed as weight/(sum of all weights in this
// BackendRefs list). For non-zero values, there may be some epsilon from
// the exact proportion defined here depending on the precision an
// implementation supports. Weight is not a percentage and the sum of
// weights does not need to equal 100.
//
// If only one backend is specified and it has a weight greater than 0, 100%
// of the traffic is forwarded to that backend. If weight is set to 0, no
// traffic should be forwarded for this entry. If unspecified, weight
// defaults to 1.
//
// Support for this field varies based on the context where used.
func (o TCPRouteSpecRulesBackendRefsPatchOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesBackendRefsPatch) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type TCPRouteSpecRulesBackendRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecRulesBackendRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (o TCPRouteSpecRulesBackendRefsPatchArrayOutput) ToTCPRouteSpecRulesBackendRefsPatchArrayOutput() TCPRouteSpecRulesBackendRefsPatchArrayOutput {
	return o
}

func (o TCPRouteSpecRulesBackendRefsPatchArrayOutput) ToTCPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(ctx context.Context) TCPRouteSpecRulesBackendRefsPatchArrayOutput {
	return o
}

func (o TCPRouteSpecRulesBackendRefsPatchArrayOutput) Index(i pulumi.IntInput) TCPRouteSpecRulesBackendRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteSpecRulesBackendRefsPatch {
		return vs[0].([]TCPRouteSpecRulesBackendRefsPatch)[vs[1].(int)]
	}).(TCPRouteSpecRulesBackendRefsPatchOutput)
}

// TCPRouteRule is the configuration for a given rule.
type TCPRouteSpecRulesPatch struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent. If unspecified or invalid (refers to a nonexistent resource or a
	// Service with no endpoints), the underlying implementation MUST actively
	// reject connection attempts to this backend. Connection rejections must
	// respect weight; if an invalid backend is requested to have 80% of
	// connections, then 80% of connections must be rejected instead.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Extended
	BackendRefs []TCPRouteSpecRulesBackendRefsPatch `pulumi:"backendRefs"`
	// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
	//
	// Support: Extended
	Name *string `pulumi:"name"`
}

// TCPRouteSpecRulesPatchInput is an input type that accepts TCPRouteSpecRulesPatchArgs and TCPRouteSpecRulesPatchOutput values.
// You can construct a concrete instance of `TCPRouteSpecRulesPatchInput` via:
//
//	TCPRouteSpecRulesPatchArgs{...}
type TCPRouteSpecRulesPatchInput interface {
	pulumi.Input

	ToTCPRouteSpecRulesPatchOutput() TCPRouteSpecRulesPatchOutput
	ToTCPRouteSpecRulesPatchOutputWithContext(context.Context) TCPRouteSpecRulesPatchOutput
}

// TCPRouteRule is the configuration for a given rule.
type TCPRouteSpecRulesPatchArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent. If unspecified or invalid (refers to a nonexistent resource or a
	// Service with no endpoints), the underlying implementation MUST actively
	// reject connection attempts to this backend. Connection rejections must
	// respect weight; if an invalid backend is requested to have 80% of
	// connections, then 80% of connections must be rejected instead.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Extended
	BackendRefs TCPRouteSpecRulesBackendRefsPatchArrayInput `pulumi:"backendRefs"`
	// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
	//
	// Support: Extended
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (TCPRouteSpecRulesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecRulesPatch)(nil)).Elem()
}

func (i TCPRouteSpecRulesPatchArgs) ToTCPRouteSpecRulesPatchOutput() TCPRouteSpecRulesPatchOutput {
	return i.ToTCPRouteSpecRulesPatchOutputWithContext(context.Background())
}

func (i TCPRouteSpecRulesPatchArgs) ToTCPRouteSpecRulesPatchOutputWithContext(ctx context.Context) TCPRouteSpecRulesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecRulesPatchOutput)
}

// TCPRouteSpecRulesPatchArrayInput is an input type that accepts TCPRouteSpecRulesPatchArray and TCPRouteSpecRulesPatchArrayOutput values.
// You can construct a concrete instance of `TCPRouteSpecRulesPatchArrayInput` via:
//
//	TCPRouteSpecRulesPatchArray{ TCPRouteSpecRulesPatchArgs{...} }
type TCPRouteSpecRulesPatchArrayInput interface {
	pulumi.Input

	ToTCPRouteSpecRulesPatchArrayOutput() TCPRouteSpecRulesPatchArrayOutput
	ToTCPRouteSpecRulesPatchArrayOutputWithContext(context.Context) TCPRouteSpecRulesPatchArrayOutput
}

type TCPRouteSpecRulesPatchArray []TCPRouteSpecRulesPatchInput

func (TCPRouteSpecRulesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecRulesPatch)(nil)).Elem()
}

func (i TCPRouteSpecRulesPatchArray) ToTCPRouteSpecRulesPatchArrayOutput() TCPRouteSpecRulesPatchArrayOutput {
	return i.ToTCPRouteSpecRulesPatchArrayOutputWithContext(context.Background())
}

func (i TCPRouteSpecRulesPatchArray) ToTCPRouteSpecRulesPatchArrayOutputWithContext(ctx context.Context) TCPRouteSpecRulesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteSpecRulesPatchArrayOutput)
}

// TCPRouteRule is the configuration for a given rule.
type TCPRouteSpecRulesPatchOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecRulesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteSpecRulesPatch)(nil)).Elem()
}

func (o TCPRouteSpecRulesPatchOutput) ToTCPRouteSpecRulesPatchOutput() TCPRouteSpecRulesPatchOutput {
	return o
}

func (o TCPRouteSpecRulesPatchOutput) ToTCPRouteSpecRulesPatchOutputWithContext(ctx context.Context) TCPRouteSpecRulesPatchOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be
// sent. If unspecified or invalid (refers to a nonexistent resource or a
// Service with no endpoints), the underlying implementation MUST actively
// reject connection attempts to this backend. Connection rejections must
// respect weight; if an invalid backend is requested to have 80% of
// connections, then 80% of connections must be rejected instead.
//
// Support: Core for Kubernetes Service
//
// Support: Extended for Kubernetes ServiceImport
//
// Support: Implementation-specific for any other resource
//
// Support for weight: Extended
func (o TCPRouteSpecRulesPatchOutput) BackendRefs() TCPRouteSpecRulesBackendRefsPatchArrayOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesPatch) []TCPRouteSpecRulesBackendRefsPatch { return v.BackendRefs }).(TCPRouteSpecRulesBackendRefsPatchArrayOutput)
}

// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
//
// Support: Extended
func (o TCPRouteSpecRulesPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteSpecRulesPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type TCPRouteSpecRulesPatchArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteSpecRulesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteSpecRulesPatch)(nil)).Elem()
}

func (o TCPRouteSpecRulesPatchArrayOutput) ToTCPRouteSpecRulesPatchArrayOutput() TCPRouteSpecRulesPatchArrayOutput {
	return o
}

func (o TCPRouteSpecRulesPatchArrayOutput) ToTCPRouteSpecRulesPatchArrayOutputWithContext(ctx context.Context) TCPRouteSpecRulesPatchArrayOutput {
	return o
}

func (o TCPRouteSpecRulesPatchArrayOutput) Index(i pulumi.IntInput) TCPRouteSpecRulesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteSpecRulesPatch {
		return vs[0].([]TCPRouteSpecRulesPatch)[vs[1].(int)]
	}).(TCPRouteSpecRulesPatchOutput)
}

// Status defines the current state of TCPRoute.
type TCPRouteStatus struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents []TCPRouteStatusParents `pulumi:"parents"`
}

// TCPRouteStatusInput is an input type that accepts TCPRouteStatusArgs and TCPRouteStatusOutput values.
// You can construct a concrete instance of `TCPRouteStatusInput` via:
//
//	TCPRouteStatusArgs{...}
type TCPRouteStatusInput interface {
	pulumi.Input

	ToTCPRouteStatusOutput() TCPRouteStatusOutput
	ToTCPRouteStatusOutputWithContext(context.Context) TCPRouteStatusOutput
}

// Status defines the current state of TCPRoute.
type TCPRouteStatusArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents TCPRouteStatusParentsArrayInput `pulumi:"parents"`
}

func (TCPRouteStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatus)(nil)).Elem()
}

func (i TCPRouteStatusArgs) ToTCPRouteStatusOutput() TCPRouteStatusOutput {
	return i.ToTCPRouteStatusOutputWithContext(context.Background())
}

func (i TCPRouteStatusArgs) ToTCPRouteStatusOutputWithContext(ctx context.Context) TCPRouteStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusOutput)
}

func (i TCPRouteStatusArgs) ToTCPRouteStatusPtrOutput() TCPRouteStatusPtrOutput {
	return i.ToTCPRouteStatusPtrOutputWithContext(context.Background())
}

func (i TCPRouteStatusArgs) ToTCPRouteStatusPtrOutputWithContext(ctx context.Context) TCPRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusOutput).ToTCPRouteStatusPtrOutputWithContext(ctx)
}

// TCPRouteStatusPtrInput is an input type that accepts TCPRouteStatusArgs, TCPRouteStatusPtr and TCPRouteStatusPtrOutput values.
// You can construct a concrete instance of `TCPRouteStatusPtrInput` via:
//
//	        TCPRouteStatusArgs{...}
//
//	or:
//
//	        nil
type TCPRouteStatusPtrInput interface {
	pulumi.Input

	ToTCPRouteStatusPtrOutput() TCPRouteStatusPtrOutput
	ToTCPRouteStatusPtrOutputWithContext(context.Context) TCPRouteStatusPtrOutput
}

type tcprouteStatusPtrType TCPRouteStatusArgs

func TCPRouteStatusPtr(v *TCPRouteStatusArgs) TCPRouteStatusPtrInput {
	return (*tcprouteStatusPtrType)(v)
}

func (*tcprouteStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteStatus)(nil)).Elem()
}

func (i *tcprouteStatusPtrType) ToTCPRouteStatusPtrOutput() TCPRouteStatusPtrOutput {
	return i.ToTCPRouteStatusPtrOutputWithContext(context.Background())
}

func (i *tcprouteStatusPtrType) ToTCPRouteStatusPtrOutputWithContext(ctx context.Context) TCPRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusPtrOutput)
}

// Status defines the current state of TCPRoute.
type TCPRouteStatusOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatus)(nil)).Elem()
}

func (o TCPRouteStatusOutput) ToTCPRouteStatusOutput() TCPRouteStatusOutput {
	return o
}

func (o TCPRouteStatusOutput) ToTCPRouteStatusOutputWithContext(ctx context.Context) TCPRouteStatusOutput {
	return o
}

func (o TCPRouteStatusOutput) ToTCPRouteStatusPtrOutput() TCPRouteStatusPtrOutput {
	return o.ToTCPRouteStatusPtrOutputWithContext(context.Background())
}

func (o TCPRouteStatusOutput) ToTCPRouteStatusPtrOutputWithContext(ctx context.Context) TCPRouteStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TCPRouteStatus) *TCPRouteStatus {
		return &v
	}).(TCPRouteStatusPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o TCPRouteStatusOutput) Parents() TCPRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v TCPRouteStatus) []TCPRouteStatusParents { return v.Parents }).(TCPRouteStatusParentsArrayOutput)
}

type TCPRouteStatusPtrOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteStatus)(nil)).Elem()
}

func (o TCPRouteStatusPtrOutput) ToTCPRouteStatusPtrOutput() TCPRouteStatusPtrOutput {
	return o
}

func (o TCPRouteStatusPtrOutput) ToTCPRouteStatusPtrOutputWithContext(ctx context.Context) TCPRouteStatusPtrOutput {
	return o
}

func (o TCPRouteStatusPtrOutput) Elem() TCPRouteStatusOutput {
	return o.ApplyT(func(v *TCPRouteStatus) TCPRouteStatus {
		if v != nil {
			return *v
		}
		var ret TCPRouteStatus
		return ret
	}).(TCPRouteStatusOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o TCPRouteStatusPtrOutput) Parents() TCPRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v *TCPRouteStatus) []TCPRouteStatusParents {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(TCPRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type TCPRouteStatusParents struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a nonexistent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions []TCPRouteStatusParentsConditions `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName *string                         `pulumi:"controllerName"`
	ParentRef      *TCPRouteStatusParentsParentRef `pulumi:"parentRef"`
}

// TCPRouteStatusParentsInput is an input type that accepts TCPRouteStatusParentsArgs and TCPRouteStatusParentsOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsInput` via:
//
//	TCPRouteStatusParentsArgs{...}
type TCPRouteStatusParentsInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsOutput() TCPRouteStatusParentsOutput
	ToTCPRouteStatusParentsOutputWithContext(context.Context) TCPRouteStatusParentsOutput
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type TCPRouteStatusParentsArgs struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a nonexistent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions TCPRouteStatusParentsConditionsArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringPtrInput                  `pulumi:"controllerName"`
	ParentRef      TCPRouteStatusParentsParentRefPtrInput `pulumi:"parentRef"`
}

func (TCPRouteStatusParentsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParents)(nil)).Elem()
}

func (i TCPRouteStatusParentsArgs) ToTCPRouteStatusParentsOutput() TCPRouteStatusParentsOutput {
	return i.ToTCPRouteStatusParentsOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsArgs) ToTCPRouteStatusParentsOutputWithContext(ctx context.Context) TCPRouteStatusParentsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsOutput)
}

// TCPRouteStatusParentsArrayInput is an input type that accepts TCPRouteStatusParentsArray and TCPRouteStatusParentsArrayOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsArrayInput` via:
//
//	TCPRouteStatusParentsArray{ TCPRouteStatusParentsArgs{...} }
type TCPRouteStatusParentsArrayInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsArrayOutput() TCPRouteStatusParentsArrayOutput
	ToTCPRouteStatusParentsArrayOutputWithContext(context.Context) TCPRouteStatusParentsArrayOutput
}

type TCPRouteStatusParentsArray []TCPRouteStatusParentsInput

func (TCPRouteStatusParentsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteStatusParents)(nil)).Elem()
}

func (i TCPRouteStatusParentsArray) ToTCPRouteStatusParentsArrayOutput() TCPRouteStatusParentsArrayOutput {
	return i.ToTCPRouteStatusParentsArrayOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsArray) ToTCPRouteStatusParentsArrayOutputWithContext(ctx context.Context) TCPRouteStatusParentsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type TCPRouteStatusParentsOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParents)(nil)).Elem()
}

func (o TCPRouteStatusParentsOutput) ToTCPRouteStatusParentsOutput() TCPRouteStatusParentsOutput {
	return o
}

func (o TCPRouteStatusParentsOutput) ToTCPRouteStatusParentsOutputWithContext(ctx context.Context) TCPRouteStatusParentsOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway.
// Note that the route's availability is also subject to the Gateway's own
// status conditions and listener status.
//
// If the Route's ParentRef specifies an existing Gateway that supports
// Routes of this kind AND that Gateway's controller has sufficient access,
// then that Gateway's controller MUST set the "Accepted" condition on the
// Route, to indicate whether the route has been accepted or rejected by the
// Gateway, and why.
//
// A Route MUST be considered "Accepted" if at least one of the Route's
// rules is implemented by the Gateway.
//
// There are a number of cases where the "Accepted" condition may not be set
// due to lack of controller visibility, that includes when:
//
// * The Route refers to a nonexistent parent.
// * The Route is of a type that the controller does not support.
// * The Route is in a namespace the controller does not have access to.
func (o TCPRouteStatusParentsOutput) Conditions() TCPRouteStatusParentsConditionsArrayOutput {
	return o.ApplyT(func(v TCPRouteStatusParents) []TCPRouteStatusParentsConditions { return v.Conditions }).(TCPRouteStatusParentsConditionsArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o TCPRouteStatusParentsOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParents) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

func (o TCPRouteStatusParentsOutput) ParentRef() TCPRouteStatusParentsParentRefPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParents) *TCPRouteStatusParentsParentRef { return v.ParentRef }).(TCPRouteStatusParentsParentRefPtrOutput)
}

type TCPRouteStatusParentsArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteStatusParents)(nil)).Elem()
}

func (o TCPRouteStatusParentsArrayOutput) ToTCPRouteStatusParentsArrayOutput() TCPRouteStatusParentsArrayOutput {
	return o
}

func (o TCPRouteStatusParentsArrayOutput) ToTCPRouteStatusParentsArrayOutputWithContext(ctx context.Context) TCPRouteStatusParentsArrayOutput {
	return o
}

func (o TCPRouteStatusParentsArrayOutput) Index(i pulumi.IntInput) TCPRouteStatusParentsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteStatusParents {
		return vs[0].([]TCPRouteStatusParents)[vs[1].(int)]
	}).(TCPRouteStatusParentsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type TCPRouteStatusParentsConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type *string `pulumi:"type"`
}

// TCPRouteStatusParentsConditionsInput is an input type that accepts TCPRouteStatusParentsConditionsArgs and TCPRouteStatusParentsConditionsOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsConditionsInput` via:
//
//	TCPRouteStatusParentsConditionsArgs{...}
type TCPRouteStatusParentsConditionsInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsConditionsOutput() TCPRouteStatusParentsConditionsOutput
	ToTCPRouteStatusParentsConditionsOutputWithContext(context.Context) TCPRouteStatusParentsConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
type TCPRouteStatusParentsConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (TCPRouteStatusParentsConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParentsConditions)(nil)).Elem()
}

func (i TCPRouteStatusParentsConditionsArgs) ToTCPRouteStatusParentsConditionsOutput() TCPRouteStatusParentsConditionsOutput {
	return i.ToTCPRouteStatusParentsConditionsOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsConditionsArgs) ToTCPRouteStatusParentsConditionsOutputWithContext(ctx context.Context) TCPRouteStatusParentsConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsConditionsOutput)
}

// TCPRouteStatusParentsConditionsArrayInput is an input type that accepts TCPRouteStatusParentsConditionsArray and TCPRouteStatusParentsConditionsArrayOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsConditionsArrayInput` via:
//
//	TCPRouteStatusParentsConditionsArray{ TCPRouteStatusParentsConditionsArgs{...} }
type TCPRouteStatusParentsConditionsArrayInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsConditionsArrayOutput() TCPRouteStatusParentsConditionsArrayOutput
	ToTCPRouteStatusParentsConditionsArrayOutputWithContext(context.Context) TCPRouteStatusParentsConditionsArrayOutput
}

type TCPRouteStatusParentsConditionsArray []TCPRouteStatusParentsConditionsInput

func (TCPRouteStatusParentsConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteStatusParentsConditions)(nil)).Elem()
}

func (i TCPRouteStatusParentsConditionsArray) ToTCPRouteStatusParentsConditionsArrayOutput() TCPRouteStatusParentsConditionsArrayOutput {
	return i.ToTCPRouteStatusParentsConditionsArrayOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsConditionsArray) ToTCPRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) TCPRouteStatusParentsConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type TCPRouteStatusParentsConditionsOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParentsConditions)(nil)).Elem()
}

func (o TCPRouteStatusParentsConditionsOutput) ToTCPRouteStatusParentsConditionsOutput() TCPRouteStatusParentsConditionsOutput {
	return o
}

func (o TCPRouteStatusParentsConditionsOutput) ToTCPRouteStatusParentsConditionsOutputWithContext(ctx context.Context) TCPRouteStatusParentsConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o TCPRouteStatusParentsConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o TCPRouteStatusParentsConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o TCPRouteStatusParentsConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o TCPRouteStatusParentsConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o TCPRouteStatusParentsConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
func (o TCPRouteStatusParentsConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type TCPRouteStatusParentsConditionsArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteStatusParentsConditions)(nil)).Elem()
}

func (o TCPRouteStatusParentsConditionsArrayOutput) ToTCPRouteStatusParentsConditionsArrayOutput() TCPRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o TCPRouteStatusParentsConditionsArrayOutput) ToTCPRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) TCPRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o TCPRouteStatusParentsConditionsArrayOutput) Index(i pulumi.IntInput) TCPRouteStatusParentsConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteStatusParentsConditions {
		return vs[0].([]TCPRouteStatusParentsConditions)[vs[1].(int)]
	}).(TCPRouteStatusParentsConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type TCPRouteStatusParentsConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type *string `pulumi:"type"`
}

// TCPRouteStatusParentsConditionsPatchInput is an input type that accepts TCPRouteStatusParentsConditionsPatchArgs and TCPRouteStatusParentsConditionsPatchOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsConditionsPatchInput` via:
//
//	TCPRouteStatusParentsConditionsPatchArgs{...}
type TCPRouteStatusParentsConditionsPatchInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsConditionsPatchOutput() TCPRouteStatusParentsConditionsPatchOutput
	ToTCPRouteStatusParentsConditionsPatchOutputWithContext(context.Context) TCPRouteStatusParentsConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
type TCPRouteStatusParentsConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (TCPRouteStatusParentsConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (i TCPRouteStatusParentsConditionsPatchArgs) ToTCPRouteStatusParentsConditionsPatchOutput() TCPRouteStatusParentsConditionsPatchOutput {
	return i.ToTCPRouteStatusParentsConditionsPatchOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsConditionsPatchArgs) ToTCPRouteStatusParentsConditionsPatchOutputWithContext(ctx context.Context) TCPRouteStatusParentsConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsConditionsPatchOutput)
}

// TCPRouteStatusParentsConditionsPatchArrayInput is an input type that accepts TCPRouteStatusParentsConditionsPatchArray and TCPRouteStatusParentsConditionsPatchArrayOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsConditionsPatchArrayInput` via:
//
//	TCPRouteStatusParentsConditionsPatchArray{ TCPRouteStatusParentsConditionsPatchArgs{...} }
type TCPRouteStatusParentsConditionsPatchArrayInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsConditionsPatchArrayOutput() TCPRouteStatusParentsConditionsPatchArrayOutput
	ToTCPRouteStatusParentsConditionsPatchArrayOutputWithContext(context.Context) TCPRouteStatusParentsConditionsPatchArrayOutput
}

type TCPRouteStatusParentsConditionsPatchArray []TCPRouteStatusParentsConditionsPatchInput

func (TCPRouteStatusParentsConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (i TCPRouteStatusParentsConditionsPatchArray) ToTCPRouteStatusParentsConditionsPatchArrayOutput() TCPRouteStatusParentsConditionsPatchArrayOutput {
	return i.ToTCPRouteStatusParentsConditionsPatchArrayOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsConditionsPatchArray) ToTCPRouteStatusParentsConditionsPatchArrayOutputWithContext(ctx context.Context) TCPRouteStatusParentsConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type TCPRouteStatusParentsConditionsPatchOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (o TCPRouteStatusParentsConditionsPatchOutput) ToTCPRouteStatusParentsConditionsPatchOutput() TCPRouteStatusParentsConditionsPatchOutput {
	return o
}

func (o TCPRouteStatusParentsConditionsPatchOutput) ToTCPRouteStatusParentsConditionsPatchOutputWithContext(ctx context.Context) TCPRouteStatusParentsConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o TCPRouteStatusParentsConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o TCPRouteStatusParentsConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o TCPRouteStatusParentsConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o TCPRouteStatusParentsConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o TCPRouteStatusParentsConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
func (o TCPRouteStatusParentsConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type TCPRouteStatusParentsConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (o TCPRouteStatusParentsConditionsPatchArrayOutput) ToTCPRouteStatusParentsConditionsPatchArrayOutput() TCPRouteStatusParentsConditionsPatchArrayOutput {
	return o
}

func (o TCPRouteStatusParentsConditionsPatchArrayOutput) ToTCPRouteStatusParentsConditionsPatchArrayOutputWithContext(ctx context.Context) TCPRouteStatusParentsConditionsPatchArrayOutput {
	return o
}

func (o TCPRouteStatusParentsConditionsPatchArrayOutput) Index(i pulumi.IntInput) TCPRouteStatusParentsConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteStatusParentsConditionsPatch {
		return vs[0].([]TCPRouteStatusParentsConditionsPatch)[vs[1].(int)]
	}).(TCPRouteStatusParentsConditionsPatchOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type TCPRouteStatusParentsParentRef struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// TCPRouteStatusParentsParentRefInput is an input type that accepts TCPRouteStatusParentsParentRefArgs and TCPRouteStatusParentsParentRefOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsParentRefInput` via:
//
//	TCPRouteStatusParentsParentRefArgs{...}
type TCPRouteStatusParentsParentRefInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsParentRefOutput() TCPRouteStatusParentsParentRefOutput
	ToTCPRouteStatusParentsParentRefOutputWithContext(context.Context) TCPRouteStatusParentsParentRefOutput
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type TCPRouteStatusParentsParentRefArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (TCPRouteStatusParentsParentRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParentsParentRef)(nil)).Elem()
}

func (i TCPRouteStatusParentsParentRefArgs) ToTCPRouteStatusParentsParentRefOutput() TCPRouteStatusParentsParentRefOutput {
	return i.ToTCPRouteStatusParentsParentRefOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsParentRefArgs) ToTCPRouteStatusParentsParentRefOutputWithContext(ctx context.Context) TCPRouteStatusParentsParentRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsParentRefOutput)
}

func (i TCPRouteStatusParentsParentRefArgs) ToTCPRouteStatusParentsParentRefPtrOutput() TCPRouteStatusParentsParentRefPtrOutput {
	return i.ToTCPRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsParentRefArgs) ToTCPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) TCPRouteStatusParentsParentRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsParentRefOutput).ToTCPRouteStatusParentsParentRefPtrOutputWithContext(ctx)
}

// TCPRouteStatusParentsParentRefPtrInput is an input type that accepts TCPRouteStatusParentsParentRefArgs, TCPRouteStatusParentsParentRefPtr and TCPRouteStatusParentsParentRefPtrOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsParentRefPtrInput` via:
//
//	        TCPRouteStatusParentsParentRefArgs{...}
//
//	or:
//
//	        nil
type TCPRouteStatusParentsParentRefPtrInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsParentRefPtrOutput() TCPRouteStatusParentsParentRefPtrOutput
	ToTCPRouteStatusParentsParentRefPtrOutputWithContext(context.Context) TCPRouteStatusParentsParentRefPtrOutput
}

type tcprouteStatusParentsParentRefPtrType TCPRouteStatusParentsParentRefArgs

func TCPRouteStatusParentsParentRefPtr(v *TCPRouteStatusParentsParentRefArgs) TCPRouteStatusParentsParentRefPtrInput {
	return (*tcprouteStatusParentsParentRefPtrType)(v)
}

func (*tcprouteStatusParentsParentRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteStatusParentsParentRef)(nil)).Elem()
}

func (i *tcprouteStatusParentsParentRefPtrType) ToTCPRouteStatusParentsParentRefPtrOutput() TCPRouteStatusParentsParentRefPtrOutput {
	return i.ToTCPRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (i *tcprouteStatusParentsParentRefPtrType) ToTCPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) TCPRouteStatusParentsParentRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsParentRefPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type TCPRouteStatusParentsParentRefOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsParentRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParentsParentRef)(nil)).Elem()
}

func (o TCPRouteStatusParentsParentRefOutput) ToTCPRouteStatusParentsParentRefOutput() TCPRouteStatusParentsParentRefOutput {
	return o
}

func (o TCPRouteStatusParentsParentRefOutput) ToTCPRouteStatusParentsParentRefOutputWithContext(ctx context.Context) TCPRouteStatusParentsParentRefOutput {
	return o
}

func (o TCPRouteStatusParentsParentRefOutput) ToTCPRouteStatusParentsParentRefPtrOutput() TCPRouteStatusParentsParentRefPtrOutput {
	return o.ToTCPRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (o TCPRouteStatusParentsParentRefOutput) ToTCPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) TCPRouteStatusParentsParentRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TCPRouteStatusParentsParentRef) *TCPRouteStatusParentsParentRef {
		return &v
	}).(TCPRouteStatusParentsParentRefPtrOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o TCPRouteStatusParentsParentRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o TCPRouteStatusParentsParentRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o TCPRouteStatusParentsParentRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o TCPRouteStatusParentsParentRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o TCPRouteStatusParentsParentRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o TCPRouteStatusParentsParentRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type TCPRouteStatusParentsParentRefPtrOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsParentRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteStatusParentsParentRef)(nil)).Elem()
}

func (o TCPRouteStatusParentsParentRefPtrOutput) ToTCPRouteStatusParentsParentRefPtrOutput() TCPRouteStatusParentsParentRefPtrOutput {
	return o
}

func (o TCPRouteStatusParentsParentRefPtrOutput) ToTCPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) TCPRouteStatusParentsParentRefPtrOutput {
	return o
}

func (o TCPRouteStatusParentsParentRefPtrOutput) Elem() TCPRouteStatusParentsParentRefOutput {
	return o.ApplyT(func(v *TCPRouteStatusParentsParentRef) TCPRouteStatusParentsParentRef {
		if v != nil {
			return *v
		}
		var ret TCPRouteStatusParentsParentRef
		return ret
	}).(TCPRouteStatusParentsParentRefOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o TCPRouteStatusParentsParentRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TCPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o TCPRouteStatusParentsParentRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TCPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o TCPRouteStatusParentsParentRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TCPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o TCPRouteStatusParentsParentRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TCPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o TCPRouteStatusParentsParentRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TCPRouteStatusParentsParentRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o TCPRouteStatusParentsParentRefPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TCPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type TCPRouteStatusParentsParentRefPatch struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// TCPRouteStatusParentsParentRefPatchInput is an input type that accepts TCPRouteStatusParentsParentRefPatchArgs and TCPRouteStatusParentsParentRefPatchOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsParentRefPatchInput` via:
//
//	TCPRouteStatusParentsParentRefPatchArgs{...}
type TCPRouteStatusParentsParentRefPatchInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsParentRefPatchOutput() TCPRouteStatusParentsParentRefPatchOutput
	ToTCPRouteStatusParentsParentRefPatchOutputWithContext(context.Context) TCPRouteStatusParentsParentRefPatchOutput
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type TCPRouteStatusParentsParentRefPatchArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (TCPRouteStatusParentsParentRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (i TCPRouteStatusParentsParentRefPatchArgs) ToTCPRouteStatusParentsParentRefPatchOutput() TCPRouteStatusParentsParentRefPatchOutput {
	return i.ToTCPRouteStatusParentsParentRefPatchOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsParentRefPatchArgs) ToTCPRouteStatusParentsParentRefPatchOutputWithContext(ctx context.Context) TCPRouteStatusParentsParentRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsParentRefPatchOutput)
}

func (i TCPRouteStatusParentsParentRefPatchArgs) ToTCPRouteStatusParentsParentRefPatchPtrOutput() TCPRouteStatusParentsParentRefPatchPtrOutput {
	return i.ToTCPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsParentRefPatchArgs) ToTCPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) TCPRouteStatusParentsParentRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsParentRefPatchOutput).ToTCPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx)
}

// TCPRouteStatusParentsParentRefPatchPtrInput is an input type that accepts TCPRouteStatusParentsParentRefPatchArgs, TCPRouteStatusParentsParentRefPatchPtr and TCPRouteStatusParentsParentRefPatchPtrOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsParentRefPatchPtrInput` via:
//
//	        TCPRouteStatusParentsParentRefPatchArgs{...}
//
//	or:
//
//	        nil
type TCPRouteStatusParentsParentRefPatchPtrInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsParentRefPatchPtrOutput() TCPRouteStatusParentsParentRefPatchPtrOutput
	ToTCPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Context) TCPRouteStatusParentsParentRefPatchPtrOutput
}

type tcprouteStatusParentsParentRefPatchPtrType TCPRouteStatusParentsParentRefPatchArgs

func TCPRouteStatusParentsParentRefPatchPtr(v *TCPRouteStatusParentsParentRefPatchArgs) TCPRouteStatusParentsParentRefPatchPtrInput {
	return (*tcprouteStatusParentsParentRefPatchPtrType)(v)
}

func (*tcprouteStatusParentsParentRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (i *tcprouteStatusParentsParentRefPatchPtrType) ToTCPRouteStatusParentsParentRefPatchPtrOutput() TCPRouteStatusParentsParentRefPatchPtrOutput {
	return i.ToTCPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (i *tcprouteStatusParentsParentRefPatchPtrType) ToTCPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) TCPRouteStatusParentsParentRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsParentRefPatchPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type TCPRouteStatusParentsParentRefPatchOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsParentRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (o TCPRouteStatusParentsParentRefPatchOutput) ToTCPRouteStatusParentsParentRefPatchOutput() TCPRouteStatusParentsParentRefPatchOutput {
	return o
}

func (o TCPRouteStatusParentsParentRefPatchOutput) ToTCPRouteStatusParentsParentRefPatchOutputWithContext(ctx context.Context) TCPRouteStatusParentsParentRefPatchOutput {
	return o
}

func (o TCPRouteStatusParentsParentRefPatchOutput) ToTCPRouteStatusParentsParentRefPatchPtrOutput() TCPRouteStatusParentsParentRefPatchPtrOutput {
	return o.ToTCPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (o TCPRouteStatusParentsParentRefPatchOutput) ToTCPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) TCPRouteStatusParentsParentRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TCPRouteStatusParentsParentRefPatch) *TCPRouteStatusParentsParentRefPatch {
		return &v
	}).(TCPRouteStatusParentsParentRefPatchPtrOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o TCPRouteStatusParentsParentRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o TCPRouteStatusParentsParentRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o TCPRouteStatusParentsParentRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o TCPRouteStatusParentsParentRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o TCPRouteStatusParentsParentRefPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRefPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o TCPRouteStatusParentsParentRefPatchOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsParentRefPatch) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type TCPRouteStatusParentsParentRefPatchPtrOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsParentRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (o TCPRouteStatusParentsParentRefPatchPtrOutput) ToTCPRouteStatusParentsParentRefPatchPtrOutput() TCPRouteStatusParentsParentRefPatchPtrOutput {
	return o
}

func (o TCPRouteStatusParentsParentRefPatchPtrOutput) ToTCPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) TCPRouteStatusParentsParentRefPatchPtrOutput {
	return o
}

func (o TCPRouteStatusParentsParentRefPatchPtrOutput) Elem() TCPRouteStatusParentsParentRefPatchOutput {
	return o.ApplyT(func(v *TCPRouteStatusParentsParentRefPatch) TCPRouteStatusParentsParentRefPatch {
		if v != nil {
			return *v
		}
		var ret TCPRouteStatusParentsParentRefPatch
		return ret
	}).(TCPRouteStatusParentsParentRefPatchOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o TCPRouteStatusParentsParentRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TCPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o TCPRouteStatusParentsParentRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TCPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o TCPRouteStatusParentsParentRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TCPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o TCPRouteStatusParentsParentRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TCPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o TCPRouteStatusParentsParentRefPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TCPRouteStatusParentsParentRefPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o TCPRouteStatusParentsParentRefPatchPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TCPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type TCPRouteStatusParentsPatch struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a nonexistent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions []TCPRouteStatusParentsConditionsPatch `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName *string                              `pulumi:"controllerName"`
	ParentRef      *TCPRouteStatusParentsParentRefPatch `pulumi:"parentRef"`
}

// TCPRouteStatusParentsPatchInput is an input type that accepts TCPRouteStatusParentsPatchArgs and TCPRouteStatusParentsPatchOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsPatchInput` via:
//
//	TCPRouteStatusParentsPatchArgs{...}
type TCPRouteStatusParentsPatchInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsPatchOutput() TCPRouteStatusParentsPatchOutput
	ToTCPRouteStatusParentsPatchOutputWithContext(context.Context) TCPRouteStatusParentsPatchOutput
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type TCPRouteStatusParentsPatchArgs struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a nonexistent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions TCPRouteStatusParentsConditionsPatchArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringPtrInput                       `pulumi:"controllerName"`
	ParentRef      TCPRouteStatusParentsParentRefPatchPtrInput `pulumi:"parentRef"`
}

func (TCPRouteStatusParentsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParentsPatch)(nil)).Elem()
}

func (i TCPRouteStatusParentsPatchArgs) ToTCPRouteStatusParentsPatchOutput() TCPRouteStatusParentsPatchOutput {
	return i.ToTCPRouteStatusParentsPatchOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsPatchArgs) ToTCPRouteStatusParentsPatchOutputWithContext(ctx context.Context) TCPRouteStatusParentsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsPatchOutput)
}

// TCPRouteStatusParentsPatchArrayInput is an input type that accepts TCPRouteStatusParentsPatchArray and TCPRouteStatusParentsPatchArrayOutput values.
// You can construct a concrete instance of `TCPRouteStatusParentsPatchArrayInput` via:
//
//	TCPRouteStatusParentsPatchArray{ TCPRouteStatusParentsPatchArgs{...} }
type TCPRouteStatusParentsPatchArrayInput interface {
	pulumi.Input

	ToTCPRouteStatusParentsPatchArrayOutput() TCPRouteStatusParentsPatchArrayOutput
	ToTCPRouteStatusParentsPatchArrayOutputWithContext(context.Context) TCPRouteStatusParentsPatchArrayOutput
}

type TCPRouteStatusParentsPatchArray []TCPRouteStatusParentsPatchInput

func (TCPRouteStatusParentsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteStatusParentsPatch)(nil)).Elem()
}

func (i TCPRouteStatusParentsPatchArray) ToTCPRouteStatusParentsPatchArrayOutput() TCPRouteStatusParentsPatchArrayOutput {
	return i.ToTCPRouteStatusParentsPatchArrayOutputWithContext(context.Background())
}

func (i TCPRouteStatusParentsPatchArray) ToTCPRouteStatusParentsPatchArrayOutputWithContext(ctx context.Context) TCPRouteStatusParentsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusParentsPatchArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type TCPRouteStatusParentsPatchOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusParentsPatch)(nil)).Elem()
}

func (o TCPRouteStatusParentsPatchOutput) ToTCPRouteStatusParentsPatchOutput() TCPRouteStatusParentsPatchOutput {
	return o
}

func (o TCPRouteStatusParentsPatchOutput) ToTCPRouteStatusParentsPatchOutputWithContext(ctx context.Context) TCPRouteStatusParentsPatchOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway.
// Note that the route's availability is also subject to the Gateway's own
// status conditions and listener status.
//
// If the Route's ParentRef specifies an existing Gateway that supports
// Routes of this kind AND that Gateway's controller has sufficient access,
// then that Gateway's controller MUST set the "Accepted" condition on the
// Route, to indicate whether the route has been accepted or rejected by the
// Gateway, and why.
//
// A Route MUST be considered "Accepted" if at least one of the Route's
// rules is implemented by the Gateway.
//
// There are a number of cases where the "Accepted" condition may not be set
// due to lack of controller visibility, that includes when:
//
// * The Route refers to a nonexistent parent.
// * The Route is of a type that the controller does not support.
// * The Route is in a namespace the controller does not have access to.
func (o TCPRouteStatusParentsPatchOutput) Conditions() TCPRouteStatusParentsConditionsPatchArrayOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsPatch) []TCPRouteStatusParentsConditionsPatch { return v.Conditions }).(TCPRouteStatusParentsConditionsPatchArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o TCPRouteStatusParentsPatchOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsPatch) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

func (o TCPRouteStatusParentsPatchOutput) ParentRef() TCPRouteStatusParentsParentRefPatchPtrOutput {
	return o.ApplyT(func(v TCPRouteStatusParentsPatch) *TCPRouteStatusParentsParentRefPatch { return v.ParentRef }).(TCPRouteStatusParentsParentRefPatchPtrOutput)
}

type TCPRouteStatusParentsPatchArrayOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusParentsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TCPRouteStatusParentsPatch)(nil)).Elem()
}

func (o TCPRouteStatusParentsPatchArrayOutput) ToTCPRouteStatusParentsPatchArrayOutput() TCPRouteStatusParentsPatchArrayOutput {
	return o
}

func (o TCPRouteStatusParentsPatchArrayOutput) ToTCPRouteStatusParentsPatchArrayOutputWithContext(ctx context.Context) TCPRouteStatusParentsPatchArrayOutput {
	return o
}

func (o TCPRouteStatusParentsPatchArrayOutput) Index(i pulumi.IntInput) TCPRouteStatusParentsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TCPRouteStatusParentsPatch {
		return vs[0].([]TCPRouteStatusParentsPatch)[vs[1].(int)]
	}).(TCPRouteStatusParentsPatchOutput)
}

// Status defines the current state of TCPRoute.
type TCPRouteStatusPatch struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents []TCPRouteStatusParentsPatch `pulumi:"parents"`
}

// TCPRouteStatusPatchInput is an input type that accepts TCPRouteStatusPatchArgs and TCPRouteStatusPatchOutput values.
// You can construct a concrete instance of `TCPRouteStatusPatchInput` via:
//
//	TCPRouteStatusPatchArgs{...}
type TCPRouteStatusPatchInput interface {
	pulumi.Input

	ToTCPRouteStatusPatchOutput() TCPRouteStatusPatchOutput
	ToTCPRouteStatusPatchOutputWithContext(context.Context) TCPRouteStatusPatchOutput
}

// Status defines the current state of TCPRoute.
type TCPRouteStatusPatchArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents TCPRouteStatusParentsPatchArrayInput `pulumi:"parents"`
}

func (TCPRouteStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusPatch)(nil)).Elem()
}

func (i TCPRouteStatusPatchArgs) ToTCPRouteStatusPatchOutput() TCPRouteStatusPatchOutput {
	return i.ToTCPRouteStatusPatchOutputWithContext(context.Background())
}

func (i TCPRouteStatusPatchArgs) ToTCPRouteStatusPatchOutputWithContext(ctx context.Context) TCPRouteStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusPatchOutput)
}

func (i TCPRouteStatusPatchArgs) ToTCPRouteStatusPatchPtrOutput() TCPRouteStatusPatchPtrOutput {
	return i.ToTCPRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (i TCPRouteStatusPatchArgs) ToTCPRouteStatusPatchPtrOutputWithContext(ctx context.Context) TCPRouteStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusPatchOutput).ToTCPRouteStatusPatchPtrOutputWithContext(ctx)
}

// TCPRouteStatusPatchPtrInput is an input type that accepts TCPRouteStatusPatchArgs, TCPRouteStatusPatchPtr and TCPRouteStatusPatchPtrOutput values.
// You can construct a concrete instance of `TCPRouteStatusPatchPtrInput` via:
//
//	        TCPRouteStatusPatchArgs{...}
//
//	or:
//
//	        nil
type TCPRouteStatusPatchPtrInput interface {
	pulumi.Input

	ToTCPRouteStatusPatchPtrOutput() TCPRouteStatusPatchPtrOutput
	ToTCPRouteStatusPatchPtrOutputWithContext(context.Context) TCPRouteStatusPatchPtrOutput
}

type tcprouteStatusPatchPtrType TCPRouteStatusPatchArgs

func TCPRouteStatusPatchPtr(v *TCPRouteStatusPatchArgs) TCPRouteStatusPatchPtrInput {
	return (*tcprouteStatusPatchPtrType)(v)
}

func (*tcprouteStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteStatusPatch)(nil)).Elem()
}

func (i *tcprouteStatusPatchPtrType) ToTCPRouteStatusPatchPtrOutput() TCPRouteStatusPatchPtrOutput {
	return i.ToTCPRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (i *tcprouteStatusPatchPtrType) ToTCPRouteStatusPatchPtrOutputWithContext(ctx context.Context) TCPRouteStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TCPRouteStatusPatchPtrOutput)
}

// Status defines the current state of TCPRoute.
type TCPRouteStatusPatchOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TCPRouteStatusPatch)(nil)).Elem()
}

func (o TCPRouteStatusPatchOutput) ToTCPRouteStatusPatchOutput() TCPRouteStatusPatchOutput {
	return o
}

func (o TCPRouteStatusPatchOutput) ToTCPRouteStatusPatchOutputWithContext(ctx context.Context) TCPRouteStatusPatchOutput {
	return o
}

func (o TCPRouteStatusPatchOutput) ToTCPRouteStatusPatchPtrOutput() TCPRouteStatusPatchPtrOutput {
	return o.ToTCPRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (o TCPRouteStatusPatchOutput) ToTCPRouteStatusPatchPtrOutputWithContext(ctx context.Context) TCPRouteStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TCPRouteStatusPatch) *TCPRouteStatusPatch {
		return &v
	}).(TCPRouteStatusPatchPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o TCPRouteStatusPatchOutput) Parents() TCPRouteStatusParentsPatchArrayOutput {
	return o.ApplyT(func(v TCPRouteStatusPatch) []TCPRouteStatusParentsPatch { return v.Parents }).(TCPRouteStatusParentsPatchArrayOutput)
}

type TCPRouteStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (TCPRouteStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TCPRouteStatusPatch)(nil)).Elem()
}

func (o TCPRouteStatusPatchPtrOutput) ToTCPRouteStatusPatchPtrOutput() TCPRouteStatusPatchPtrOutput {
	return o
}

func (o TCPRouteStatusPatchPtrOutput) ToTCPRouteStatusPatchPtrOutputWithContext(ctx context.Context) TCPRouteStatusPatchPtrOutput {
	return o
}

func (o TCPRouteStatusPatchPtrOutput) Elem() TCPRouteStatusPatchOutput {
	return o.ApplyT(func(v *TCPRouteStatusPatch) TCPRouteStatusPatch {
		if v != nil {
			return *v
		}
		var ret TCPRouteStatusPatch
		return ret
	}).(TCPRouteStatusPatchOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o TCPRouteStatusPatchPtrOutput) Parents() TCPRouteStatusParentsPatchArrayOutput {
	return o.ApplyT(func(v *TCPRouteStatusPatch) []TCPRouteStatusParentsPatch {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(TCPRouteStatusParentsPatchArrayOutput)
}

// The TLSRoute resource is similar to TCPRoute, but can be configured
// to match against TLS-specific metadata. This allows more flexibility
// in matching streams for a given TLS listener.
//
// If you need to forward traffic to a single target for a TLS listener, you
// could choose to use a TCPRoute with a TLS listener.
type TLSRouteType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	Spec     *TLSRouteSpec      `pulumi:"spec"`
	Status   *TLSRouteStatus    `pulumi:"status"`
}

// TLSRouteTypeInput is an input type that accepts TLSRouteTypeArgs and TLSRouteTypeOutput values.
// You can construct a concrete instance of `TLSRouteTypeInput` via:
//
//	TLSRouteTypeArgs{...}
type TLSRouteTypeInput interface {
	pulumi.Input

	ToTLSRouteTypeOutput() TLSRouteTypeOutput
	ToTLSRouteTypeOutputWithContext(context.Context) TLSRouteTypeOutput
}

// The TLSRoute resource is similar to TCPRoute, but can be configured
// to match against TLS-specific metadata. This allows more flexibility
// in matching streams for a given TLS listener.
//
// If you need to forward traffic to a single target for a TLS listener, you
// could choose to use a TCPRoute with a TLS listener.
type TLSRouteTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	Spec     TLSRouteSpecPtrInput      `pulumi:"spec"`
	Status   TLSRouteStatusPtrInput    `pulumi:"status"`
}

func (TLSRouteTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteType)(nil)).Elem()
}

func (i TLSRouteTypeArgs) ToTLSRouteTypeOutput() TLSRouteTypeOutput {
	return i.ToTLSRouteTypeOutputWithContext(context.Background())
}

func (i TLSRouteTypeArgs) ToTLSRouteTypeOutputWithContext(ctx context.Context) TLSRouteTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteTypeOutput)
}

// TLSRouteTypeArrayInput is an input type that accepts TLSRouteTypeArray and TLSRouteTypeArrayOutput values.
// You can construct a concrete instance of `TLSRouteTypeArrayInput` via:
//
//	TLSRouteTypeArray{ TLSRouteTypeArgs{...} }
type TLSRouteTypeArrayInput interface {
	pulumi.Input

	ToTLSRouteTypeArrayOutput() TLSRouteTypeArrayOutput
	ToTLSRouteTypeArrayOutputWithContext(context.Context) TLSRouteTypeArrayOutput
}

type TLSRouteTypeArray []TLSRouteTypeInput

func (TLSRouteTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteType)(nil)).Elem()
}

func (i TLSRouteTypeArray) ToTLSRouteTypeArrayOutput() TLSRouteTypeArrayOutput {
	return i.ToTLSRouteTypeArrayOutputWithContext(context.Background())
}

func (i TLSRouteTypeArray) ToTLSRouteTypeArrayOutputWithContext(ctx context.Context) TLSRouteTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteTypeArrayOutput)
}

// The TLSRoute resource is similar to TCPRoute, but can be configured
// to match against TLS-specific metadata. This allows more flexibility
// in matching streams for a given TLS listener.
//
// If you need to forward traffic to a single target for a TLS listener, you
// could choose to use a TCPRoute with a TLS listener.
type TLSRouteTypeOutput struct{ *pulumi.OutputState }

func (TLSRouteTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteType)(nil)).Elem()
}

func (o TLSRouteTypeOutput) ToTLSRouteTypeOutput() TLSRouteTypeOutput {
	return o
}

func (o TLSRouteTypeOutput) ToTLSRouteTypeOutputWithContext(ctx context.Context) TLSRouteTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o TLSRouteTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o TLSRouteTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o TLSRouteTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v TLSRouteType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o TLSRouteTypeOutput) Spec() TLSRouteSpecPtrOutput {
	return o.ApplyT(func(v TLSRouteType) *TLSRouteSpec { return v.Spec }).(TLSRouteSpecPtrOutput)
}

func (o TLSRouteTypeOutput) Status() TLSRouteStatusPtrOutput {
	return o.ApplyT(func(v TLSRouteType) *TLSRouteStatus { return v.Status }).(TLSRouteStatusPtrOutput)
}

type TLSRouteTypeArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteType)(nil)).Elem()
}

func (o TLSRouteTypeArrayOutput) ToTLSRouteTypeArrayOutput() TLSRouteTypeArrayOutput {
	return o
}

func (o TLSRouteTypeArrayOutput) ToTLSRouteTypeArrayOutputWithContext(ctx context.Context) TLSRouteTypeArrayOutput {
	return o
}

func (o TLSRouteTypeArrayOutput) Index(i pulumi.IntInput) TLSRouteTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteType {
		return vs[0].([]TLSRouteType)[vs[1].(int)]
	}).(TLSRouteTypeOutput)
}

// TLSRouteList is a list of TLSRoute
type TLSRouteListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of tlsroutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []TLSRouteType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// TLSRouteListTypeInput is an input type that accepts TLSRouteListTypeArgs and TLSRouteListTypeOutput values.
// You can construct a concrete instance of `TLSRouteListTypeInput` via:
//
//	TLSRouteListTypeArgs{...}
type TLSRouteListTypeInput interface {
	pulumi.Input

	ToTLSRouteListTypeOutput() TLSRouteListTypeOutput
	ToTLSRouteListTypeOutputWithContext(context.Context) TLSRouteListTypeOutput
}

// TLSRouteList is a list of TLSRoute
type TLSRouteListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of tlsroutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items TLSRouteTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (TLSRouteListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteListType)(nil)).Elem()
}

func (i TLSRouteListTypeArgs) ToTLSRouteListTypeOutput() TLSRouteListTypeOutput {
	return i.ToTLSRouteListTypeOutputWithContext(context.Background())
}

func (i TLSRouteListTypeArgs) ToTLSRouteListTypeOutputWithContext(ctx context.Context) TLSRouteListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteListTypeOutput)
}

// TLSRouteList is a list of TLSRoute
type TLSRouteListTypeOutput struct{ *pulumi.OutputState }

func (TLSRouteListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteListType)(nil)).Elem()
}

func (o TLSRouteListTypeOutput) ToTLSRouteListTypeOutput() TLSRouteListTypeOutput {
	return o
}

func (o TLSRouteListTypeOutput) ToTLSRouteListTypeOutputWithContext(ctx context.Context) TLSRouteListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o TLSRouteListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of tlsroutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o TLSRouteListTypeOutput) Items() TLSRouteTypeArrayOutput {
	return o.ApplyT(func(v TLSRouteListType) []TLSRouteType { return v.Items }).(TLSRouteTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o TLSRouteListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o TLSRouteListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v TLSRouteListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// The TLSRoute resource is similar to TCPRoute, but can be configured
// to match against TLS-specific metadata. This allows more flexibility
// in matching streams for a given TLS listener.
//
// If you need to forward traffic to a single target for a TLS listener, you
// could choose to use a TCPRoute with a TLS listener.
type TLSRoutePatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	Spec     *TLSRouteSpecPatch      `pulumi:"spec"`
	Status   *TLSRouteStatusPatch    `pulumi:"status"`
}

// TLSRoutePatchTypeInput is an input type that accepts TLSRoutePatchTypeArgs and TLSRoutePatchTypeOutput values.
// You can construct a concrete instance of `TLSRoutePatchTypeInput` via:
//
//	TLSRoutePatchTypeArgs{...}
type TLSRoutePatchTypeInput interface {
	pulumi.Input

	ToTLSRoutePatchTypeOutput() TLSRoutePatchTypeOutput
	ToTLSRoutePatchTypeOutputWithContext(context.Context) TLSRoutePatchTypeOutput
}

// The TLSRoute resource is similar to TCPRoute, but can be configured
// to match against TLS-specific metadata. This allows more flexibility
// in matching streams for a given TLS listener.
//
// If you need to forward traffic to a single target for a TLS listener, you
// could choose to use a TCPRoute with a TLS listener.
type TLSRoutePatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	Spec     TLSRouteSpecPatchPtrInput      `pulumi:"spec"`
	Status   TLSRouteStatusPatchPtrInput    `pulumi:"status"`
}

func (TLSRoutePatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRoutePatchType)(nil)).Elem()
}

func (i TLSRoutePatchTypeArgs) ToTLSRoutePatchTypeOutput() TLSRoutePatchTypeOutput {
	return i.ToTLSRoutePatchTypeOutputWithContext(context.Background())
}

func (i TLSRoutePatchTypeArgs) ToTLSRoutePatchTypeOutputWithContext(ctx context.Context) TLSRoutePatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRoutePatchTypeOutput)
}

// The TLSRoute resource is similar to TCPRoute, but can be configured
// to match against TLS-specific metadata. This allows more flexibility
// in matching streams for a given TLS listener.
//
// If you need to forward traffic to a single target for a TLS listener, you
// could choose to use a TCPRoute with a TLS listener.
type TLSRoutePatchTypeOutput struct{ *pulumi.OutputState }

func (TLSRoutePatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRoutePatchType)(nil)).Elem()
}

func (o TLSRoutePatchTypeOutput) ToTLSRoutePatchTypeOutput() TLSRoutePatchTypeOutput {
	return o
}

func (o TLSRoutePatchTypeOutput) ToTLSRoutePatchTypeOutputWithContext(ctx context.Context) TLSRoutePatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o TLSRoutePatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRoutePatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o TLSRoutePatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRoutePatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o TLSRoutePatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v TLSRoutePatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o TLSRoutePatchTypeOutput) Spec() TLSRouteSpecPatchPtrOutput {
	return o.ApplyT(func(v TLSRoutePatchType) *TLSRouteSpecPatch { return v.Spec }).(TLSRouteSpecPatchPtrOutput)
}

func (o TLSRoutePatchTypeOutput) Status() TLSRouteStatusPatchPtrOutput {
	return o.ApplyT(func(v TLSRoutePatchType) *TLSRouteStatusPatch { return v.Status }).(TLSRouteStatusPatchPtrOutput)
}

// Spec defines the desired state of TLSRoute.
type TLSRouteSpec struct {
	// Hostnames defines a set of SNI names that should match against the
	// SNI attribute of TLS ClientHello message in TLS handshake. This matches
	// the RFC 1123 definition of a hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed in SNI names per RFC 6066.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label must appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and TLSRoute, there
	// must be at least one intersecting hostname for the TLSRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches TLSRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches TLSRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `test.example.com` and `*.example.com` would both match. On the other
	//   hand, `example.com` and `test.example.net` would not match.
	//
	// If both the Listener and TLSRoute have specified hostnames, any
	// TLSRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// TLSRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` must not be considered for a match.
	//
	// If both the Listener and TLSRoute have specified hostnames, and none
	// match with the criteria above, then the TLSRoute is not accepted. The
	// implementation must raise an 'Accepted' Condition with a status of
	// `False` in the corresponding RouteParentStatus.
	//
	// Support: Core
	Hostnames []string `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	ParentRefs []TLSRouteSpecParentRefs `pulumi:"parentRefs"`
	// Rules are a list of TLS matchers and actions.
	Rules []TLSRouteSpecRules `pulumi:"rules"`
}

// TLSRouteSpecInput is an input type that accepts TLSRouteSpecArgs and TLSRouteSpecOutput values.
// You can construct a concrete instance of `TLSRouteSpecInput` via:
//
//	TLSRouteSpecArgs{...}
type TLSRouteSpecInput interface {
	pulumi.Input

	ToTLSRouteSpecOutput() TLSRouteSpecOutput
	ToTLSRouteSpecOutputWithContext(context.Context) TLSRouteSpecOutput
}

// Spec defines the desired state of TLSRoute.
type TLSRouteSpecArgs struct {
	// Hostnames defines a set of SNI names that should match against the
	// SNI attribute of TLS ClientHello message in TLS handshake. This matches
	// the RFC 1123 definition of a hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed in SNI names per RFC 6066.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label must appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and TLSRoute, there
	// must be at least one intersecting hostname for the TLSRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches TLSRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches TLSRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `test.example.com` and `*.example.com` would both match. On the other
	//   hand, `example.com` and `test.example.net` would not match.
	//
	// If both the Listener and TLSRoute have specified hostnames, any
	// TLSRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// TLSRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` must not be considered for a match.
	//
	// If both the Listener and TLSRoute have specified hostnames, and none
	// match with the criteria above, then the TLSRoute is not accepted. The
	// implementation must raise an 'Accepted' Condition with a status of
	// `False` in the corresponding RouteParentStatus.
	//
	// Support: Core
	Hostnames pulumi.StringArrayInput `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	ParentRefs TLSRouteSpecParentRefsArrayInput `pulumi:"parentRefs"`
	// Rules are a list of TLS matchers and actions.
	Rules TLSRouteSpecRulesArrayInput `pulumi:"rules"`
}

func (TLSRouteSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpec)(nil)).Elem()
}

func (i TLSRouteSpecArgs) ToTLSRouteSpecOutput() TLSRouteSpecOutput {
	return i.ToTLSRouteSpecOutputWithContext(context.Background())
}

func (i TLSRouteSpecArgs) ToTLSRouteSpecOutputWithContext(ctx context.Context) TLSRouteSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecOutput)
}

func (i TLSRouteSpecArgs) ToTLSRouteSpecPtrOutput() TLSRouteSpecPtrOutput {
	return i.ToTLSRouteSpecPtrOutputWithContext(context.Background())
}

func (i TLSRouteSpecArgs) ToTLSRouteSpecPtrOutputWithContext(ctx context.Context) TLSRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecOutput).ToTLSRouteSpecPtrOutputWithContext(ctx)
}

// TLSRouteSpecPtrInput is an input type that accepts TLSRouteSpecArgs, TLSRouteSpecPtr and TLSRouteSpecPtrOutput values.
// You can construct a concrete instance of `TLSRouteSpecPtrInput` via:
//
//	        TLSRouteSpecArgs{...}
//
//	or:
//
//	        nil
type TLSRouteSpecPtrInput interface {
	pulumi.Input

	ToTLSRouteSpecPtrOutput() TLSRouteSpecPtrOutput
	ToTLSRouteSpecPtrOutputWithContext(context.Context) TLSRouteSpecPtrOutput
}

type tlsrouteSpecPtrType TLSRouteSpecArgs

func TLSRouteSpecPtr(v *TLSRouteSpecArgs) TLSRouteSpecPtrInput {
	return (*tlsrouteSpecPtrType)(v)
}

func (*tlsrouteSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteSpec)(nil)).Elem()
}

func (i *tlsrouteSpecPtrType) ToTLSRouteSpecPtrOutput() TLSRouteSpecPtrOutput {
	return i.ToTLSRouteSpecPtrOutputWithContext(context.Background())
}

func (i *tlsrouteSpecPtrType) ToTLSRouteSpecPtrOutputWithContext(ctx context.Context) TLSRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecPtrOutput)
}

// Spec defines the desired state of TLSRoute.
type TLSRouteSpecOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpec)(nil)).Elem()
}

func (o TLSRouteSpecOutput) ToTLSRouteSpecOutput() TLSRouteSpecOutput {
	return o
}

func (o TLSRouteSpecOutput) ToTLSRouteSpecOutputWithContext(ctx context.Context) TLSRouteSpecOutput {
	return o
}

func (o TLSRouteSpecOutput) ToTLSRouteSpecPtrOutput() TLSRouteSpecPtrOutput {
	return o.ToTLSRouteSpecPtrOutputWithContext(context.Background())
}

func (o TLSRouteSpecOutput) ToTLSRouteSpecPtrOutputWithContext(ctx context.Context) TLSRouteSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TLSRouteSpec) *TLSRouteSpec {
		return &v
	}).(TLSRouteSpecPtrOutput)
}

// Hostnames defines a set of SNI names that should match against the
// SNI attribute of TLS ClientHello message in TLS handshake. This matches
// the RFC 1123 definition of a hostname with 2 notable exceptions:
//
//  1. IPs are not allowed in SNI names per RFC 6066.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label must appear by itself as the first label.
//
// If a hostname is specified by both the Listener and TLSRoute, there
// must be at least one intersecting hostname for the TLSRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches TLSRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches TLSRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `test.example.com` and `*.example.com` would both match. On the other
//     hand, `example.com` and `test.example.net` would not match.
//
// If both the Listener and TLSRoute have specified hostnames, any
// TLSRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// TLSRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` must not be considered for a match.
//
// If both the Listener and TLSRoute have specified hostnames, and none
// match with the criteria above, then the TLSRoute is not accepted. The
// implementation must raise an 'Accepted' Condition with a status of
// `False` in the corresponding RouteParentStatus.
//
// Support: Core
func (o TLSRouteSpecOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TLSRouteSpec) []string { return v.Hostnames }).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
func (o TLSRouteSpecOutput) ParentRefs() TLSRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v TLSRouteSpec) []TLSRouteSpecParentRefs { return v.ParentRefs }).(TLSRouteSpecParentRefsArrayOutput)
}

// Rules are a list of TLS matchers and actions.
func (o TLSRouteSpecOutput) Rules() TLSRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v TLSRouteSpec) []TLSRouteSpecRules { return v.Rules }).(TLSRouteSpecRulesArrayOutput)
}

type TLSRouteSpecPtrOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteSpec)(nil)).Elem()
}

func (o TLSRouteSpecPtrOutput) ToTLSRouteSpecPtrOutput() TLSRouteSpecPtrOutput {
	return o
}

func (o TLSRouteSpecPtrOutput) ToTLSRouteSpecPtrOutputWithContext(ctx context.Context) TLSRouteSpecPtrOutput {
	return o
}

func (o TLSRouteSpecPtrOutput) Elem() TLSRouteSpecOutput {
	return o.ApplyT(func(v *TLSRouteSpec) TLSRouteSpec {
		if v != nil {
			return *v
		}
		var ret TLSRouteSpec
		return ret
	}).(TLSRouteSpecOutput)
}

// Hostnames defines a set of SNI names that should match against the
// SNI attribute of TLS ClientHello message in TLS handshake. This matches
// the RFC 1123 definition of a hostname with 2 notable exceptions:
//
//  1. IPs are not allowed in SNI names per RFC 6066.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label must appear by itself as the first label.
//
// If a hostname is specified by both the Listener and TLSRoute, there
// must be at least one intersecting hostname for the TLSRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches TLSRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches TLSRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `test.example.com` and `*.example.com` would both match. On the other
//     hand, `example.com` and `test.example.net` would not match.
//
// If both the Listener and TLSRoute have specified hostnames, any
// TLSRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// TLSRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` must not be considered for a match.
//
// If both the Listener and TLSRoute have specified hostnames, and none
// match with the criteria above, then the TLSRoute is not accepted. The
// implementation must raise an 'Accepted' Condition with a status of
// `False` in the corresponding RouteParentStatus.
//
// Support: Core
func (o TLSRouteSpecPtrOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TLSRouteSpec) []string {
		if v == nil {
			return nil
		}
		return v.Hostnames
	}).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
func (o TLSRouteSpecPtrOutput) ParentRefs() TLSRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v *TLSRouteSpec) []TLSRouteSpecParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(TLSRouteSpecParentRefsArrayOutput)
}

// Rules are a list of TLS matchers and actions.
func (o TLSRouteSpecPtrOutput) Rules() TLSRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v *TLSRouteSpec) []TLSRouteSpecRules {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(TLSRouteSpecRulesArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type TLSRouteSpecParentRefs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// TLSRouteSpecParentRefsInput is an input type that accepts TLSRouteSpecParentRefsArgs and TLSRouteSpecParentRefsOutput values.
// You can construct a concrete instance of `TLSRouteSpecParentRefsInput` via:
//
//	TLSRouteSpecParentRefsArgs{...}
type TLSRouteSpecParentRefsInput interface {
	pulumi.Input

	ToTLSRouteSpecParentRefsOutput() TLSRouteSpecParentRefsOutput
	ToTLSRouteSpecParentRefsOutputWithContext(context.Context) TLSRouteSpecParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type TLSRouteSpecParentRefsArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (TLSRouteSpecParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecParentRefs)(nil)).Elem()
}

func (i TLSRouteSpecParentRefsArgs) ToTLSRouteSpecParentRefsOutput() TLSRouteSpecParentRefsOutput {
	return i.ToTLSRouteSpecParentRefsOutputWithContext(context.Background())
}

func (i TLSRouteSpecParentRefsArgs) ToTLSRouteSpecParentRefsOutputWithContext(ctx context.Context) TLSRouteSpecParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecParentRefsOutput)
}

// TLSRouteSpecParentRefsArrayInput is an input type that accepts TLSRouteSpecParentRefsArray and TLSRouteSpecParentRefsArrayOutput values.
// You can construct a concrete instance of `TLSRouteSpecParentRefsArrayInput` via:
//
//	TLSRouteSpecParentRefsArray{ TLSRouteSpecParentRefsArgs{...} }
type TLSRouteSpecParentRefsArrayInput interface {
	pulumi.Input

	ToTLSRouteSpecParentRefsArrayOutput() TLSRouteSpecParentRefsArrayOutput
	ToTLSRouteSpecParentRefsArrayOutputWithContext(context.Context) TLSRouteSpecParentRefsArrayOutput
}

type TLSRouteSpecParentRefsArray []TLSRouteSpecParentRefsInput

func (TLSRouteSpecParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecParentRefs)(nil)).Elem()
}

func (i TLSRouteSpecParentRefsArray) ToTLSRouteSpecParentRefsArrayOutput() TLSRouteSpecParentRefsArrayOutput {
	return i.ToTLSRouteSpecParentRefsArrayOutputWithContext(context.Background())
}

func (i TLSRouteSpecParentRefsArray) ToTLSRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) TLSRouteSpecParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type TLSRouteSpecParentRefsOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecParentRefs)(nil)).Elem()
}

func (o TLSRouteSpecParentRefsOutput) ToTLSRouteSpecParentRefsOutput() TLSRouteSpecParentRefsOutput {
	return o
}

func (o TLSRouteSpecParentRefsOutput) ToTLSRouteSpecParentRefsOutputWithContext(ctx context.Context) TLSRouteSpecParentRefsOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o TLSRouteSpecParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o TLSRouteSpecParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o TLSRouteSpecParentRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o TLSRouteSpecParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o TLSRouteSpecParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o TLSRouteSpecParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type TLSRouteSpecParentRefsArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecParentRefs)(nil)).Elem()
}

func (o TLSRouteSpecParentRefsArrayOutput) ToTLSRouteSpecParentRefsArrayOutput() TLSRouteSpecParentRefsArrayOutput {
	return o
}

func (o TLSRouteSpecParentRefsArrayOutput) ToTLSRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) TLSRouteSpecParentRefsArrayOutput {
	return o
}

func (o TLSRouteSpecParentRefsArrayOutput) Index(i pulumi.IntInput) TLSRouteSpecParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteSpecParentRefs {
		return vs[0].([]TLSRouteSpecParentRefs)[vs[1].(int)]
	}).(TLSRouteSpecParentRefsOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type TLSRouteSpecParentRefsPatch struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// TLSRouteSpecParentRefsPatchInput is an input type that accepts TLSRouteSpecParentRefsPatchArgs and TLSRouteSpecParentRefsPatchOutput values.
// You can construct a concrete instance of `TLSRouteSpecParentRefsPatchInput` via:
//
//	TLSRouteSpecParentRefsPatchArgs{...}
type TLSRouteSpecParentRefsPatchInput interface {
	pulumi.Input

	ToTLSRouteSpecParentRefsPatchOutput() TLSRouteSpecParentRefsPatchOutput
	ToTLSRouteSpecParentRefsPatchOutputWithContext(context.Context) TLSRouteSpecParentRefsPatchOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type TLSRouteSpecParentRefsPatchArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (TLSRouteSpecParentRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecParentRefsPatch)(nil)).Elem()
}

func (i TLSRouteSpecParentRefsPatchArgs) ToTLSRouteSpecParentRefsPatchOutput() TLSRouteSpecParentRefsPatchOutput {
	return i.ToTLSRouteSpecParentRefsPatchOutputWithContext(context.Background())
}

func (i TLSRouteSpecParentRefsPatchArgs) ToTLSRouteSpecParentRefsPatchOutputWithContext(ctx context.Context) TLSRouteSpecParentRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecParentRefsPatchOutput)
}

// TLSRouteSpecParentRefsPatchArrayInput is an input type that accepts TLSRouteSpecParentRefsPatchArray and TLSRouteSpecParentRefsPatchArrayOutput values.
// You can construct a concrete instance of `TLSRouteSpecParentRefsPatchArrayInput` via:
//
//	TLSRouteSpecParentRefsPatchArray{ TLSRouteSpecParentRefsPatchArgs{...} }
type TLSRouteSpecParentRefsPatchArrayInput interface {
	pulumi.Input

	ToTLSRouteSpecParentRefsPatchArrayOutput() TLSRouteSpecParentRefsPatchArrayOutput
	ToTLSRouteSpecParentRefsPatchArrayOutputWithContext(context.Context) TLSRouteSpecParentRefsPatchArrayOutput
}

type TLSRouteSpecParentRefsPatchArray []TLSRouteSpecParentRefsPatchInput

func (TLSRouteSpecParentRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecParentRefsPatch)(nil)).Elem()
}

func (i TLSRouteSpecParentRefsPatchArray) ToTLSRouteSpecParentRefsPatchArrayOutput() TLSRouteSpecParentRefsPatchArrayOutput {
	return i.ToTLSRouteSpecParentRefsPatchArrayOutputWithContext(context.Background())
}

func (i TLSRouteSpecParentRefsPatchArray) ToTLSRouteSpecParentRefsPatchArrayOutputWithContext(ctx context.Context) TLSRouteSpecParentRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecParentRefsPatchArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type TLSRouteSpecParentRefsPatchOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecParentRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecParentRefsPatch)(nil)).Elem()
}

func (o TLSRouteSpecParentRefsPatchOutput) ToTLSRouteSpecParentRefsPatchOutput() TLSRouteSpecParentRefsPatchOutput {
	return o
}

func (o TLSRouteSpecParentRefsPatchOutput) ToTLSRouteSpecParentRefsPatchOutputWithContext(ctx context.Context) TLSRouteSpecParentRefsPatchOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o TLSRouteSpecParentRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o TLSRouteSpecParentRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o TLSRouteSpecParentRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o TLSRouteSpecParentRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o TLSRouteSpecParentRefsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o TLSRouteSpecParentRefsPatchOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecParentRefsPatch) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type TLSRouteSpecParentRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecParentRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecParentRefsPatch)(nil)).Elem()
}

func (o TLSRouteSpecParentRefsPatchArrayOutput) ToTLSRouteSpecParentRefsPatchArrayOutput() TLSRouteSpecParentRefsPatchArrayOutput {
	return o
}

func (o TLSRouteSpecParentRefsPatchArrayOutput) ToTLSRouteSpecParentRefsPatchArrayOutputWithContext(ctx context.Context) TLSRouteSpecParentRefsPatchArrayOutput {
	return o
}

func (o TLSRouteSpecParentRefsPatchArrayOutput) Index(i pulumi.IntInput) TLSRouteSpecParentRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteSpecParentRefsPatch {
		return vs[0].([]TLSRouteSpecParentRefsPatch)[vs[1].(int)]
	}).(TLSRouteSpecParentRefsPatchOutput)
}

// Spec defines the desired state of TLSRoute.
type TLSRouteSpecPatch struct {
	// Hostnames defines a set of SNI names that should match against the
	// SNI attribute of TLS ClientHello message in TLS handshake. This matches
	// the RFC 1123 definition of a hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed in SNI names per RFC 6066.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label must appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and TLSRoute, there
	// must be at least one intersecting hostname for the TLSRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches TLSRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches TLSRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `test.example.com` and `*.example.com` would both match. On the other
	//   hand, `example.com` and `test.example.net` would not match.
	//
	// If both the Listener and TLSRoute have specified hostnames, any
	// TLSRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// TLSRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` must not be considered for a match.
	//
	// If both the Listener and TLSRoute have specified hostnames, and none
	// match with the criteria above, then the TLSRoute is not accepted. The
	// implementation must raise an 'Accepted' Condition with a status of
	// `False` in the corresponding RouteParentStatus.
	//
	// Support: Core
	Hostnames []string `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	ParentRefs []TLSRouteSpecParentRefsPatch `pulumi:"parentRefs"`
	// Rules are a list of TLS matchers and actions.
	Rules []TLSRouteSpecRulesPatch `pulumi:"rules"`
}

// TLSRouteSpecPatchInput is an input type that accepts TLSRouteSpecPatchArgs and TLSRouteSpecPatchOutput values.
// You can construct a concrete instance of `TLSRouteSpecPatchInput` via:
//
//	TLSRouteSpecPatchArgs{...}
type TLSRouteSpecPatchInput interface {
	pulumi.Input

	ToTLSRouteSpecPatchOutput() TLSRouteSpecPatchOutput
	ToTLSRouteSpecPatchOutputWithContext(context.Context) TLSRouteSpecPatchOutput
}

// Spec defines the desired state of TLSRoute.
type TLSRouteSpecPatchArgs struct {
	// Hostnames defines a set of SNI names that should match against the
	// SNI attribute of TLS ClientHello message in TLS handshake. This matches
	// the RFC 1123 definition of a hostname with 2 notable exceptions:
	//
	// 1. IPs are not allowed in SNI names per RFC 6066.
	// 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
	//    label must appear by itself as the first label.
	//
	// If a hostname is specified by both the Listener and TLSRoute, there
	// must be at least one intersecting hostname for the TLSRoute to be
	// attached to the Listener. For example:
	//
	// * A Listener with `test.example.com` as the hostname matches TLSRoutes
	//   that have either not specified any hostnames, or have specified at
	//   least one of `test.example.com` or `*.example.com`.
	// * A Listener with `*.example.com` as the hostname matches TLSRoutes
	//   that have either not specified any hostnames or have specified at least
	//   one hostname that matches the Listener hostname. For example,
	//   `test.example.com` and `*.example.com` would both match. On the other
	//   hand, `example.com` and `test.example.net` would not match.
	//
	// If both the Listener and TLSRoute have specified hostnames, any
	// TLSRoute hostnames that do not match the Listener hostname MUST be
	// ignored. For example, if a Listener specified `*.example.com`, and the
	// TLSRoute specified `test.example.com` and `test.example.net`,
	// `test.example.net` must not be considered for a match.
	//
	// If both the Listener and TLSRoute have specified hostnames, and none
	// match with the criteria above, then the TLSRoute is not accepted. The
	// implementation must raise an 'Accepted' Condition with a status of
	// `False` in the corresponding RouteParentStatus.
	//
	// Support: Core
	Hostnames pulumi.StringArrayInput `pulumi:"hostnames"`
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	ParentRefs TLSRouteSpecParentRefsPatchArrayInput `pulumi:"parentRefs"`
	// Rules are a list of TLS matchers and actions.
	Rules TLSRouteSpecRulesPatchArrayInput `pulumi:"rules"`
}

func (TLSRouteSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecPatch)(nil)).Elem()
}

func (i TLSRouteSpecPatchArgs) ToTLSRouteSpecPatchOutput() TLSRouteSpecPatchOutput {
	return i.ToTLSRouteSpecPatchOutputWithContext(context.Background())
}

func (i TLSRouteSpecPatchArgs) ToTLSRouteSpecPatchOutputWithContext(ctx context.Context) TLSRouteSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecPatchOutput)
}

func (i TLSRouteSpecPatchArgs) ToTLSRouteSpecPatchPtrOutput() TLSRouteSpecPatchPtrOutput {
	return i.ToTLSRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (i TLSRouteSpecPatchArgs) ToTLSRouteSpecPatchPtrOutputWithContext(ctx context.Context) TLSRouteSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecPatchOutput).ToTLSRouteSpecPatchPtrOutputWithContext(ctx)
}

// TLSRouteSpecPatchPtrInput is an input type that accepts TLSRouteSpecPatchArgs, TLSRouteSpecPatchPtr and TLSRouteSpecPatchPtrOutput values.
// You can construct a concrete instance of `TLSRouteSpecPatchPtrInput` via:
//
//	        TLSRouteSpecPatchArgs{...}
//
//	or:
//
//	        nil
type TLSRouteSpecPatchPtrInput interface {
	pulumi.Input

	ToTLSRouteSpecPatchPtrOutput() TLSRouteSpecPatchPtrOutput
	ToTLSRouteSpecPatchPtrOutputWithContext(context.Context) TLSRouteSpecPatchPtrOutput
}

type tlsrouteSpecPatchPtrType TLSRouteSpecPatchArgs

func TLSRouteSpecPatchPtr(v *TLSRouteSpecPatchArgs) TLSRouteSpecPatchPtrInput {
	return (*tlsrouteSpecPatchPtrType)(v)
}

func (*tlsrouteSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteSpecPatch)(nil)).Elem()
}

func (i *tlsrouteSpecPatchPtrType) ToTLSRouteSpecPatchPtrOutput() TLSRouteSpecPatchPtrOutput {
	return i.ToTLSRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (i *tlsrouteSpecPatchPtrType) ToTLSRouteSpecPatchPtrOutputWithContext(ctx context.Context) TLSRouteSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecPatchPtrOutput)
}

// Spec defines the desired state of TLSRoute.
type TLSRouteSpecPatchOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecPatch)(nil)).Elem()
}

func (o TLSRouteSpecPatchOutput) ToTLSRouteSpecPatchOutput() TLSRouteSpecPatchOutput {
	return o
}

func (o TLSRouteSpecPatchOutput) ToTLSRouteSpecPatchOutputWithContext(ctx context.Context) TLSRouteSpecPatchOutput {
	return o
}

func (o TLSRouteSpecPatchOutput) ToTLSRouteSpecPatchPtrOutput() TLSRouteSpecPatchPtrOutput {
	return o.ToTLSRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (o TLSRouteSpecPatchOutput) ToTLSRouteSpecPatchPtrOutputWithContext(ctx context.Context) TLSRouteSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TLSRouteSpecPatch) *TLSRouteSpecPatch {
		return &v
	}).(TLSRouteSpecPatchPtrOutput)
}

// Hostnames defines a set of SNI names that should match against the
// SNI attribute of TLS ClientHello message in TLS handshake. This matches
// the RFC 1123 definition of a hostname with 2 notable exceptions:
//
//  1. IPs are not allowed in SNI names per RFC 6066.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label must appear by itself as the first label.
//
// If a hostname is specified by both the Listener and TLSRoute, there
// must be at least one intersecting hostname for the TLSRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches TLSRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches TLSRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `test.example.com` and `*.example.com` would both match. On the other
//     hand, `example.com` and `test.example.net` would not match.
//
// If both the Listener and TLSRoute have specified hostnames, any
// TLSRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// TLSRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` must not be considered for a match.
//
// If both the Listener and TLSRoute have specified hostnames, and none
// match with the criteria above, then the TLSRoute is not accepted. The
// implementation must raise an 'Accepted' Condition with a status of
// `False` in the corresponding RouteParentStatus.
//
// Support: Core
func (o TLSRouteSpecPatchOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v TLSRouteSpecPatch) []string { return v.Hostnames }).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
func (o TLSRouteSpecPatchOutput) ParentRefs() TLSRouteSpecParentRefsPatchArrayOutput {
	return o.ApplyT(func(v TLSRouteSpecPatch) []TLSRouteSpecParentRefsPatch { return v.ParentRefs }).(TLSRouteSpecParentRefsPatchArrayOutput)
}

// Rules are a list of TLS matchers and actions.
func (o TLSRouteSpecPatchOutput) Rules() TLSRouteSpecRulesPatchArrayOutput {
	return o.ApplyT(func(v TLSRouteSpecPatch) []TLSRouteSpecRulesPatch { return v.Rules }).(TLSRouteSpecRulesPatchArrayOutput)
}

type TLSRouteSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteSpecPatch)(nil)).Elem()
}

func (o TLSRouteSpecPatchPtrOutput) ToTLSRouteSpecPatchPtrOutput() TLSRouteSpecPatchPtrOutput {
	return o
}

func (o TLSRouteSpecPatchPtrOutput) ToTLSRouteSpecPatchPtrOutputWithContext(ctx context.Context) TLSRouteSpecPatchPtrOutput {
	return o
}

func (o TLSRouteSpecPatchPtrOutput) Elem() TLSRouteSpecPatchOutput {
	return o.ApplyT(func(v *TLSRouteSpecPatch) TLSRouteSpecPatch {
		if v != nil {
			return *v
		}
		var ret TLSRouteSpecPatch
		return ret
	}).(TLSRouteSpecPatchOutput)
}

// Hostnames defines a set of SNI names that should match against the
// SNI attribute of TLS ClientHello message in TLS handshake. This matches
// the RFC 1123 definition of a hostname with 2 notable exceptions:
//
//  1. IPs are not allowed in SNI names per RFC 6066.
//  2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
//     label must appear by itself as the first label.
//
// If a hostname is specified by both the Listener and TLSRoute, there
// must be at least one intersecting hostname for the TLSRoute to be
// attached to the Listener. For example:
//
//   - A Listener with `test.example.com` as the hostname matches TLSRoutes
//     that have either not specified any hostnames, or have specified at
//     least one of `test.example.com` or `*.example.com`.
//   - A Listener with `*.example.com` as the hostname matches TLSRoutes
//     that have either not specified any hostnames or have specified at least
//     one hostname that matches the Listener hostname. For example,
//     `test.example.com` and `*.example.com` would both match. On the other
//     hand, `example.com` and `test.example.net` would not match.
//
// If both the Listener and TLSRoute have specified hostnames, any
// TLSRoute hostnames that do not match the Listener hostname MUST be
// ignored. For example, if a Listener specified `*.example.com`, and the
// TLSRoute specified `test.example.com` and `test.example.net`,
// `test.example.net` must not be considered for a match.
//
// If both the Listener and TLSRoute have specified hostnames, and none
// match with the criteria above, then the TLSRoute is not accepted. The
// implementation must raise an 'Accepted' Condition with a status of
// `False` in the corresponding RouteParentStatus.
//
// Support: Core
func (o TLSRouteSpecPatchPtrOutput) Hostnames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *TLSRouteSpecPatch) []string {
		if v == nil {
			return nil
		}
		return v.Hostnames
	}).(pulumi.StringArrayOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
func (o TLSRouteSpecPatchPtrOutput) ParentRefs() TLSRouteSpecParentRefsPatchArrayOutput {
	return o.ApplyT(func(v *TLSRouteSpecPatch) []TLSRouteSpecParentRefsPatch {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(TLSRouteSpecParentRefsPatchArrayOutput)
}

// Rules are a list of TLS matchers and actions.
func (o TLSRouteSpecPatchPtrOutput) Rules() TLSRouteSpecRulesPatchArrayOutput {
	return o.ApplyT(func(v *TLSRouteSpecPatch) []TLSRouteSpecRulesPatch {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(TLSRouteSpecRulesPatchArrayOutput)
}

// TLSRouteRule is the configuration for a given rule.
type TLSRouteSpecRules struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent. If unspecified or invalid (refers to a nonexistent resource or
	// a Service with no endpoints), the rule performs no forwarding; if no
	// filters are specified that would result in a response being sent, the
	// underlying implementation must actively reject request attempts to this
	// backend, by rejecting the connection or returning a 500 status code.
	// Request rejections must respect weight; if an invalid backend is
	// requested to have 80% of requests, then 80% of requests must be rejected
	// instead.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Extended
	BackendRefs []TLSRouteSpecRulesBackendRefs `pulumi:"backendRefs"`
	// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
	//
	// Support: Extended
	Name *string `pulumi:"name"`
}

// TLSRouteSpecRulesInput is an input type that accepts TLSRouteSpecRulesArgs and TLSRouteSpecRulesOutput values.
// You can construct a concrete instance of `TLSRouteSpecRulesInput` via:
//
//	TLSRouteSpecRulesArgs{...}
type TLSRouteSpecRulesInput interface {
	pulumi.Input

	ToTLSRouteSpecRulesOutput() TLSRouteSpecRulesOutput
	ToTLSRouteSpecRulesOutputWithContext(context.Context) TLSRouteSpecRulesOutput
}

// TLSRouteRule is the configuration for a given rule.
type TLSRouteSpecRulesArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent. If unspecified or invalid (refers to a nonexistent resource or
	// a Service with no endpoints), the rule performs no forwarding; if no
	// filters are specified that would result in a response being sent, the
	// underlying implementation must actively reject request attempts to this
	// backend, by rejecting the connection or returning a 500 status code.
	// Request rejections must respect weight; if an invalid backend is
	// requested to have 80% of requests, then 80% of requests must be rejected
	// instead.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Extended
	BackendRefs TLSRouteSpecRulesBackendRefsArrayInput `pulumi:"backendRefs"`
	// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
	//
	// Support: Extended
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (TLSRouteSpecRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecRules)(nil)).Elem()
}

func (i TLSRouteSpecRulesArgs) ToTLSRouteSpecRulesOutput() TLSRouteSpecRulesOutput {
	return i.ToTLSRouteSpecRulesOutputWithContext(context.Background())
}

func (i TLSRouteSpecRulesArgs) ToTLSRouteSpecRulesOutputWithContext(ctx context.Context) TLSRouteSpecRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecRulesOutput)
}

// TLSRouteSpecRulesArrayInput is an input type that accepts TLSRouteSpecRulesArray and TLSRouteSpecRulesArrayOutput values.
// You can construct a concrete instance of `TLSRouteSpecRulesArrayInput` via:
//
//	TLSRouteSpecRulesArray{ TLSRouteSpecRulesArgs{...} }
type TLSRouteSpecRulesArrayInput interface {
	pulumi.Input

	ToTLSRouteSpecRulesArrayOutput() TLSRouteSpecRulesArrayOutput
	ToTLSRouteSpecRulesArrayOutputWithContext(context.Context) TLSRouteSpecRulesArrayOutput
}

type TLSRouteSpecRulesArray []TLSRouteSpecRulesInput

func (TLSRouteSpecRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecRules)(nil)).Elem()
}

func (i TLSRouteSpecRulesArray) ToTLSRouteSpecRulesArrayOutput() TLSRouteSpecRulesArrayOutput {
	return i.ToTLSRouteSpecRulesArrayOutputWithContext(context.Background())
}

func (i TLSRouteSpecRulesArray) ToTLSRouteSpecRulesArrayOutputWithContext(ctx context.Context) TLSRouteSpecRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecRulesArrayOutput)
}

// TLSRouteRule is the configuration for a given rule.
type TLSRouteSpecRulesOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecRules)(nil)).Elem()
}

func (o TLSRouteSpecRulesOutput) ToTLSRouteSpecRulesOutput() TLSRouteSpecRulesOutput {
	return o
}

func (o TLSRouteSpecRulesOutput) ToTLSRouteSpecRulesOutputWithContext(ctx context.Context) TLSRouteSpecRulesOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be
// sent. If unspecified or invalid (refers to a nonexistent resource or
// a Service with no endpoints), the rule performs no forwarding; if no
// filters are specified that would result in a response being sent, the
// underlying implementation must actively reject request attempts to this
// backend, by rejecting the connection or returning a 500 status code.
// Request rejections must respect weight; if an invalid backend is
// requested to have 80% of requests, then 80% of requests must be rejected
// instead.
//
// Support: Core for Kubernetes Service
//
// Support: Extended for Kubernetes ServiceImport
//
// Support: Implementation-specific for any other resource
//
// Support for weight: Extended
func (o TLSRouteSpecRulesOutput) BackendRefs() TLSRouteSpecRulesBackendRefsArrayOutput {
	return o.ApplyT(func(v TLSRouteSpecRules) []TLSRouteSpecRulesBackendRefs { return v.BackendRefs }).(TLSRouteSpecRulesBackendRefsArrayOutput)
}

// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
//
// Support: Extended
func (o TLSRouteSpecRulesOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRules) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type TLSRouteSpecRulesArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecRules)(nil)).Elem()
}

func (o TLSRouteSpecRulesArrayOutput) ToTLSRouteSpecRulesArrayOutput() TLSRouteSpecRulesArrayOutput {
	return o
}

func (o TLSRouteSpecRulesArrayOutput) ToTLSRouteSpecRulesArrayOutputWithContext(ctx context.Context) TLSRouteSpecRulesArrayOutput {
	return o
}

func (o TLSRouteSpecRulesArrayOutput) Index(i pulumi.IntInput) TLSRouteSpecRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteSpecRules {
		return vs[0].([]TLSRouteSpecRules)[vs[1].(int)]
	}).(TLSRouteSpecRulesOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type TLSRouteSpecRulesBackendRefs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// TLSRouteSpecRulesBackendRefsInput is an input type that accepts TLSRouteSpecRulesBackendRefsArgs and TLSRouteSpecRulesBackendRefsOutput values.
// You can construct a concrete instance of `TLSRouteSpecRulesBackendRefsInput` via:
//
//	TLSRouteSpecRulesBackendRefsArgs{...}
type TLSRouteSpecRulesBackendRefsInput interface {
	pulumi.Input

	ToTLSRouteSpecRulesBackendRefsOutput() TLSRouteSpecRulesBackendRefsOutput
	ToTLSRouteSpecRulesBackendRefsOutputWithContext(context.Context) TLSRouteSpecRulesBackendRefsOutput
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type TLSRouteSpecRulesBackendRefsArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (TLSRouteSpecRulesBackendRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i TLSRouteSpecRulesBackendRefsArgs) ToTLSRouteSpecRulesBackendRefsOutput() TLSRouteSpecRulesBackendRefsOutput {
	return i.ToTLSRouteSpecRulesBackendRefsOutputWithContext(context.Background())
}

func (i TLSRouteSpecRulesBackendRefsArgs) ToTLSRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) TLSRouteSpecRulesBackendRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecRulesBackendRefsOutput)
}

// TLSRouteSpecRulesBackendRefsArrayInput is an input type that accepts TLSRouteSpecRulesBackendRefsArray and TLSRouteSpecRulesBackendRefsArrayOutput values.
// You can construct a concrete instance of `TLSRouteSpecRulesBackendRefsArrayInput` via:
//
//	TLSRouteSpecRulesBackendRefsArray{ TLSRouteSpecRulesBackendRefsArgs{...} }
type TLSRouteSpecRulesBackendRefsArrayInput interface {
	pulumi.Input

	ToTLSRouteSpecRulesBackendRefsArrayOutput() TLSRouteSpecRulesBackendRefsArrayOutput
	ToTLSRouteSpecRulesBackendRefsArrayOutputWithContext(context.Context) TLSRouteSpecRulesBackendRefsArrayOutput
}

type TLSRouteSpecRulesBackendRefsArray []TLSRouteSpecRulesBackendRefsInput

func (TLSRouteSpecRulesBackendRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i TLSRouteSpecRulesBackendRefsArray) ToTLSRouteSpecRulesBackendRefsArrayOutput() TLSRouteSpecRulesBackendRefsArrayOutput {
	return i.ToTLSRouteSpecRulesBackendRefsArrayOutputWithContext(context.Background())
}

func (i TLSRouteSpecRulesBackendRefsArray) ToTLSRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) TLSRouteSpecRulesBackendRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecRulesBackendRefsArrayOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type TLSRouteSpecRulesBackendRefsOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecRulesBackendRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o TLSRouteSpecRulesBackendRefsOutput) ToTLSRouteSpecRulesBackendRefsOutput() TLSRouteSpecRulesBackendRefsOutput {
	return o
}

func (o TLSRouteSpecRulesBackendRefsOutput) ToTLSRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) TLSRouteSpecRulesBackendRefsOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o TLSRouteSpecRulesBackendRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o TLSRouteSpecRulesBackendRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o TLSRouteSpecRulesBackendRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o TLSRouteSpecRulesBackendRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o TLSRouteSpecRulesBackendRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced
// backend. This is computed as weight/(sum of all weights in this
// BackendRefs list). For non-zero values, there may be some epsilon from
// the exact proportion defined here depending on the precision an
// implementation supports. Weight is not a percentage and the sum of
// weights does not need to equal 100.
//
// If only one backend is specified and it has a weight greater than 0, 100%
// of the traffic is forwarded to that backend. If weight is set to 0, no
// traffic should be forwarded for this entry. If unspecified, weight
// defaults to 1.
//
// Support for this field varies based on the context where used.
func (o TLSRouteSpecRulesBackendRefsOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefs) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type TLSRouteSpecRulesBackendRefsArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecRulesBackendRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o TLSRouteSpecRulesBackendRefsArrayOutput) ToTLSRouteSpecRulesBackendRefsArrayOutput() TLSRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o TLSRouteSpecRulesBackendRefsArrayOutput) ToTLSRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) TLSRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o TLSRouteSpecRulesBackendRefsArrayOutput) Index(i pulumi.IntInput) TLSRouteSpecRulesBackendRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteSpecRulesBackendRefs {
		return vs[0].([]TLSRouteSpecRulesBackendRefs)[vs[1].(int)]
	}).(TLSRouteSpecRulesBackendRefsOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type TLSRouteSpecRulesBackendRefsPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// TLSRouteSpecRulesBackendRefsPatchInput is an input type that accepts TLSRouteSpecRulesBackendRefsPatchArgs and TLSRouteSpecRulesBackendRefsPatchOutput values.
// You can construct a concrete instance of `TLSRouteSpecRulesBackendRefsPatchInput` via:
//
//	TLSRouteSpecRulesBackendRefsPatchArgs{...}
type TLSRouteSpecRulesBackendRefsPatchInput interface {
	pulumi.Input

	ToTLSRouteSpecRulesBackendRefsPatchOutput() TLSRouteSpecRulesBackendRefsPatchOutput
	ToTLSRouteSpecRulesBackendRefsPatchOutputWithContext(context.Context) TLSRouteSpecRulesBackendRefsPatchOutput
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type TLSRouteSpecRulesBackendRefsPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (TLSRouteSpecRulesBackendRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (i TLSRouteSpecRulesBackendRefsPatchArgs) ToTLSRouteSpecRulesBackendRefsPatchOutput() TLSRouteSpecRulesBackendRefsPatchOutput {
	return i.ToTLSRouteSpecRulesBackendRefsPatchOutputWithContext(context.Background())
}

func (i TLSRouteSpecRulesBackendRefsPatchArgs) ToTLSRouteSpecRulesBackendRefsPatchOutputWithContext(ctx context.Context) TLSRouteSpecRulesBackendRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecRulesBackendRefsPatchOutput)
}

// TLSRouteSpecRulesBackendRefsPatchArrayInput is an input type that accepts TLSRouteSpecRulesBackendRefsPatchArray and TLSRouteSpecRulesBackendRefsPatchArrayOutput values.
// You can construct a concrete instance of `TLSRouteSpecRulesBackendRefsPatchArrayInput` via:
//
//	TLSRouteSpecRulesBackendRefsPatchArray{ TLSRouteSpecRulesBackendRefsPatchArgs{...} }
type TLSRouteSpecRulesBackendRefsPatchArrayInput interface {
	pulumi.Input

	ToTLSRouteSpecRulesBackendRefsPatchArrayOutput() TLSRouteSpecRulesBackendRefsPatchArrayOutput
	ToTLSRouteSpecRulesBackendRefsPatchArrayOutputWithContext(context.Context) TLSRouteSpecRulesBackendRefsPatchArrayOutput
}

type TLSRouteSpecRulesBackendRefsPatchArray []TLSRouteSpecRulesBackendRefsPatchInput

func (TLSRouteSpecRulesBackendRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (i TLSRouteSpecRulesBackendRefsPatchArray) ToTLSRouteSpecRulesBackendRefsPatchArrayOutput() TLSRouteSpecRulesBackendRefsPatchArrayOutput {
	return i.ToTLSRouteSpecRulesBackendRefsPatchArrayOutputWithContext(context.Background())
}

func (i TLSRouteSpecRulesBackendRefsPatchArray) ToTLSRouteSpecRulesBackendRefsPatchArrayOutputWithContext(ctx context.Context) TLSRouteSpecRulesBackendRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecRulesBackendRefsPatchArrayOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type TLSRouteSpecRulesBackendRefsPatchOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecRulesBackendRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (o TLSRouteSpecRulesBackendRefsPatchOutput) ToTLSRouteSpecRulesBackendRefsPatchOutput() TLSRouteSpecRulesBackendRefsPatchOutput {
	return o
}

func (o TLSRouteSpecRulesBackendRefsPatchOutput) ToTLSRouteSpecRulesBackendRefsPatchOutputWithContext(ctx context.Context) TLSRouteSpecRulesBackendRefsPatchOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o TLSRouteSpecRulesBackendRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o TLSRouteSpecRulesBackendRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o TLSRouteSpecRulesBackendRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o TLSRouteSpecRulesBackendRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o TLSRouteSpecRulesBackendRefsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced
// backend. This is computed as weight/(sum of all weights in this
// BackendRefs list). For non-zero values, there may be some epsilon from
// the exact proportion defined here depending on the precision an
// implementation supports. Weight is not a percentage and the sum of
// weights does not need to equal 100.
//
// If only one backend is specified and it has a weight greater than 0, 100%
// of the traffic is forwarded to that backend. If weight is set to 0, no
// traffic should be forwarded for this entry. If unspecified, weight
// defaults to 1.
//
// Support for this field varies based on the context where used.
func (o TLSRouteSpecRulesBackendRefsPatchOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesBackendRefsPatch) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type TLSRouteSpecRulesBackendRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecRulesBackendRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (o TLSRouteSpecRulesBackendRefsPatchArrayOutput) ToTLSRouteSpecRulesBackendRefsPatchArrayOutput() TLSRouteSpecRulesBackendRefsPatchArrayOutput {
	return o
}

func (o TLSRouteSpecRulesBackendRefsPatchArrayOutput) ToTLSRouteSpecRulesBackendRefsPatchArrayOutputWithContext(ctx context.Context) TLSRouteSpecRulesBackendRefsPatchArrayOutput {
	return o
}

func (o TLSRouteSpecRulesBackendRefsPatchArrayOutput) Index(i pulumi.IntInput) TLSRouteSpecRulesBackendRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteSpecRulesBackendRefsPatch {
		return vs[0].([]TLSRouteSpecRulesBackendRefsPatch)[vs[1].(int)]
	}).(TLSRouteSpecRulesBackendRefsPatchOutput)
}

// TLSRouteRule is the configuration for a given rule.
type TLSRouteSpecRulesPatch struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent. If unspecified or invalid (refers to a nonexistent resource or
	// a Service with no endpoints), the rule performs no forwarding; if no
	// filters are specified that would result in a response being sent, the
	// underlying implementation must actively reject request attempts to this
	// backend, by rejecting the connection or returning a 500 status code.
	// Request rejections must respect weight; if an invalid backend is
	// requested to have 80% of requests, then 80% of requests must be rejected
	// instead.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Extended
	BackendRefs []TLSRouteSpecRulesBackendRefsPatch `pulumi:"backendRefs"`
	// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
	//
	// Support: Extended
	Name *string `pulumi:"name"`
}

// TLSRouteSpecRulesPatchInput is an input type that accepts TLSRouteSpecRulesPatchArgs and TLSRouteSpecRulesPatchOutput values.
// You can construct a concrete instance of `TLSRouteSpecRulesPatchInput` via:
//
//	TLSRouteSpecRulesPatchArgs{...}
type TLSRouteSpecRulesPatchInput interface {
	pulumi.Input

	ToTLSRouteSpecRulesPatchOutput() TLSRouteSpecRulesPatchOutput
	ToTLSRouteSpecRulesPatchOutputWithContext(context.Context) TLSRouteSpecRulesPatchOutput
}

// TLSRouteRule is the configuration for a given rule.
type TLSRouteSpecRulesPatchArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent. If unspecified or invalid (refers to a nonexistent resource or
	// a Service with no endpoints), the rule performs no forwarding; if no
	// filters are specified that would result in a response being sent, the
	// underlying implementation must actively reject request attempts to this
	// backend, by rejecting the connection or returning a 500 status code.
	// Request rejections must respect weight; if an invalid backend is
	// requested to have 80% of requests, then 80% of requests must be rejected
	// instead.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Extended
	BackendRefs TLSRouteSpecRulesBackendRefsPatchArrayInput `pulumi:"backendRefs"`
	// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
	//
	// Support: Extended
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (TLSRouteSpecRulesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecRulesPatch)(nil)).Elem()
}

func (i TLSRouteSpecRulesPatchArgs) ToTLSRouteSpecRulesPatchOutput() TLSRouteSpecRulesPatchOutput {
	return i.ToTLSRouteSpecRulesPatchOutputWithContext(context.Background())
}

func (i TLSRouteSpecRulesPatchArgs) ToTLSRouteSpecRulesPatchOutputWithContext(ctx context.Context) TLSRouteSpecRulesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecRulesPatchOutput)
}

// TLSRouteSpecRulesPatchArrayInput is an input type that accepts TLSRouteSpecRulesPatchArray and TLSRouteSpecRulesPatchArrayOutput values.
// You can construct a concrete instance of `TLSRouteSpecRulesPatchArrayInput` via:
//
//	TLSRouteSpecRulesPatchArray{ TLSRouteSpecRulesPatchArgs{...} }
type TLSRouteSpecRulesPatchArrayInput interface {
	pulumi.Input

	ToTLSRouteSpecRulesPatchArrayOutput() TLSRouteSpecRulesPatchArrayOutput
	ToTLSRouteSpecRulesPatchArrayOutputWithContext(context.Context) TLSRouteSpecRulesPatchArrayOutput
}

type TLSRouteSpecRulesPatchArray []TLSRouteSpecRulesPatchInput

func (TLSRouteSpecRulesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecRulesPatch)(nil)).Elem()
}

func (i TLSRouteSpecRulesPatchArray) ToTLSRouteSpecRulesPatchArrayOutput() TLSRouteSpecRulesPatchArrayOutput {
	return i.ToTLSRouteSpecRulesPatchArrayOutputWithContext(context.Background())
}

func (i TLSRouteSpecRulesPatchArray) ToTLSRouteSpecRulesPatchArrayOutputWithContext(ctx context.Context) TLSRouteSpecRulesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteSpecRulesPatchArrayOutput)
}

// TLSRouteRule is the configuration for a given rule.
type TLSRouteSpecRulesPatchOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecRulesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteSpecRulesPatch)(nil)).Elem()
}

func (o TLSRouteSpecRulesPatchOutput) ToTLSRouteSpecRulesPatchOutput() TLSRouteSpecRulesPatchOutput {
	return o
}

func (o TLSRouteSpecRulesPatchOutput) ToTLSRouteSpecRulesPatchOutputWithContext(ctx context.Context) TLSRouteSpecRulesPatchOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be
// sent. If unspecified or invalid (refers to a nonexistent resource or
// a Service with no endpoints), the rule performs no forwarding; if no
// filters are specified that would result in a response being sent, the
// underlying implementation must actively reject request attempts to this
// backend, by rejecting the connection or returning a 500 status code.
// Request rejections must respect weight; if an invalid backend is
// requested to have 80% of requests, then 80% of requests must be rejected
// instead.
//
// Support: Core for Kubernetes Service
//
// Support: Extended for Kubernetes ServiceImport
//
// Support: Implementation-specific for any other resource
//
// Support for weight: Extended
func (o TLSRouteSpecRulesPatchOutput) BackendRefs() TLSRouteSpecRulesBackendRefsPatchArrayOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesPatch) []TLSRouteSpecRulesBackendRefsPatch { return v.BackendRefs }).(TLSRouteSpecRulesBackendRefsPatchArrayOutput)
}

// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
//
// Support: Extended
func (o TLSRouteSpecRulesPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteSpecRulesPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type TLSRouteSpecRulesPatchArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteSpecRulesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteSpecRulesPatch)(nil)).Elem()
}

func (o TLSRouteSpecRulesPatchArrayOutput) ToTLSRouteSpecRulesPatchArrayOutput() TLSRouteSpecRulesPatchArrayOutput {
	return o
}

func (o TLSRouteSpecRulesPatchArrayOutput) ToTLSRouteSpecRulesPatchArrayOutputWithContext(ctx context.Context) TLSRouteSpecRulesPatchArrayOutput {
	return o
}

func (o TLSRouteSpecRulesPatchArrayOutput) Index(i pulumi.IntInput) TLSRouteSpecRulesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteSpecRulesPatch {
		return vs[0].([]TLSRouteSpecRulesPatch)[vs[1].(int)]
	}).(TLSRouteSpecRulesPatchOutput)
}

// Status defines the current state of TLSRoute.
type TLSRouteStatus struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents []TLSRouteStatusParents `pulumi:"parents"`
}

// TLSRouteStatusInput is an input type that accepts TLSRouteStatusArgs and TLSRouteStatusOutput values.
// You can construct a concrete instance of `TLSRouteStatusInput` via:
//
//	TLSRouteStatusArgs{...}
type TLSRouteStatusInput interface {
	pulumi.Input

	ToTLSRouteStatusOutput() TLSRouteStatusOutput
	ToTLSRouteStatusOutputWithContext(context.Context) TLSRouteStatusOutput
}

// Status defines the current state of TLSRoute.
type TLSRouteStatusArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents TLSRouteStatusParentsArrayInput `pulumi:"parents"`
}

func (TLSRouteStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatus)(nil)).Elem()
}

func (i TLSRouteStatusArgs) ToTLSRouteStatusOutput() TLSRouteStatusOutput {
	return i.ToTLSRouteStatusOutputWithContext(context.Background())
}

func (i TLSRouteStatusArgs) ToTLSRouteStatusOutputWithContext(ctx context.Context) TLSRouteStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusOutput)
}

func (i TLSRouteStatusArgs) ToTLSRouteStatusPtrOutput() TLSRouteStatusPtrOutput {
	return i.ToTLSRouteStatusPtrOutputWithContext(context.Background())
}

func (i TLSRouteStatusArgs) ToTLSRouteStatusPtrOutputWithContext(ctx context.Context) TLSRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusOutput).ToTLSRouteStatusPtrOutputWithContext(ctx)
}

// TLSRouteStatusPtrInput is an input type that accepts TLSRouteStatusArgs, TLSRouteStatusPtr and TLSRouteStatusPtrOutput values.
// You can construct a concrete instance of `TLSRouteStatusPtrInput` via:
//
//	        TLSRouteStatusArgs{...}
//
//	or:
//
//	        nil
type TLSRouteStatusPtrInput interface {
	pulumi.Input

	ToTLSRouteStatusPtrOutput() TLSRouteStatusPtrOutput
	ToTLSRouteStatusPtrOutputWithContext(context.Context) TLSRouteStatusPtrOutput
}

type tlsrouteStatusPtrType TLSRouteStatusArgs

func TLSRouteStatusPtr(v *TLSRouteStatusArgs) TLSRouteStatusPtrInput {
	return (*tlsrouteStatusPtrType)(v)
}

func (*tlsrouteStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteStatus)(nil)).Elem()
}

func (i *tlsrouteStatusPtrType) ToTLSRouteStatusPtrOutput() TLSRouteStatusPtrOutput {
	return i.ToTLSRouteStatusPtrOutputWithContext(context.Background())
}

func (i *tlsrouteStatusPtrType) ToTLSRouteStatusPtrOutputWithContext(ctx context.Context) TLSRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusPtrOutput)
}

// Status defines the current state of TLSRoute.
type TLSRouteStatusOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatus)(nil)).Elem()
}

func (o TLSRouteStatusOutput) ToTLSRouteStatusOutput() TLSRouteStatusOutput {
	return o
}

func (o TLSRouteStatusOutput) ToTLSRouteStatusOutputWithContext(ctx context.Context) TLSRouteStatusOutput {
	return o
}

func (o TLSRouteStatusOutput) ToTLSRouteStatusPtrOutput() TLSRouteStatusPtrOutput {
	return o.ToTLSRouteStatusPtrOutputWithContext(context.Background())
}

func (o TLSRouteStatusOutput) ToTLSRouteStatusPtrOutputWithContext(ctx context.Context) TLSRouteStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TLSRouteStatus) *TLSRouteStatus {
		return &v
	}).(TLSRouteStatusPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o TLSRouteStatusOutput) Parents() TLSRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v TLSRouteStatus) []TLSRouteStatusParents { return v.Parents }).(TLSRouteStatusParentsArrayOutput)
}

type TLSRouteStatusPtrOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteStatus)(nil)).Elem()
}

func (o TLSRouteStatusPtrOutput) ToTLSRouteStatusPtrOutput() TLSRouteStatusPtrOutput {
	return o
}

func (o TLSRouteStatusPtrOutput) ToTLSRouteStatusPtrOutputWithContext(ctx context.Context) TLSRouteStatusPtrOutput {
	return o
}

func (o TLSRouteStatusPtrOutput) Elem() TLSRouteStatusOutput {
	return o.ApplyT(func(v *TLSRouteStatus) TLSRouteStatus {
		if v != nil {
			return *v
		}
		var ret TLSRouteStatus
		return ret
	}).(TLSRouteStatusOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o TLSRouteStatusPtrOutput) Parents() TLSRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v *TLSRouteStatus) []TLSRouteStatusParents {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(TLSRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type TLSRouteStatusParents struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a nonexistent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions []TLSRouteStatusParentsConditions `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName *string                         `pulumi:"controllerName"`
	ParentRef      *TLSRouteStatusParentsParentRef `pulumi:"parentRef"`
}

// TLSRouteStatusParentsInput is an input type that accepts TLSRouteStatusParentsArgs and TLSRouteStatusParentsOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsInput` via:
//
//	TLSRouteStatusParentsArgs{...}
type TLSRouteStatusParentsInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsOutput() TLSRouteStatusParentsOutput
	ToTLSRouteStatusParentsOutputWithContext(context.Context) TLSRouteStatusParentsOutput
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type TLSRouteStatusParentsArgs struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a nonexistent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions TLSRouteStatusParentsConditionsArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringPtrInput                  `pulumi:"controllerName"`
	ParentRef      TLSRouteStatusParentsParentRefPtrInput `pulumi:"parentRef"`
}

func (TLSRouteStatusParentsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParents)(nil)).Elem()
}

func (i TLSRouteStatusParentsArgs) ToTLSRouteStatusParentsOutput() TLSRouteStatusParentsOutput {
	return i.ToTLSRouteStatusParentsOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsArgs) ToTLSRouteStatusParentsOutputWithContext(ctx context.Context) TLSRouteStatusParentsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsOutput)
}

// TLSRouteStatusParentsArrayInput is an input type that accepts TLSRouteStatusParentsArray and TLSRouteStatusParentsArrayOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsArrayInput` via:
//
//	TLSRouteStatusParentsArray{ TLSRouteStatusParentsArgs{...} }
type TLSRouteStatusParentsArrayInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsArrayOutput() TLSRouteStatusParentsArrayOutput
	ToTLSRouteStatusParentsArrayOutputWithContext(context.Context) TLSRouteStatusParentsArrayOutput
}

type TLSRouteStatusParentsArray []TLSRouteStatusParentsInput

func (TLSRouteStatusParentsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteStatusParents)(nil)).Elem()
}

func (i TLSRouteStatusParentsArray) ToTLSRouteStatusParentsArrayOutput() TLSRouteStatusParentsArrayOutput {
	return i.ToTLSRouteStatusParentsArrayOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsArray) ToTLSRouteStatusParentsArrayOutputWithContext(ctx context.Context) TLSRouteStatusParentsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type TLSRouteStatusParentsOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParents)(nil)).Elem()
}

func (o TLSRouteStatusParentsOutput) ToTLSRouteStatusParentsOutput() TLSRouteStatusParentsOutput {
	return o
}

func (o TLSRouteStatusParentsOutput) ToTLSRouteStatusParentsOutputWithContext(ctx context.Context) TLSRouteStatusParentsOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway.
// Note that the route's availability is also subject to the Gateway's own
// status conditions and listener status.
//
// If the Route's ParentRef specifies an existing Gateway that supports
// Routes of this kind AND that Gateway's controller has sufficient access,
// then that Gateway's controller MUST set the "Accepted" condition on the
// Route, to indicate whether the route has been accepted or rejected by the
// Gateway, and why.
//
// A Route MUST be considered "Accepted" if at least one of the Route's
// rules is implemented by the Gateway.
//
// There are a number of cases where the "Accepted" condition may not be set
// due to lack of controller visibility, that includes when:
//
// * The Route refers to a nonexistent parent.
// * The Route is of a type that the controller does not support.
// * The Route is in a namespace the controller does not have access to.
func (o TLSRouteStatusParentsOutput) Conditions() TLSRouteStatusParentsConditionsArrayOutput {
	return o.ApplyT(func(v TLSRouteStatusParents) []TLSRouteStatusParentsConditions { return v.Conditions }).(TLSRouteStatusParentsConditionsArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o TLSRouteStatusParentsOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParents) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

func (o TLSRouteStatusParentsOutput) ParentRef() TLSRouteStatusParentsParentRefPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParents) *TLSRouteStatusParentsParentRef { return v.ParentRef }).(TLSRouteStatusParentsParentRefPtrOutput)
}

type TLSRouteStatusParentsArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteStatusParents)(nil)).Elem()
}

func (o TLSRouteStatusParentsArrayOutput) ToTLSRouteStatusParentsArrayOutput() TLSRouteStatusParentsArrayOutput {
	return o
}

func (o TLSRouteStatusParentsArrayOutput) ToTLSRouteStatusParentsArrayOutputWithContext(ctx context.Context) TLSRouteStatusParentsArrayOutput {
	return o
}

func (o TLSRouteStatusParentsArrayOutput) Index(i pulumi.IntInput) TLSRouteStatusParentsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteStatusParents {
		return vs[0].([]TLSRouteStatusParents)[vs[1].(int)]
	}).(TLSRouteStatusParentsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type TLSRouteStatusParentsConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type *string `pulumi:"type"`
}

// TLSRouteStatusParentsConditionsInput is an input type that accepts TLSRouteStatusParentsConditionsArgs and TLSRouteStatusParentsConditionsOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsConditionsInput` via:
//
//	TLSRouteStatusParentsConditionsArgs{...}
type TLSRouteStatusParentsConditionsInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsConditionsOutput() TLSRouteStatusParentsConditionsOutput
	ToTLSRouteStatusParentsConditionsOutputWithContext(context.Context) TLSRouteStatusParentsConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
type TLSRouteStatusParentsConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (TLSRouteStatusParentsConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParentsConditions)(nil)).Elem()
}

func (i TLSRouteStatusParentsConditionsArgs) ToTLSRouteStatusParentsConditionsOutput() TLSRouteStatusParentsConditionsOutput {
	return i.ToTLSRouteStatusParentsConditionsOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsConditionsArgs) ToTLSRouteStatusParentsConditionsOutputWithContext(ctx context.Context) TLSRouteStatusParentsConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsConditionsOutput)
}

// TLSRouteStatusParentsConditionsArrayInput is an input type that accepts TLSRouteStatusParentsConditionsArray and TLSRouteStatusParentsConditionsArrayOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsConditionsArrayInput` via:
//
//	TLSRouteStatusParentsConditionsArray{ TLSRouteStatusParentsConditionsArgs{...} }
type TLSRouteStatusParentsConditionsArrayInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsConditionsArrayOutput() TLSRouteStatusParentsConditionsArrayOutput
	ToTLSRouteStatusParentsConditionsArrayOutputWithContext(context.Context) TLSRouteStatusParentsConditionsArrayOutput
}

type TLSRouteStatusParentsConditionsArray []TLSRouteStatusParentsConditionsInput

func (TLSRouteStatusParentsConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteStatusParentsConditions)(nil)).Elem()
}

func (i TLSRouteStatusParentsConditionsArray) ToTLSRouteStatusParentsConditionsArrayOutput() TLSRouteStatusParentsConditionsArrayOutput {
	return i.ToTLSRouteStatusParentsConditionsArrayOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsConditionsArray) ToTLSRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) TLSRouteStatusParentsConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type TLSRouteStatusParentsConditionsOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParentsConditions)(nil)).Elem()
}

func (o TLSRouteStatusParentsConditionsOutput) ToTLSRouteStatusParentsConditionsOutput() TLSRouteStatusParentsConditionsOutput {
	return o
}

func (o TLSRouteStatusParentsConditionsOutput) ToTLSRouteStatusParentsConditionsOutputWithContext(ctx context.Context) TLSRouteStatusParentsConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o TLSRouteStatusParentsConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o TLSRouteStatusParentsConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o TLSRouteStatusParentsConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o TLSRouteStatusParentsConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o TLSRouteStatusParentsConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
func (o TLSRouteStatusParentsConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type TLSRouteStatusParentsConditionsArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteStatusParentsConditions)(nil)).Elem()
}

func (o TLSRouteStatusParentsConditionsArrayOutput) ToTLSRouteStatusParentsConditionsArrayOutput() TLSRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o TLSRouteStatusParentsConditionsArrayOutput) ToTLSRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) TLSRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o TLSRouteStatusParentsConditionsArrayOutput) Index(i pulumi.IntInput) TLSRouteStatusParentsConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteStatusParentsConditions {
		return vs[0].([]TLSRouteStatusParentsConditions)[vs[1].(int)]
	}).(TLSRouteStatusParentsConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type TLSRouteStatusParentsConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type *string `pulumi:"type"`
}

// TLSRouteStatusParentsConditionsPatchInput is an input type that accepts TLSRouteStatusParentsConditionsPatchArgs and TLSRouteStatusParentsConditionsPatchOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsConditionsPatchInput` via:
//
//	TLSRouteStatusParentsConditionsPatchArgs{...}
type TLSRouteStatusParentsConditionsPatchInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsConditionsPatchOutput() TLSRouteStatusParentsConditionsPatchOutput
	ToTLSRouteStatusParentsConditionsPatchOutputWithContext(context.Context) TLSRouteStatusParentsConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
type TLSRouteStatusParentsConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (TLSRouteStatusParentsConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (i TLSRouteStatusParentsConditionsPatchArgs) ToTLSRouteStatusParentsConditionsPatchOutput() TLSRouteStatusParentsConditionsPatchOutput {
	return i.ToTLSRouteStatusParentsConditionsPatchOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsConditionsPatchArgs) ToTLSRouteStatusParentsConditionsPatchOutputWithContext(ctx context.Context) TLSRouteStatusParentsConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsConditionsPatchOutput)
}

// TLSRouteStatusParentsConditionsPatchArrayInput is an input type that accepts TLSRouteStatusParentsConditionsPatchArray and TLSRouteStatusParentsConditionsPatchArrayOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsConditionsPatchArrayInput` via:
//
//	TLSRouteStatusParentsConditionsPatchArray{ TLSRouteStatusParentsConditionsPatchArgs{...} }
type TLSRouteStatusParentsConditionsPatchArrayInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsConditionsPatchArrayOutput() TLSRouteStatusParentsConditionsPatchArrayOutput
	ToTLSRouteStatusParentsConditionsPatchArrayOutputWithContext(context.Context) TLSRouteStatusParentsConditionsPatchArrayOutput
}

type TLSRouteStatusParentsConditionsPatchArray []TLSRouteStatusParentsConditionsPatchInput

func (TLSRouteStatusParentsConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (i TLSRouteStatusParentsConditionsPatchArray) ToTLSRouteStatusParentsConditionsPatchArrayOutput() TLSRouteStatusParentsConditionsPatchArrayOutput {
	return i.ToTLSRouteStatusParentsConditionsPatchArrayOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsConditionsPatchArray) ToTLSRouteStatusParentsConditionsPatchArrayOutputWithContext(ctx context.Context) TLSRouteStatusParentsConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type TLSRouteStatusParentsConditionsPatchOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (o TLSRouteStatusParentsConditionsPatchOutput) ToTLSRouteStatusParentsConditionsPatchOutput() TLSRouteStatusParentsConditionsPatchOutput {
	return o
}

func (o TLSRouteStatusParentsConditionsPatchOutput) ToTLSRouteStatusParentsConditionsPatchOutputWithContext(ctx context.Context) TLSRouteStatusParentsConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o TLSRouteStatusParentsConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o TLSRouteStatusParentsConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o TLSRouteStatusParentsConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o TLSRouteStatusParentsConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o TLSRouteStatusParentsConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
func (o TLSRouteStatusParentsConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type TLSRouteStatusParentsConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (o TLSRouteStatusParentsConditionsPatchArrayOutput) ToTLSRouteStatusParentsConditionsPatchArrayOutput() TLSRouteStatusParentsConditionsPatchArrayOutput {
	return o
}

func (o TLSRouteStatusParentsConditionsPatchArrayOutput) ToTLSRouteStatusParentsConditionsPatchArrayOutputWithContext(ctx context.Context) TLSRouteStatusParentsConditionsPatchArrayOutput {
	return o
}

func (o TLSRouteStatusParentsConditionsPatchArrayOutput) Index(i pulumi.IntInput) TLSRouteStatusParentsConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteStatusParentsConditionsPatch {
		return vs[0].([]TLSRouteStatusParentsConditionsPatch)[vs[1].(int)]
	}).(TLSRouteStatusParentsConditionsPatchOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type TLSRouteStatusParentsParentRef struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// TLSRouteStatusParentsParentRefInput is an input type that accepts TLSRouteStatusParentsParentRefArgs and TLSRouteStatusParentsParentRefOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsParentRefInput` via:
//
//	TLSRouteStatusParentsParentRefArgs{...}
type TLSRouteStatusParentsParentRefInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsParentRefOutput() TLSRouteStatusParentsParentRefOutput
	ToTLSRouteStatusParentsParentRefOutputWithContext(context.Context) TLSRouteStatusParentsParentRefOutput
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type TLSRouteStatusParentsParentRefArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (TLSRouteStatusParentsParentRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParentsParentRef)(nil)).Elem()
}

func (i TLSRouteStatusParentsParentRefArgs) ToTLSRouteStatusParentsParentRefOutput() TLSRouteStatusParentsParentRefOutput {
	return i.ToTLSRouteStatusParentsParentRefOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsParentRefArgs) ToTLSRouteStatusParentsParentRefOutputWithContext(ctx context.Context) TLSRouteStatusParentsParentRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsParentRefOutput)
}

func (i TLSRouteStatusParentsParentRefArgs) ToTLSRouteStatusParentsParentRefPtrOutput() TLSRouteStatusParentsParentRefPtrOutput {
	return i.ToTLSRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsParentRefArgs) ToTLSRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) TLSRouteStatusParentsParentRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsParentRefOutput).ToTLSRouteStatusParentsParentRefPtrOutputWithContext(ctx)
}

// TLSRouteStatusParentsParentRefPtrInput is an input type that accepts TLSRouteStatusParentsParentRefArgs, TLSRouteStatusParentsParentRefPtr and TLSRouteStatusParentsParentRefPtrOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsParentRefPtrInput` via:
//
//	        TLSRouteStatusParentsParentRefArgs{...}
//
//	or:
//
//	        nil
type TLSRouteStatusParentsParentRefPtrInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsParentRefPtrOutput() TLSRouteStatusParentsParentRefPtrOutput
	ToTLSRouteStatusParentsParentRefPtrOutputWithContext(context.Context) TLSRouteStatusParentsParentRefPtrOutput
}

type tlsrouteStatusParentsParentRefPtrType TLSRouteStatusParentsParentRefArgs

func TLSRouteStatusParentsParentRefPtr(v *TLSRouteStatusParentsParentRefArgs) TLSRouteStatusParentsParentRefPtrInput {
	return (*tlsrouteStatusParentsParentRefPtrType)(v)
}

func (*tlsrouteStatusParentsParentRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteStatusParentsParentRef)(nil)).Elem()
}

func (i *tlsrouteStatusParentsParentRefPtrType) ToTLSRouteStatusParentsParentRefPtrOutput() TLSRouteStatusParentsParentRefPtrOutput {
	return i.ToTLSRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (i *tlsrouteStatusParentsParentRefPtrType) ToTLSRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) TLSRouteStatusParentsParentRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsParentRefPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type TLSRouteStatusParentsParentRefOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsParentRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParentsParentRef)(nil)).Elem()
}

func (o TLSRouteStatusParentsParentRefOutput) ToTLSRouteStatusParentsParentRefOutput() TLSRouteStatusParentsParentRefOutput {
	return o
}

func (o TLSRouteStatusParentsParentRefOutput) ToTLSRouteStatusParentsParentRefOutputWithContext(ctx context.Context) TLSRouteStatusParentsParentRefOutput {
	return o
}

func (o TLSRouteStatusParentsParentRefOutput) ToTLSRouteStatusParentsParentRefPtrOutput() TLSRouteStatusParentsParentRefPtrOutput {
	return o.ToTLSRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (o TLSRouteStatusParentsParentRefOutput) ToTLSRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) TLSRouteStatusParentsParentRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TLSRouteStatusParentsParentRef) *TLSRouteStatusParentsParentRef {
		return &v
	}).(TLSRouteStatusParentsParentRefPtrOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o TLSRouteStatusParentsParentRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o TLSRouteStatusParentsParentRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o TLSRouteStatusParentsParentRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o TLSRouteStatusParentsParentRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o TLSRouteStatusParentsParentRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o TLSRouteStatusParentsParentRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type TLSRouteStatusParentsParentRefPtrOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsParentRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteStatusParentsParentRef)(nil)).Elem()
}

func (o TLSRouteStatusParentsParentRefPtrOutput) ToTLSRouteStatusParentsParentRefPtrOutput() TLSRouteStatusParentsParentRefPtrOutput {
	return o
}

func (o TLSRouteStatusParentsParentRefPtrOutput) ToTLSRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) TLSRouteStatusParentsParentRefPtrOutput {
	return o
}

func (o TLSRouteStatusParentsParentRefPtrOutput) Elem() TLSRouteStatusParentsParentRefOutput {
	return o.ApplyT(func(v *TLSRouteStatusParentsParentRef) TLSRouteStatusParentsParentRef {
		if v != nil {
			return *v
		}
		var ret TLSRouteStatusParentsParentRef
		return ret
	}).(TLSRouteStatusParentsParentRefOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o TLSRouteStatusParentsParentRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TLSRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o TLSRouteStatusParentsParentRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TLSRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o TLSRouteStatusParentsParentRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TLSRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o TLSRouteStatusParentsParentRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TLSRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o TLSRouteStatusParentsParentRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TLSRouteStatusParentsParentRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o TLSRouteStatusParentsParentRefPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TLSRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type TLSRouteStatusParentsParentRefPatch struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// TLSRouteStatusParentsParentRefPatchInput is an input type that accepts TLSRouteStatusParentsParentRefPatchArgs and TLSRouteStatusParentsParentRefPatchOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsParentRefPatchInput` via:
//
//	TLSRouteStatusParentsParentRefPatchArgs{...}
type TLSRouteStatusParentsParentRefPatchInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsParentRefPatchOutput() TLSRouteStatusParentsParentRefPatchOutput
	ToTLSRouteStatusParentsParentRefPatchOutputWithContext(context.Context) TLSRouteStatusParentsParentRefPatchOutput
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type TLSRouteStatusParentsParentRefPatchArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (TLSRouteStatusParentsParentRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (i TLSRouteStatusParentsParentRefPatchArgs) ToTLSRouteStatusParentsParentRefPatchOutput() TLSRouteStatusParentsParentRefPatchOutput {
	return i.ToTLSRouteStatusParentsParentRefPatchOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsParentRefPatchArgs) ToTLSRouteStatusParentsParentRefPatchOutputWithContext(ctx context.Context) TLSRouteStatusParentsParentRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsParentRefPatchOutput)
}

func (i TLSRouteStatusParentsParentRefPatchArgs) ToTLSRouteStatusParentsParentRefPatchPtrOutput() TLSRouteStatusParentsParentRefPatchPtrOutput {
	return i.ToTLSRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsParentRefPatchArgs) ToTLSRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) TLSRouteStatusParentsParentRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsParentRefPatchOutput).ToTLSRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx)
}

// TLSRouteStatusParentsParentRefPatchPtrInput is an input type that accepts TLSRouteStatusParentsParentRefPatchArgs, TLSRouteStatusParentsParentRefPatchPtr and TLSRouteStatusParentsParentRefPatchPtrOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsParentRefPatchPtrInput` via:
//
//	        TLSRouteStatusParentsParentRefPatchArgs{...}
//
//	or:
//
//	        nil
type TLSRouteStatusParentsParentRefPatchPtrInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsParentRefPatchPtrOutput() TLSRouteStatusParentsParentRefPatchPtrOutput
	ToTLSRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Context) TLSRouteStatusParentsParentRefPatchPtrOutput
}

type tlsrouteStatusParentsParentRefPatchPtrType TLSRouteStatusParentsParentRefPatchArgs

func TLSRouteStatusParentsParentRefPatchPtr(v *TLSRouteStatusParentsParentRefPatchArgs) TLSRouteStatusParentsParentRefPatchPtrInput {
	return (*tlsrouteStatusParentsParentRefPatchPtrType)(v)
}

func (*tlsrouteStatusParentsParentRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (i *tlsrouteStatusParentsParentRefPatchPtrType) ToTLSRouteStatusParentsParentRefPatchPtrOutput() TLSRouteStatusParentsParentRefPatchPtrOutput {
	return i.ToTLSRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (i *tlsrouteStatusParentsParentRefPatchPtrType) ToTLSRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) TLSRouteStatusParentsParentRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsParentRefPatchPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type TLSRouteStatusParentsParentRefPatchOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsParentRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (o TLSRouteStatusParentsParentRefPatchOutput) ToTLSRouteStatusParentsParentRefPatchOutput() TLSRouteStatusParentsParentRefPatchOutput {
	return o
}

func (o TLSRouteStatusParentsParentRefPatchOutput) ToTLSRouteStatusParentsParentRefPatchOutputWithContext(ctx context.Context) TLSRouteStatusParentsParentRefPatchOutput {
	return o
}

func (o TLSRouteStatusParentsParentRefPatchOutput) ToTLSRouteStatusParentsParentRefPatchPtrOutput() TLSRouteStatusParentsParentRefPatchPtrOutput {
	return o.ToTLSRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (o TLSRouteStatusParentsParentRefPatchOutput) ToTLSRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) TLSRouteStatusParentsParentRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TLSRouteStatusParentsParentRefPatch) *TLSRouteStatusParentsParentRefPatch {
		return &v
	}).(TLSRouteStatusParentsParentRefPatchPtrOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o TLSRouteStatusParentsParentRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o TLSRouteStatusParentsParentRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o TLSRouteStatusParentsParentRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o TLSRouteStatusParentsParentRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o TLSRouteStatusParentsParentRefPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRefPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o TLSRouteStatusParentsParentRefPatchOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsParentRefPatch) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type TLSRouteStatusParentsParentRefPatchPtrOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsParentRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (o TLSRouteStatusParentsParentRefPatchPtrOutput) ToTLSRouteStatusParentsParentRefPatchPtrOutput() TLSRouteStatusParentsParentRefPatchPtrOutput {
	return o
}

func (o TLSRouteStatusParentsParentRefPatchPtrOutput) ToTLSRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) TLSRouteStatusParentsParentRefPatchPtrOutput {
	return o
}

func (o TLSRouteStatusParentsParentRefPatchPtrOutput) Elem() TLSRouteStatusParentsParentRefPatchOutput {
	return o.ApplyT(func(v *TLSRouteStatusParentsParentRefPatch) TLSRouteStatusParentsParentRefPatch {
		if v != nil {
			return *v
		}
		var ret TLSRouteStatusParentsParentRefPatch
		return ret
	}).(TLSRouteStatusParentsParentRefPatchOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o TLSRouteStatusParentsParentRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TLSRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o TLSRouteStatusParentsParentRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TLSRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o TLSRouteStatusParentsParentRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TLSRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o TLSRouteStatusParentsParentRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TLSRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o TLSRouteStatusParentsParentRefPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *TLSRouteStatusParentsParentRefPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o TLSRouteStatusParentsParentRefPatchPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *TLSRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type TLSRouteStatusParentsPatch struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a nonexistent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions []TLSRouteStatusParentsConditionsPatch `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName *string                              `pulumi:"controllerName"`
	ParentRef      *TLSRouteStatusParentsParentRefPatch `pulumi:"parentRef"`
}

// TLSRouteStatusParentsPatchInput is an input type that accepts TLSRouteStatusParentsPatchArgs and TLSRouteStatusParentsPatchOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsPatchInput` via:
//
//	TLSRouteStatusParentsPatchArgs{...}
type TLSRouteStatusParentsPatchInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsPatchOutput() TLSRouteStatusParentsPatchOutput
	ToTLSRouteStatusParentsPatchOutputWithContext(context.Context) TLSRouteStatusParentsPatchOutput
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type TLSRouteStatusParentsPatchArgs struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a nonexistent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions TLSRouteStatusParentsConditionsPatchArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringPtrInput                       `pulumi:"controllerName"`
	ParentRef      TLSRouteStatusParentsParentRefPatchPtrInput `pulumi:"parentRef"`
}

func (TLSRouteStatusParentsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParentsPatch)(nil)).Elem()
}

func (i TLSRouteStatusParentsPatchArgs) ToTLSRouteStatusParentsPatchOutput() TLSRouteStatusParentsPatchOutput {
	return i.ToTLSRouteStatusParentsPatchOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsPatchArgs) ToTLSRouteStatusParentsPatchOutputWithContext(ctx context.Context) TLSRouteStatusParentsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsPatchOutput)
}

// TLSRouteStatusParentsPatchArrayInput is an input type that accepts TLSRouteStatusParentsPatchArray and TLSRouteStatusParentsPatchArrayOutput values.
// You can construct a concrete instance of `TLSRouteStatusParentsPatchArrayInput` via:
//
//	TLSRouteStatusParentsPatchArray{ TLSRouteStatusParentsPatchArgs{...} }
type TLSRouteStatusParentsPatchArrayInput interface {
	pulumi.Input

	ToTLSRouteStatusParentsPatchArrayOutput() TLSRouteStatusParentsPatchArrayOutput
	ToTLSRouteStatusParentsPatchArrayOutputWithContext(context.Context) TLSRouteStatusParentsPatchArrayOutput
}

type TLSRouteStatusParentsPatchArray []TLSRouteStatusParentsPatchInput

func (TLSRouteStatusParentsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteStatusParentsPatch)(nil)).Elem()
}

func (i TLSRouteStatusParentsPatchArray) ToTLSRouteStatusParentsPatchArrayOutput() TLSRouteStatusParentsPatchArrayOutput {
	return i.ToTLSRouteStatusParentsPatchArrayOutputWithContext(context.Background())
}

func (i TLSRouteStatusParentsPatchArray) ToTLSRouteStatusParentsPatchArrayOutputWithContext(ctx context.Context) TLSRouteStatusParentsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusParentsPatchArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type TLSRouteStatusParentsPatchOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusParentsPatch)(nil)).Elem()
}

func (o TLSRouteStatusParentsPatchOutput) ToTLSRouteStatusParentsPatchOutput() TLSRouteStatusParentsPatchOutput {
	return o
}

func (o TLSRouteStatusParentsPatchOutput) ToTLSRouteStatusParentsPatchOutputWithContext(ctx context.Context) TLSRouteStatusParentsPatchOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway.
// Note that the route's availability is also subject to the Gateway's own
// status conditions and listener status.
//
// If the Route's ParentRef specifies an existing Gateway that supports
// Routes of this kind AND that Gateway's controller has sufficient access,
// then that Gateway's controller MUST set the "Accepted" condition on the
// Route, to indicate whether the route has been accepted or rejected by the
// Gateway, and why.
//
// A Route MUST be considered "Accepted" if at least one of the Route's
// rules is implemented by the Gateway.
//
// There are a number of cases where the "Accepted" condition may not be set
// due to lack of controller visibility, that includes when:
//
// * The Route refers to a nonexistent parent.
// * The Route is of a type that the controller does not support.
// * The Route is in a namespace the controller does not have access to.
func (o TLSRouteStatusParentsPatchOutput) Conditions() TLSRouteStatusParentsConditionsPatchArrayOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsPatch) []TLSRouteStatusParentsConditionsPatch { return v.Conditions }).(TLSRouteStatusParentsConditionsPatchArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o TLSRouteStatusParentsPatchOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsPatch) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

func (o TLSRouteStatusParentsPatchOutput) ParentRef() TLSRouteStatusParentsParentRefPatchPtrOutput {
	return o.ApplyT(func(v TLSRouteStatusParentsPatch) *TLSRouteStatusParentsParentRefPatch { return v.ParentRef }).(TLSRouteStatusParentsParentRefPatchPtrOutput)
}

type TLSRouteStatusParentsPatchArrayOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusParentsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]TLSRouteStatusParentsPatch)(nil)).Elem()
}

func (o TLSRouteStatusParentsPatchArrayOutput) ToTLSRouteStatusParentsPatchArrayOutput() TLSRouteStatusParentsPatchArrayOutput {
	return o
}

func (o TLSRouteStatusParentsPatchArrayOutput) ToTLSRouteStatusParentsPatchArrayOutputWithContext(ctx context.Context) TLSRouteStatusParentsPatchArrayOutput {
	return o
}

func (o TLSRouteStatusParentsPatchArrayOutput) Index(i pulumi.IntInput) TLSRouteStatusParentsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) TLSRouteStatusParentsPatch {
		return vs[0].([]TLSRouteStatusParentsPatch)[vs[1].(int)]
	}).(TLSRouteStatusParentsPatchOutput)
}

// Status defines the current state of TLSRoute.
type TLSRouteStatusPatch struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents []TLSRouteStatusParentsPatch `pulumi:"parents"`
}

// TLSRouteStatusPatchInput is an input type that accepts TLSRouteStatusPatchArgs and TLSRouteStatusPatchOutput values.
// You can construct a concrete instance of `TLSRouteStatusPatchInput` via:
//
//	TLSRouteStatusPatchArgs{...}
type TLSRouteStatusPatchInput interface {
	pulumi.Input

	ToTLSRouteStatusPatchOutput() TLSRouteStatusPatchOutput
	ToTLSRouteStatusPatchOutputWithContext(context.Context) TLSRouteStatusPatchOutput
}

// Status defines the current state of TLSRoute.
type TLSRouteStatusPatchArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents TLSRouteStatusParentsPatchArrayInput `pulumi:"parents"`
}

func (TLSRouteStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusPatch)(nil)).Elem()
}

func (i TLSRouteStatusPatchArgs) ToTLSRouteStatusPatchOutput() TLSRouteStatusPatchOutput {
	return i.ToTLSRouteStatusPatchOutputWithContext(context.Background())
}

func (i TLSRouteStatusPatchArgs) ToTLSRouteStatusPatchOutputWithContext(ctx context.Context) TLSRouteStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusPatchOutput)
}

func (i TLSRouteStatusPatchArgs) ToTLSRouteStatusPatchPtrOutput() TLSRouteStatusPatchPtrOutput {
	return i.ToTLSRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (i TLSRouteStatusPatchArgs) ToTLSRouteStatusPatchPtrOutputWithContext(ctx context.Context) TLSRouteStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusPatchOutput).ToTLSRouteStatusPatchPtrOutputWithContext(ctx)
}

// TLSRouteStatusPatchPtrInput is an input type that accepts TLSRouteStatusPatchArgs, TLSRouteStatusPatchPtr and TLSRouteStatusPatchPtrOutput values.
// You can construct a concrete instance of `TLSRouteStatusPatchPtrInput` via:
//
//	        TLSRouteStatusPatchArgs{...}
//
//	or:
//
//	        nil
type TLSRouteStatusPatchPtrInput interface {
	pulumi.Input

	ToTLSRouteStatusPatchPtrOutput() TLSRouteStatusPatchPtrOutput
	ToTLSRouteStatusPatchPtrOutputWithContext(context.Context) TLSRouteStatusPatchPtrOutput
}

type tlsrouteStatusPatchPtrType TLSRouteStatusPatchArgs

func TLSRouteStatusPatchPtr(v *TLSRouteStatusPatchArgs) TLSRouteStatusPatchPtrInput {
	return (*tlsrouteStatusPatchPtrType)(v)
}

func (*tlsrouteStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteStatusPatch)(nil)).Elem()
}

func (i *tlsrouteStatusPatchPtrType) ToTLSRouteStatusPatchPtrOutput() TLSRouteStatusPatchPtrOutput {
	return i.ToTLSRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (i *tlsrouteStatusPatchPtrType) ToTLSRouteStatusPatchPtrOutputWithContext(ctx context.Context) TLSRouteStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TLSRouteStatusPatchPtrOutput)
}

// Status defines the current state of TLSRoute.
type TLSRouteStatusPatchOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*TLSRouteStatusPatch)(nil)).Elem()
}

func (o TLSRouteStatusPatchOutput) ToTLSRouteStatusPatchOutput() TLSRouteStatusPatchOutput {
	return o
}

func (o TLSRouteStatusPatchOutput) ToTLSRouteStatusPatchOutputWithContext(ctx context.Context) TLSRouteStatusPatchOutput {
	return o
}

func (o TLSRouteStatusPatchOutput) ToTLSRouteStatusPatchPtrOutput() TLSRouteStatusPatchPtrOutput {
	return o.ToTLSRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (o TLSRouteStatusPatchOutput) ToTLSRouteStatusPatchPtrOutputWithContext(ctx context.Context) TLSRouteStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v TLSRouteStatusPatch) *TLSRouteStatusPatch {
		return &v
	}).(TLSRouteStatusPatchPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o TLSRouteStatusPatchOutput) Parents() TLSRouteStatusParentsPatchArrayOutput {
	return o.ApplyT(func(v TLSRouteStatusPatch) []TLSRouteStatusParentsPatch { return v.Parents }).(TLSRouteStatusParentsPatchArrayOutput)
}

type TLSRouteStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (TLSRouteStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**TLSRouteStatusPatch)(nil)).Elem()
}

func (o TLSRouteStatusPatchPtrOutput) ToTLSRouteStatusPatchPtrOutput() TLSRouteStatusPatchPtrOutput {
	return o
}

func (o TLSRouteStatusPatchPtrOutput) ToTLSRouteStatusPatchPtrOutputWithContext(ctx context.Context) TLSRouteStatusPatchPtrOutput {
	return o
}

func (o TLSRouteStatusPatchPtrOutput) Elem() TLSRouteStatusPatchOutput {
	return o.ApplyT(func(v *TLSRouteStatusPatch) TLSRouteStatusPatch {
		if v != nil {
			return *v
		}
		var ret TLSRouteStatusPatch
		return ret
	}).(TLSRouteStatusPatchOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o TLSRouteStatusPatchPtrOutput) Parents() TLSRouteStatusParentsPatchArrayOutput {
	return o.ApplyT(func(v *TLSRouteStatusPatch) []TLSRouteStatusParentsPatch {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(TLSRouteStatusParentsPatchArrayOutput)
}

// UDPRoute provides a way to route UDP traffic. When combined with a Gateway
// listener, it can be used to forward traffic on the port specified by the
// listener to a set of backends specified by the UDPRoute.
type UDPRouteType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMeta `pulumi:"metadata"`
	Spec     *UDPRouteSpec      `pulumi:"spec"`
	Status   *UDPRouteStatus    `pulumi:"status"`
}

// UDPRouteTypeInput is an input type that accepts UDPRouteTypeArgs and UDPRouteTypeOutput values.
// You can construct a concrete instance of `UDPRouteTypeInput` via:
//
//	UDPRouteTypeArgs{...}
type UDPRouteTypeInput interface {
	pulumi.Input

	ToUDPRouteTypeOutput() UDPRouteTypeOutput
	ToUDPRouteTypeOutputWithContext(context.Context) UDPRouteTypeOutput
}

// UDPRoute provides a way to route UDP traffic. When combined with a Gateway
// listener, it can be used to forward traffic on the port specified by the
// listener to a set of backends specified by the UDPRoute.
type UDPRouteTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPtrInput `pulumi:"metadata"`
	Spec     UDPRouteSpecPtrInput      `pulumi:"spec"`
	Status   UDPRouteStatusPtrInput    `pulumi:"status"`
}

func (UDPRouteTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteType)(nil)).Elem()
}

func (i UDPRouteTypeArgs) ToUDPRouteTypeOutput() UDPRouteTypeOutput {
	return i.ToUDPRouteTypeOutputWithContext(context.Background())
}

func (i UDPRouteTypeArgs) ToUDPRouteTypeOutputWithContext(ctx context.Context) UDPRouteTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteTypeOutput)
}

// UDPRouteTypeArrayInput is an input type that accepts UDPRouteTypeArray and UDPRouteTypeArrayOutput values.
// You can construct a concrete instance of `UDPRouteTypeArrayInput` via:
//
//	UDPRouteTypeArray{ UDPRouteTypeArgs{...} }
type UDPRouteTypeArrayInput interface {
	pulumi.Input

	ToUDPRouteTypeArrayOutput() UDPRouteTypeArrayOutput
	ToUDPRouteTypeArrayOutputWithContext(context.Context) UDPRouteTypeArrayOutput
}

type UDPRouteTypeArray []UDPRouteTypeInput

func (UDPRouteTypeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteType)(nil)).Elem()
}

func (i UDPRouteTypeArray) ToUDPRouteTypeArrayOutput() UDPRouteTypeArrayOutput {
	return i.ToUDPRouteTypeArrayOutputWithContext(context.Background())
}

func (i UDPRouteTypeArray) ToUDPRouteTypeArrayOutputWithContext(ctx context.Context) UDPRouteTypeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteTypeArrayOutput)
}

// UDPRoute provides a way to route UDP traffic. When combined with a Gateway
// listener, it can be used to forward traffic on the port specified by the
// listener to a set of backends specified by the UDPRoute.
type UDPRouteTypeOutput struct{ *pulumi.OutputState }

func (UDPRouteTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteType)(nil)).Elem()
}

func (o UDPRouteTypeOutput) ToUDPRouteTypeOutput() UDPRouteTypeOutput {
	return o
}

func (o UDPRouteTypeOutput) ToUDPRouteTypeOutputWithContext(ctx context.Context) UDPRouteTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o UDPRouteTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o UDPRouteTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o UDPRouteTypeOutput) Metadata() metav1.ObjectMetaPtrOutput {
	return o.ApplyT(func(v UDPRouteType) *metav1.ObjectMeta { return v.Metadata }).(metav1.ObjectMetaPtrOutput)
}

func (o UDPRouteTypeOutput) Spec() UDPRouteSpecPtrOutput {
	return o.ApplyT(func(v UDPRouteType) *UDPRouteSpec { return v.Spec }).(UDPRouteSpecPtrOutput)
}

func (o UDPRouteTypeOutput) Status() UDPRouteStatusPtrOutput {
	return o.ApplyT(func(v UDPRouteType) *UDPRouteStatus { return v.Status }).(UDPRouteStatusPtrOutput)
}

type UDPRouteTypeArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteTypeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteType)(nil)).Elem()
}

func (o UDPRouteTypeArrayOutput) ToUDPRouteTypeArrayOutput() UDPRouteTypeArrayOutput {
	return o
}

func (o UDPRouteTypeArrayOutput) ToUDPRouteTypeArrayOutputWithContext(ctx context.Context) UDPRouteTypeArrayOutput {
	return o
}

func (o UDPRouteTypeArrayOutput) Index(i pulumi.IntInput) UDPRouteTypeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteType {
		return vs[0].([]UDPRouteType)[vs[1].(int)]
	}).(UDPRouteTypeOutput)
}

// UDPRouteList is a list of UDPRoute
type UDPRouteListType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// List of udproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items []UDPRouteType `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata *metav1.ListMeta `pulumi:"metadata"`
}

// UDPRouteListTypeInput is an input type that accepts UDPRouteListTypeArgs and UDPRouteListTypeOutput values.
// You can construct a concrete instance of `UDPRouteListTypeInput` via:
//
//	UDPRouteListTypeArgs{...}
type UDPRouteListTypeInput interface {
	pulumi.Input

	ToUDPRouteListTypeOutput() UDPRouteListTypeOutput
	ToUDPRouteListTypeOutputWithContext(context.Context) UDPRouteListTypeOutput
}

// UDPRouteList is a list of UDPRoute
type UDPRouteListTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// List of udproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
	Items UDPRouteTypeArrayInput `pulumi:"items"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Metadata metav1.ListMetaPtrInput `pulumi:"metadata"`
}

func (UDPRouteListTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteListType)(nil)).Elem()
}

func (i UDPRouteListTypeArgs) ToUDPRouteListTypeOutput() UDPRouteListTypeOutput {
	return i.ToUDPRouteListTypeOutputWithContext(context.Background())
}

func (i UDPRouteListTypeArgs) ToUDPRouteListTypeOutputWithContext(ctx context.Context) UDPRouteListTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteListTypeOutput)
}

// UDPRouteList is a list of UDPRoute
type UDPRouteListTypeOutput struct{ *pulumi.OutputState }

func (UDPRouteListTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteListType)(nil)).Elem()
}

func (o UDPRouteListTypeOutput) ToUDPRouteListTypeOutput() UDPRouteListTypeOutput {
	return o
}

func (o UDPRouteListTypeOutput) ToUDPRouteListTypeOutputWithContext(ctx context.Context) UDPRouteListTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o UDPRouteListTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteListType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// List of udproutes. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
func (o UDPRouteListTypeOutput) Items() UDPRouteTypeArrayOutput {
	return o.ApplyT(func(v UDPRouteListType) []UDPRouteType { return v.Items }).(UDPRouteTypeArrayOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o UDPRouteListTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteListType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o UDPRouteListTypeOutput) Metadata() metav1.ListMetaPtrOutput {
	return o.ApplyT(func(v UDPRouteListType) *metav1.ListMeta { return v.Metadata }).(metav1.ListMetaPtrOutput)
}

// UDPRoute provides a way to route UDP traffic. When combined with a Gateway
// listener, it can be used to forward traffic on the port specified by the
// listener to a set of backends specified by the UDPRoute.
type UDPRoutePatchType struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion *string `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind *string `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata *metav1.ObjectMetaPatch `pulumi:"metadata"`
	Spec     *UDPRouteSpecPatch      `pulumi:"spec"`
	Status   *UDPRouteStatusPatch    `pulumi:"status"`
}

// UDPRoutePatchTypeInput is an input type that accepts UDPRoutePatchTypeArgs and UDPRoutePatchTypeOutput values.
// You can construct a concrete instance of `UDPRoutePatchTypeInput` via:
//
//	UDPRoutePatchTypeArgs{...}
type UDPRoutePatchTypeInput interface {
	pulumi.Input

	ToUDPRoutePatchTypeOutput() UDPRoutePatchTypeOutput
	ToUDPRoutePatchTypeOutputWithContext(context.Context) UDPRoutePatchTypeOutput
}

// UDPRoute provides a way to route UDP traffic. When combined with a Gateway
// listener, it can be used to forward traffic on the port specified by the
// listener to a set of backends specified by the UDPRoute.
type UDPRoutePatchTypeArgs struct {
	// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
	ApiVersion pulumi.StringPtrInput `pulumi:"apiVersion"`
	// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	Metadata metav1.ObjectMetaPatchPtrInput `pulumi:"metadata"`
	Spec     UDPRouteSpecPatchPtrInput      `pulumi:"spec"`
	Status   UDPRouteStatusPatchPtrInput    `pulumi:"status"`
}

func (UDPRoutePatchTypeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRoutePatchType)(nil)).Elem()
}

func (i UDPRoutePatchTypeArgs) ToUDPRoutePatchTypeOutput() UDPRoutePatchTypeOutput {
	return i.ToUDPRoutePatchTypeOutputWithContext(context.Background())
}

func (i UDPRoutePatchTypeArgs) ToUDPRoutePatchTypeOutputWithContext(ctx context.Context) UDPRoutePatchTypeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRoutePatchTypeOutput)
}

// UDPRoute provides a way to route UDP traffic. When combined with a Gateway
// listener, it can be used to forward traffic on the port specified by the
// listener to a set of backends specified by the UDPRoute.
type UDPRoutePatchTypeOutput struct{ *pulumi.OutputState }

func (UDPRoutePatchTypeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRoutePatchType)(nil)).Elem()
}

func (o UDPRoutePatchTypeOutput) ToUDPRoutePatchTypeOutput() UDPRoutePatchTypeOutput {
	return o
}

func (o UDPRoutePatchTypeOutput) ToUDPRoutePatchTypeOutputWithContext(ctx context.Context) UDPRoutePatchTypeOutput {
	return o
}

// APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
func (o UDPRoutePatchTypeOutput) ApiVersion() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRoutePatchType) *string { return v.ApiVersion }).(pulumi.StringPtrOutput)
}

// Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
func (o UDPRoutePatchTypeOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRoutePatchType) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
func (o UDPRoutePatchTypeOutput) Metadata() metav1.ObjectMetaPatchPtrOutput {
	return o.ApplyT(func(v UDPRoutePatchType) *metav1.ObjectMetaPatch { return v.Metadata }).(metav1.ObjectMetaPatchPtrOutput)
}

func (o UDPRoutePatchTypeOutput) Spec() UDPRouteSpecPatchPtrOutput {
	return o.ApplyT(func(v UDPRoutePatchType) *UDPRouteSpecPatch { return v.Spec }).(UDPRouteSpecPatchPtrOutput)
}

func (o UDPRoutePatchTypeOutput) Status() UDPRouteStatusPatchPtrOutput {
	return o.ApplyT(func(v UDPRoutePatchType) *UDPRouteStatusPatch { return v.Status }).(UDPRouteStatusPatchPtrOutput)
}

// Spec defines the desired state of UDPRoute.
type UDPRouteSpec struct {
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	ParentRefs []UDPRouteSpecParentRefs `pulumi:"parentRefs"`
	// Rules are a list of UDP matchers and actions.
	Rules []UDPRouteSpecRules `pulumi:"rules"`
}

// UDPRouteSpecInput is an input type that accepts UDPRouteSpecArgs and UDPRouteSpecOutput values.
// You can construct a concrete instance of `UDPRouteSpecInput` via:
//
//	UDPRouteSpecArgs{...}
type UDPRouteSpecInput interface {
	pulumi.Input

	ToUDPRouteSpecOutput() UDPRouteSpecOutput
	ToUDPRouteSpecOutputWithContext(context.Context) UDPRouteSpecOutput
}

// Spec defines the desired state of UDPRoute.
type UDPRouteSpecArgs struct {
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	ParentRefs UDPRouteSpecParentRefsArrayInput `pulumi:"parentRefs"`
	// Rules are a list of UDP matchers and actions.
	Rules UDPRouteSpecRulesArrayInput `pulumi:"rules"`
}

func (UDPRouteSpecArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpec)(nil)).Elem()
}

func (i UDPRouteSpecArgs) ToUDPRouteSpecOutput() UDPRouteSpecOutput {
	return i.ToUDPRouteSpecOutputWithContext(context.Background())
}

func (i UDPRouteSpecArgs) ToUDPRouteSpecOutputWithContext(ctx context.Context) UDPRouteSpecOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecOutput)
}

func (i UDPRouteSpecArgs) ToUDPRouteSpecPtrOutput() UDPRouteSpecPtrOutput {
	return i.ToUDPRouteSpecPtrOutputWithContext(context.Background())
}

func (i UDPRouteSpecArgs) ToUDPRouteSpecPtrOutputWithContext(ctx context.Context) UDPRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecOutput).ToUDPRouteSpecPtrOutputWithContext(ctx)
}

// UDPRouteSpecPtrInput is an input type that accepts UDPRouteSpecArgs, UDPRouteSpecPtr and UDPRouteSpecPtrOutput values.
// You can construct a concrete instance of `UDPRouteSpecPtrInput` via:
//
//	        UDPRouteSpecArgs{...}
//
//	or:
//
//	        nil
type UDPRouteSpecPtrInput interface {
	pulumi.Input

	ToUDPRouteSpecPtrOutput() UDPRouteSpecPtrOutput
	ToUDPRouteSpecPtrOutputWithContext(context.Context) UDPRouteSpecPtrOutput
}

type udprouteSpecPtrType UDPRouteSpecArgs

func UDPRouteSpecPtr(v *UDPRouteSpecArgs) UDPRouteSpecPtrInput {
	return (*udprouteSpecPtrType)(v)
}

func (*udprouteSpecPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteSpec)(nil)).Elem()
}

func (i *udprouteSpecPtrType) ToUDPRouteSpecPtrOutput() UDPRouteSpecPtrOutput {
	return i.ToUDPRouteSpecPtrOutputWithContext(context.Background())
}

func (i *udprouteSpecPtrType) ToUDPRouteSpecPtrOutputWithContext(ctx context.Context) UDPRouteSpecPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecPtrOutput)
}

// Spec defines the desired state of UDPRoute.
type UDPRouteSpecOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpec)(nil)).Elem()
}

func (o UDPRouteSpecOutput) ToUDPRouteSpecOutput() UDPRouteSpecOutput {
	return o
}

func (o UDPRouteSpecOutput) ToUDPRouteSpecOutputWithContext(ctx context.Context) UDPRouteSpecOutput {
	return o
}

func (o UDPRouteSpecOutput) ToUDPRouteSpecPtrOutput() UDPRouteSpecPtrOutput {
	return o.ToUDPRouteSpecPtrOutputWithContext(context.Background())
}

func (o UDPRouteSpecOutput) ToUDPRouteSpecPtrOutputWithContext(ctx context.Context) UDPRouteSpecPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UDPRouteSpec) *UDPRouteSpec {
		return &v
	}).(UDPRouteSpecPtrOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
func (o UDPRouteSpecOutput) ParentRefs() UDPRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v UDPRouteSpec) []UDPRouteSpecParentRefs { return v.ParentRefs }).(UDPRouteSpecParentRefsArrayOutput)
}

// Rules are a list of UDP matchers and actions.
func (o UDPRouteSpecOutput) Rules() UDPRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v UDPRouteSpec) []UDPRouteSpecRules { return v.Rules }).(UDPRouteSpecRulesArrayOutput)
}

type UDPRouteSpecPtrOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteSpec)(nil)).Elem()
}

func (o UDPRouteSpecPtrOutput) ToUDPRouteSpecPtrOutput() UDPRouteSpecPtrOutput {
	return o
}

func (o UDPRouteSpecPtrOutput) ToUDPRouteSpecPtrOutputWithContext(ctx context.Context) UDPRouteSpecPtrOutput {
	return o
}

func (o UDPRouteSpecPtrOutput) Elem() UDPRouteSpecOutput {
	return o.ApplyT(func(v *UDPRouteSpec) UDPRouteSpec {
		if v != nil {
			return *v
		}
		var ret UDPRouteSpec
		return ret
	}).(UDPRouteSpecOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
func (o UDPRouteSpecPtrOutput) ParentRefs() UDPRouteSpecParentRefsArrayOutput {
	return o.ApplyT(func(v *UDPRouteSpec) []UDPRouteSpecParentRefs {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(UDPRouteSpecParentRefsArrayOutput)
}

// Rules are a list of UDP matchers and actions.
func (o UDPRouteSpecPtrOutput) Rules() UDPRouteSpecRulesArrayOutput {
	return o.ApplyT(func(v *UDPRouteSpec) []UDPRouteSpecRules {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(UDPRouteSpecRulesArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type UDPRouteSpecParentRefs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// UDPRouteSpecParentRefsInput is an input type that accepts UDPRouteSpecParentRefsArgs and UDPRouteSpecParentRefsOutput values.
// You can construct a concrete instance of `UDPRouteSpecParentRefsInput` via:
//
//	UDPRouteSpecParentRefsArgs{...}
type UDPRouteSpecParentRefsInput interface {
	pulumi.Input

	ToUDPRouteSpecParentRefsOutput() UDPRouteSpecParentRefsOutput
	ToUDPRouteSpecParentRefsOutputWithContext(context.Context) UDPRouteSpecParentRefsOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type UDPRouteSpecParentRefsArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (UDPRouteSpecParentRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecParentRefs)(nil)).Elem()
}

func (i UDPRouteSpecParentRefsArgs) ToUDPRouteSpecParentRefsOutput() UDPRouteSpecParentRefsOutput {
	return i.ToUDPRouteSpecParentRefsOutputWithContext(context.Background())
}

func (i UDPRouteSpecParentRefsArgs) ToUDPRouteSpecParentRefsOutputWithContext(ctx context.Context) UDPRouteSpecParentRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecParentRefsOutput)
}

// UDPRouteSpecParentRefsArrayInput is an input type that accepts UDPRouteSpecParentRefsArray and UDPRouteSpecParentRefsArrayOutput values.
// You can construct a concrete instance of `UDPRouteSpecParentRefsArrayInput` via:
//
//	UDPRouteSpecParentRefsArray{ UDPRouteSpecParentRefsArgs{...} }
type UDPRouteSpecParentRefsArrayInput interface {
	pulumi.Input

	ToUDPRouteSpecParentRefsArrayOutput() UDPRouteSpecParentRefsArrayOutput
	ToUDPRouteSpecParentRefsArrayOutputWithContext(context.Context) UDPRouteSpecParentRefsArrayOutput
}

type UDPRouteSpecParentRefsArray []UDPRouteSpecParentRefsInput

func (UDPRouteSpecParentRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecParentRefs)(nil)).Elem()
}

func (i UDPRouteSpecParentRefsArray) ToUDPRouteSpecParentRefsArrayOutput() UDPRouteSpecParentRefsArrayOutput {
	return i.ToUDPRouteSpecParentRefsArrayOutputWithContext(context.Background())
}

func (i UDPRouteSpecParentRefsArray) ToUDPRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) UDPRouteSpecParentRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecParentRefsArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type UDPRouteSpecParentRefsOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecParentRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecParentRefs)(nil)).Elem()
}

func (o UDPRouteSpecParentRefsOutput) ToUDPRouteSpecParentRefsOutput() UDPRouteSpecParentRefsOutput {
	return o
}

func (o UDPRouteSpecParentRefsOutput) ToUDPRouteSpecParentRefsOutputWithContext(ctx context.Context) UDPRouteSpecParentRefsOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o UDPRouteSpecParentRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o UDPRouteSpecParentRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o UDPRouteSpecParentRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o UDPRouteSpecParentRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o UDPRouteSpecParentRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o UDPRouteSpecParentRefsOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefs) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type UDPRouteSpecParentRefsArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecParentRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecParentRefs)(nil)).Elem()
}

func (o UDPRouteSpecParentRefsArrayOutput) ToUDPRouteSpecParentRefsArrayOutput() UDPRouteSpecParentRefsArrayOutput {
	return o
}

func (o UDPRouteSpecParentRefsArrayOutput) ToUDPRouteSpecParentRefsArrayOutputWithContext(ctx context.Context) UDPRouteSpecParentRefsArrayOutput {
	return o
}

func (o UDPRouteSpecParentRefsArrayOutput) Index(i pulumi.IntInput) UDPRouteSpecParentRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteSpecParentRefs {
		return vs[0].([]UDPRouteSpecParentRefs)[vs[1].(int)]
	}).(UDPRouteSpecParentRefsOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type UDPRouteSpecParentRefsPatch struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// UDPRouteSpecParentRefsPatchInput is an input type that accepts UDPRouteSpecParentRefsPatchArgs and UDPRouteSpecParentRefsPatchOutput values.
// You can construct a concrete instance of `UDPRouteSpecParentRefsPatchInput` via:
//
//	UDPRouteSpecParentRefsPatchArgs{...}
type UDPRouteSpecParentRefsPatchInput interface {
	pulumi.Input

	ToUDPRouteSpecParentRefsPatchOutput() UDPRouteSpecParentRefsPatchOutput
	ToUDPRouteSpecParentRefsPatchOutputWithContext(context.Context) UDPRouteSpecParentRefsPatchOutput
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type UDPRouteSpecParentRefsPatchArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (UDPRouteSpecParentRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (i UDPRouteSpecParentRefsPatchArgs) ToUDPRouteSpecParentRefsPatchOutput() UDPRouteSpecParentRefsPatchOutput {
	return i.ToUDPRouteSpecParentRefsPatchOutputWithContext(context.Background())
}

func (i UDPRouteSpecParentRefsPatchArgs) ToUDPRouteSpecParentRefsPatchOutputWithContext(ctx context.Context) UDPRouteSpecParentRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecParentRefsPatchOutput)
}

// UDPRouteSpecParentRefsPatchArrayInput is an input type that accepts UDPRouteSpecParentRefsPatchArray and UDPRouteSpecParentRefsPatchArrayOutput values.
// You can construct a concrete instance of `UDPRouteSpecParentRefsPatchArrayInput` via:
//
//	UDPRouteSpecParentRefsPatchArray{ UDPRouteSpecParentRefsPatchArgs{...} }
type UDPRouteSpecParentRefsPatchArrayInput interface {
	pulumi.Input

	ToUDPRouteSpecParentRefsPatchArrayOutput() UDPRouteSpecParentRefsPatchArrayOutput
	ToUDPRouteSpecParentRefsPatchArrayOutputWithContext(context.Context) UDPRouteSpecParentRefsPatchArrayOutput
}

type UDPRouteSpecParentRefsPatchArray []UDPRouteSpecParentRefsPatchInput

func (UDPRouteSpecParentRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (i UDPRouteSpecParentRefsPatchArray) ToUDPRouteSpecParentRefsPatchArrayOutput() UDPRouteSpecParentRefsPatchArrayOutput {
	return i.ToUDPRouteSpecParentRefsPatchArrayOutputWithContext(context.Background())
}

func (i UDPRouteSpecParentRefsPatchArray) ToUDPRouteSpecParentRefsPatchArrayOutputWithContext(ctx context.Context) UDPRouteSpecParentRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecParentRefsPatchArrayOutput)
}

// ParentReference identifies an API object (usually a Gateway) that can be considered
// a parent of this resource (usually a route). There are two kinds of parent resources
// with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// The API object must be valid in the cluster; the Group and Kind must
// be registered in the cluster for this reference to be valid.
type UDPRouteSpecParentRefsPatchOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecParentRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (o UDPRouteSpecParentRefsPatchOutput) ToUDPRouteSpecParentRefsPatchOutput() UDPRouteSpecParentRefsPatchOutput {
	return o
}

func (o UDPRouteSpecParentRefsPatchOutput) ToUDPRouteSpecParentRefsPatchOutputWithContext(ctx context.Context) UDPRouteSpecParentRefsPatchOutput {
	return o
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o UDPRouteSpecParentRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o UDPRouteSpecParentRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o UDPRouteSpecParentRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o UDPRouteSpecParentRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o UDPRouteSpecParentRefsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o UDPRouteSpecParentRefsPatchOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecParentRefsPatch) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type UDPRouteSpecParentRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecParentRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecParentRefsPatch)(nil)).Elem()
}

func (o UDPRouteSpecParentRefsPatchArrayOutput) ToUDPRouteSpecParentRefsPatchArrayOutput() UDPRouteSpecParentRefsPatchArrayOutput {
	return o
}

func (o UDPRouteSpecParentRefsPatchArrayOutput) ToUDPRouteSpecParentRefsPatchArrayOutputWithContext(ctx context.Context) UDPRouteSpecParentRefsPatchArrayOutput {
	return o
}

func (o UDPRouteSpecParentRefsPatchArrayOutput) Index(i pulumi.IntInput) UDPRouteSpecParentRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteSpecParentRefsPatch {
		return vs[0].([]UDPRouteSpecParentRefsPatch)[vs[1].(int)]
	}).(UDPRouteSpecParentRefsPatchOutput)
}

// Spec defines the desired state of UDPRoute.
type UDPRouteSpecPatch struct {
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	ParentRefs []UDPRouteSpecParentRefsPatch `pulumi:"parentRefs"`
	// Rules are a list of UDP matchers and actions.
	Rules []UDPRouteSpecRulesPatch `pulumi:"rules"`
}

// UDPRouteSpecPatchInput is an input type that accepts UDPRouteSpecPatchArgs and UDPRouteSpecPatchOutput values.
// You can construct a concrete instance of `UDPRouteSpecPatchInput` via:
//
//	UDPRouteSpecPatchArgs{...}
type UDPRouteSpecPatchInput interface {
	pulumi.Input

	ToUDPRouteSpecPatchOutput() UDPRouteSpecPatchOutput
	ToUDPRouteSpecPatchOutputWithContext(context.Context) UDPRouteSpecPatchOutput
}

// Spec defines the desired state of UDPRoute.
type UDPRouteSpecPatchArgs struct {
	// ParentRefs references the resources (usually Gateways) that a Route wants
	// to be attached to. Note that the referenced parent resource needs to
	// allow this for the attachment to be complete. For Gateways, that means
	// the Gateway needs to allow attachment from Routes of this kind and
	// namespace. For Services, that means the Service must either be in the same
	// namespace for a "producer" route, or the mesh implementation must support
	// and allow "consumer" routes for the referenced Service. ReferenceGrant is
	// not applicable for governing ParentRefs to Services - it is not possible to
	// create a "producer" route for a Service in a different namespace from the
	// Route.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// This API may be extended in the future to support additional kinds of parent
	// resources.
	//
	// ParentRefs must be _distinct_. This means either that:
	//
	// * They select different objects.  If this is the case, then parentRef
	//   entries are distinct. In terms of fields, this means that the
	//   multi-part key defined by `group`, `kind`, `namespace`, and `name` must
	//   be unique across all parentRef entries in the Route.
	// * They do not select different objects, but for each optional field used,
	//   each ParentRef that selects the same object must set the same set of
	//   optional fields to different values. If one ParentRef sets a
	//   combination of optional fields, all must set the same combination.
	//
	// Some examples:
	//
	// * If one ParentRef sets `sectionName`, all ParentRefs referencing the
	//   same object must also set `sectionName`.
	// * If one ParentRef sets `port`, all ParentRefs referencing the same
	//   object must also set `port`.
	// * If one ParentRef sets `sectionName` and `port`, all ParentRefs
	//   referencing the same object must also set `sectionName` and `port`.
	//
	// It is possible to separately reference multiple distinct objects that may
	// be collapsed by an implementation. For example, some implementations may
	// choose to merge compatible Gateway Listeners together. If that is the
	// case, the list of routes attached to those resources should also be
	// merged.
	//
	// Note that for ParentRefs that cross namespace boundaries, there are specific
	// rules. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example,
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable other kinds of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	ParentRefs UDPRouteSpecParentRefsPatchArrayInput `pulumi:"parentRefs"`
	// Rules are a list of UDP matchers and actions.
	Rules UDPRouteSpecRulesPatchArrayInput `pulumi:"rules"`
}

func (UDPRouteSpecPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecPatch)(nil)).Elem()
}

func (i UDPRouteSpecPatchArgs) ToUDPRouteSpecPatchOutput() UDPRouteSpecPatchOutput {
	return i.ToUDPRouteSpecPatchOutputWithContext(context.Background())
}

func (i UDPRouteSpecPatchArgs) ToUDPRouteSpecPatchOutputWithContext(ctx context.Context) UDPRouteSpecPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecPatchOutput)
}

func (i UDPRouteSpecPatchArgs) ToUDPRouteSpecPatchPtrOutput() UDPRouteSpecPatchPtrOutput {
	return i.ToUDPRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (i UDPRouteSpecPatchArgs) ToUDPRouteSpecPatchPtrOutputWithContext(ctx context.Context) UDPRouteSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecPatchOutput).ToUDPRouteSpecPatchPtrOutputWithContext(ctx)
}

// UDPRouteSpecPatchPtrInput is an input type that accepts UDPRouteSpecPatchArgs, UDPRouteSpecPatchPtr and UDPRouteSpecPatchPtrOutput values.
// You can construct a concrete instance of `UDPRouteSpecPatchPtrInput` via:
//
//	        UDPRouteSpecPatchArgs{...}
//
//	or:
//
//	        nil
type UDPRouteSpecPatchPtrInput interface {
	pulumi.Input

	ToUDPRouteSpecPatchPtrOutput() UDPRouteSpecPatchPtrOutput
	ToUDPRouteSpecPatchPtrOutputWithContext(context.Context) UDPRouteSpecPatchPtrOutput
}

type udprouteSpecPatchPtrType UDPRouteSpecPatchArgs

func UDPRouteSpecPatchPtr(v *UDPRouteSpecPatchArgs) UDPRouteSpecPatchPtrInput {
	return (*udprouteSpecPatchPtrType)(v)
}

func (*udprouteSpecPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteSpecPatch)(nil)).Elem()
}

func (i *udprouteSpecPatchPtrType) ToUDPRouteSpecPatchPtrOutput() UDPRouteSpecPatchPtrOutput {
	return i.ToUDPRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (i *udprouteSpecPatchPtrType) ToUDPRouteSpecPatchPtrOutputWithContext(ctx context.Context) UDPRouteSpecPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecPatchPtrOutput)
}

// Spec defines the desired state of UDPRoute.
type UDPRouteSpecPatchOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecPatch)(nil)).Elem()
}

func (o UDPRouteSpecPatchOutput) ToUDPRouteSpecPatchOutput() UDPRouteSpecPatchOutput {
	return o
}

func (o UDPRouteSpecPatchOutput) ToUDPRouteSpecPatchOutputWithContext(ctx context.Context) UDPRouteSpecPatchOutput {
	return o
}

func (o UDPRouteSpecPatchOutput) ToUDPRouteSpecPatchPtrOutput() UDPRouteSpecPatchPtrOutput {
	return o.ToUDPRouteSpecPatchPtrOutputWithContext(context.Background())
}

func (o UDPRouteSpecPatchOutput) ToUDPRouteSpecPatchPtrOutputWithContext(ctx context.Context) UDPRouteSpecPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UDPRouteSpecPatch) *UDPRouteSpecPatch {
		return &v
	}).(UDPRouteSpecPatchPtrOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
func (o UDPRouteSpecPatchOutput) ParentRefs() UDPRouteSpecParentRefsPatchArrayOutput {
	return o.ApplyT(func(v UDPRouteSpecPatch) []UDPRouteSpecParentRefsPatch { return v.ParentRefs }).(UDPRouteSpecParentRefsPatchArrayOutput)
}

// Rules are a list of UDP matchers and actions.
func (o UDPRouteSpecPatchOutput) Rules() UDPRouteSpecRulesPatchArrayOutput {
	return o.ApplyT(func(v UDPRouteSpecPatch) []UDPRouteSpecRulesPatch { return v.Rules }).(UDPRouteSpecRulesPatchArrayOutput)
}

type UDPRouteSpecPatchPtrOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteSpecPatch)(nil)).Elem()
}

func (o UDPRouteSpecPatchPtrOutput) ToUDPRouteSpecPatchPtrOutput() UDPRouteSpecPatchPtrOutput {
	return o
}

func (o UDPRouteSpecPatchPtrOutput) ToUDPRouteSpecPatchPtrOutputWithContext(ctx context.Context) UDPRouteSpecPatchPtrOutput {
	return o
}

func (o UDPRouteSpecPatchPtrOutput) Elem() UDPRouteSpecPatchOutput {
	return o.ApplyT(func(v *UDPRouteSpecPatch) UDPRouteSpecPatch {
		if v != nil {
			return *v
		}
		var ret UDPRouteSpecPatch
		return ret
	}).(UDPRouteSpecPatchOutput)
}

// ParentRefs references the resources (usually Gateways) that a Route wants
// to be attached to. Note that the referenced parent resource needs to
// allow this for the attachment to be complete. For Gateways, that means
// the Gateway needs to allow attachment from Routes of this kind and
// namespace. For Services, that means the Service must either be in the same
// namespace for a "producer" route, or the mesh implementation must support
// and allow "consumer" routes for the referenced Service. ReferenceGrant is
// not applicable for governing ParentRefs to Services - it is not possible to
// create a "producer" route for a Service in a different namespace from the
// Route.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// This API may be extended in the future to support additional kinds of parent
// resources.
//
// ParentRefs must be _distinct_. This means either that:
//
//   - They select different objects.  If this is the case, then parentRef
//     entries are distinct. In terms of fields, this means that the
//     multi-part key defined by `group`, `kind`, `namespace`, and `name` must
//     be unique across all parentRef entries in the Route.
//   - They do not select different objects, but for each optional field used,
//     each ParentRef that selects the same object must set the same set of
//     optional fields to different values. If one ParentRef sets a
//     combination of optional fields, all must set the same combination.
//
// Some examples:
//
//   - If one ParentRef sets `sectionName`, all ParentRefs referencing the
//     same object must also set `sectionName`.
//   - If one ParentRef sets `port`, all ParentRefs referencing the same
//     object must also set `port`.
//   - If one ParentRef sets `sectionName` and `port`, all ParentRefs
//     referencing the same object must also set `sectionName` and `port`.
//
// It is possible to separately reference multiple distinct objects that may
// be collapsed by an implementation. For example, some implementations may
// choose to merge compatible Gateway Listeners together. If that is the
// case, the list of routes attached to those resources should also be
// merged.
//
// Note that for ParentRefs that cross namespace boundaries, there are specific
// rules. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example,
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable other kinds of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
func (o UDPRouteSpecPatchPtrOutput) ParentRefs() UDPRouteSpecParentRefsPatchArrayOutput {
	return o.ApplyT(func(v *UDPRouteSpecPatch) []UDPRouteSpecParentRefsPatch {
		if v == nil {
			return nil
		}
		return v.ParentRefs
	}).(UDPRouteSpecParentRefsPatchArrayOutput)
}

// Rules are a list of UDP matchers and actions.
func (o UDPRouteSpecPatchPtrOutput) Rules() UDPRouteSpecRulesPatchArrayOutput {
	return o.ApplyT(func(v *UDPRouteSpecPatch) []UDPRouteSpecRulesPatch {
		if v == nil {
			return nil
		}
		return v.Rules
	}).(UDPRouteSpecRulesPatchArrayOutput)
}

// UDPRouteRule is the configuration for a given rule.
type UDPRouteSpecRules struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent. If unspecified or invalid (refers to a nonexistent resource or a
	// Service with no endpoints), the underlying implementation MUST actively
	// reject connection attempts to this backend. Packet drops must
	// respect weight; if an invalid backend is requested to have 80% of
	// the packets, then 80% of packets must be dropped instead.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Extended
	BackendRefs []UDPRouteSpecRulesBackendRefs `pulumi:"backendRefs"`
	// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
	//
	// Support: Extended
	Name *string `pulumi:"name"`
}

// UDPRouteSpecRulesInput is an input type that accepts UDPRouteSpecRulesArgs and UDPRouteSpecRulesOutput values.
// You can construct a concrete instance of `UDPRouteSpecRulesInput` via:
//
//	UDPRouteSpecRulesArgs{...}
type UDPRouteSpecRulesInput interface {
	pulumi.Input

	ToUDPRouteSpecRulesOutput() UDPRouteSpecRulesOutput
	ToUDPRouteSpecRulesOutputWithContext(context.Context) UDPRouteSpecRulesOutput
}

// UDPRouteRule is the configuration for a given rule.
type UDPRouteSpecRulesArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent. If unspecified or invalid (refers to a nonexistent resource or a
	// Service with no endpoints), the underlying implementation MUST actively
	// reject connection attempts to this backend. Packet drops must
	// respect weight; if an invalid backend is requested to have 80% of
	// the packets, then 80% of packets must be dropped instead.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Extended
	BackendRefs UDPRouteSpecRulesBackendRefsArrayInput `pulumi:"backendRefs"`
	// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
	//
	// Support: Extended
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (UDPRouteSpecRulesArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecRules)(nil)).Elem()
}

func (i UDPRouteSpecRulesArgs) ToUDPRouteSpecRulesOutput() UDPRouteSpecRulesOutput {
	return i.ToUDPRouteSpecRulesOutputWithContext(context.Background())
}

func (i UDPRouteSpecRulesArgs) ToUDPRouteSpecRulesOutputWithContext(ctx context.Context) UDPRouteSpecRulesOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecRulesOutput)
}

// UDPRouteSpecRulesArrayInput is an input type that accepts UDPRouteSpecRulesArray and UDPRouteSpecRulesArrayOutput values.
// You can construct a concrete instance of `UDPRouteSpecRulesArrayInput` via:
//
//	UDPRouteSpecRulesArray{ UDPRouteSpecRulesArgs{...} }
type UDPRouteSpecRulesArrayInput interface {
	pulumi.Input

	ToUDPRouteSpecRulesArrayOutput() UDPRouteSpecRulesArrayOutput
	ToUDPRouteSpecRulesArrayOutputWithContext(context.Context) UDPRouteSpecRulesArrayOutput
}

type UDPRouteSpecRulesArray []UDPRouteSpecRulesInput

func (UDPRouteSpecRulesArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecRules)(nil)).Elem()
}

func (i UDPRouteSpecRulesArray) ToUDPRouteSpecRulesArrayOutput() UDPRouteSpecRulesArrayOutput {
	return i.ToUDPRouteSpecRulesArrayOutputWithContext(context.Background())
}

func (i UDPRouteSpecRulesArray) ToUDPRouteSpecRulesArrayOutputWithContext(ctx context.Context) UDPRouteSpecRulesArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecRulesArrayOutput)
}

// UDPRouteRule is the configuration for a given rule.
type UDPRouteSpecRulesOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecRulesOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecRules)(nil)).Elem()
}

func (o UDPRouteSpecRulesOutput) ToUDPRouteSpecRulesOutput() UDPRouteSpecRulesOutput {
	return o
}

func (o UDPRouteSpecRulesOutput) ToUDPRouteSpecRulesOutputWithContext(ctx context.Context) UDPRouteSpecRulesOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be
// sent. If unspecified or invalid (refers to a nonexistent resource or a
// Service with no endpoints), the underlying implementation MUST actively
// reject connection attempts to this backend. Packet drops must
// respect weight; if an invalid backend is requested to have 80% of
// the packets, then 80% of packets must be dropped instead.
//
// Support: Core for Kubernetes Service
//
// Support: Extended for Kubernetes ServiceImport
//
// Support: Implementation-specific for any other resource
//
// Support for weight: Extended
func (o UDPRouteSpecRulesOutput) BackendRefs() UDPRouteSpecRulesBackendRefsArrayOutput {
	return o.ApplyT(func(v UDPRouteSpecRules) []UDPRouteSpecRulesBackendRefs { return v.BackendRefs }).(UDPRouteSpecRulesBackendRefsArrayOutput)
}

// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
//
// Support: Extended
func (o UDPRouteSpecRulesOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRules) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type UDPRouteSpecRulesArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecRulesArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecRules)(nil)).Elem()
}

func (o UDPRouteSpecRulesArrayOutput) ToUDPRouteSpecRulesArrayOutput() UDPRouteSpecRulesArrayOutput {
	return o
}

func (o UDPRouteSpecRulesArrayOutput) ToUDPRouteSpecRulesArrayOutputWithContext(ctx context.Context) UDPRouteSpecRulesArrayOutput {
	return o
}

func (o UDPRouteSpecRulesArrayOutput) Index(i pulumi.IntInput) UDPRouteSpecRulesOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteSpecRules {
		return vs[0].([]UDPRouteSpecRules)[vs[1].(int)]
	}).(UDPRouteSpecRulesOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type UDPRouteSpecRulesBackendRefs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// UDPRouteSpecRulesBackendRefsInput is an input type that accepts UDPRouteSpecRulesBackendRefsArgs and UDPRouteSpecRulesBackendRefsOutput values.
// You can construct a concrete instance of `UDPRouteSpecRulesBackendRefsInput` via:
//
//	UDPRouteSpecRulesBackendRefsArgs{...}
type UDPRouteSpecRulesBackendRefsInput interface {
	pulumi.Input

	ToUDPRouteSpecRulesBackendRefsOutput() UDPRouteSpecRulesBackendRefsOutput
	ToUDPRouteSpecRulesBackendRefsOutputWithContext(context.Context) UDPRouteSpecRulesBackendRefsOutput
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type UDPRouteSpecRulesBackendRefsArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (UDPRouteSpecRulesBackendRefsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i UDPRouteSpecRulesBackendRefsArgs) ToUDPRouteSpecRulesBackendRefsOutput() UDPRouteSpecRulesBackendRefsOutput {
	return i.ToUDPRouteSpecRulesBackendRefsOutputWithContext(context.Background())
}

func (i UDPRouteSpecRulesBackendRefsArgs) ToUDPRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) UDPRouteSpecRulesBackendRefsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecRulesBackendRefsOutput)
}

// UDPRouteSpecRulesBackendRefsArrayInput is an input type that accepts UDPRouteSpecRulesBackendRefsArray and UDPRouteSpecRulesBackendRefsArrayOutput values.
// You can construct a concrete instance of `UDPRouteSpecRulesBackendRefsArrayInput` via:
//
//	UDPRouteSpecRulesBackendRefsArray{ UDPRouteSpecRulesBackendRefsArgs{...} }
type UDPRouteSpecRulesBackendRefsArrayInput interface {
	pulumi.Input

	ToUDPRouteSpecRulesBackendRefsArrayOutput() UDPRouteSpecRulesBackendRefsArrayOutput
	ToUDPRouteSpecRulesBackendRefsArrayOutputWithContext(context.Context) UDPRouteSpecRulesBackendRefsArrayOutput
}

type UDPRouteSpecRulesBackendRefsArray []UDPRouteSpecRulesBackendRefsInput

func (UDPRouteSpecRulesBackendRefsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (i UDPRouteSpecRulesBackendRefsArray) ToUDPRouteSpecRulesBackendRefsArrayOutput() UDPRouteSpecRulesBackendRefsArrayOutput {
	return i.ToUDPRouteSpecRulesBackendRefsArrayOutputWithContext(context.Background())
}

func (i UDPRouteSpecRulesBackendRefsArray) ToUDPRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) UDPRouteSpecRulesBackendRefsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecRulesBackendRefsArrayOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type UDPRouteSpecRulesBackendRefsOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecRulesBackendRefsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o UDPRouteSpecRulesBackendRefsOutput) ToUDPRouteSpecRulesBackendRefsOutput() UDPRouteSpecRulesBackendRefsOutput {
	return o
}

func (o UDPRouteSpecRulesBackendRefsOutput) ToUDPRouteSpecRulesBackendRefsOutputWithContext(ctx context.Context) UDPRouteSpecRulesBackendRefsOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o UDPRouteSpecRulesBackendRefsOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefs) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o UDPRouteSpecRulesBackendRefsOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefs) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o UDPRouteSpecRulesBackendRefsOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefs) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o UDPRouteSpecRulesBackendRefsOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefs) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o UDPRouteSpecRulesBackendRefsOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefs) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced
// backend. This is computed as weight/(sum of all weights in this
// BackendRefs list). For non-zero values, there may be some epsilon from
// the exact proportion defined here depending on the precision an
// implementation supports. Weight is not a percentage and the sum of
// weights does not need to equal 100.
//
// If only one backend is specified and it has a weight greater than 0, 100%
// of the traffic is forwarded to that backend. If weight is set to 0, no
// traffic should be forwarded for this entry. If unspecified, weight
// defaults to 1.
//
// Support for this field varies based on the context where used.
func (o UDPRouteSpecRulesBackendRefsOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefs) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type UDPRouteSpecRulesBackendRefsArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecRulesBackendRefsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecRulesBackendRefs)(nil)).Elem()
}

func (o UDPRouteSpecRulesBackendRefsArrayOutput) ToUDPRouteSpecRulesBackendRefsArrayOutput() UDPRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o UDPRouteSpecRulesBackendRefsArrayOutput) ToUDPRouteSpecRulesBackendRefsArrayOutputWithContext(ctx context.Context) UDPRouteSpecRulesBackendRefsArrayOutput {
	return o
}

func (o UDPRouteSpecRulesBackendRefsArrayOutput) Index(i pulumi.IntInput) UDPRouteSpecRulesBackendRefsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteSpecRulesBackendRefs {
		return vs[0].([]UDPRouteSpecRulesBackendRefs)[vs[1].(int)]
	}).(UDPRouteSpecRulesBackendRefsOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type UDPRouteSpecRulesBackendRefsPatch struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group *string `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port *int `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight *int `pulumi:"weight"`
}

// UDPRouteSpecRulesBackendRefsPatchInput is an input type that accepts UDPRouteSpecRulesBackendRefsPatchArgs and UDPRouteSpecRulesBackendRefsPatchOutput values.
// You can construct a concrete instance of `UDPRouteSpecRulesBackendRefsPatchInput` via:
//
//	UDPRouteSpecRulesBackendRefsPatchArgs{...}
type UDPRouteSpecRulesBackendRefsPatchInput interface {
	pulumi.Input

	ToUDPRouteSpecRulesBackendRefsPatchOutput() UDPRouteSpecRulesBackendRefsPatchOutput
	ToUDPRouteSpecRulesBackendRefsPatchOutputWithContext(context.Context) UDPRouteSpecRulesBackendRefsPatchOutput
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type UDPRouteSpecRulesBackendRefsPatchArgs struct {
	// Group is the group of the referent. For example, "gateway.networking.k8s.io".
	// When unspecified or empty string, core API group is inferred.
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is the Kubernetes resource kind of the referent. For example
	// "Service".
	//
	// Defaults to "Service" when not specified.
	//
	// ExternalName services can refer to CNAME DNS records that may live
	// outside of the cluster and as such are difficult to reason about in
	// terms of conformance. They also may not be safe to forward to (see
	// CVE-2021-25740 for more information). Implementations SHOULD NOT
	// support ExternalName Services.
	//
	// Support: Core (Services with a type other than ExternalName)
	//
	// Support: Implementation-specific (Services with type ExternalName)
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the backend. When unspecified, the local
	// namespace is inferred.
	//
	// Note that when a namespace different than the local namespace is specified,
	// a ReferenceGrant object is required in the referent namespace to allow that
	// namespace's owner to accept the reference. See the ReferenceGrant
	// documentation for details.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port specifies the destination port number to use for this resource.
	// Port is required when the referent is a Kubernetes Service. In this
	// case, the port number is the service port number, not the target port.
	// For other resources, destination port might be derived from the referent
	// resource or this field.
	Port pulumi.IntPtrInput `pulumi:"port"`
	// Weight specifies the proportion of requests forwarded to the referenced
	// backend. This is computed as weight/(sum of all weights in this
	// BackendRefs list). For non-zero values, there may be some epsilon from
	// the exact proportion defined here depending on the precision an
	// implementation supports. Weight is not a percentage and the sum of
	// weights does not need to equal 100.
	//
	// If only one backend is specified and it has a weight greater than 0, 100%
	// of the traffic is forwarded to that backend. If weight is set to 0, no
	// traffic should be forwarded for this entry. If unspecified, weight
	// defaults to 1.
	//
	// Support for this field varies based on the context where used.
	Weight pulumi.IntPtrInput `pulumi:"weight"`
}

func (UDPRouteSpecRulesBackendRefsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (i UDPRouteSpecRulesBackendRefsPatchArgs) ToUDPRouteSpecRulesBackendRefsPatchOutput() UDPRouteSpecRulesBackendRefsPatchOutput {
	return i.ToUDPRouteSpecRulesBackendRefsPatchOutputWithContext(context.Background())
}

func (i UDPRouteSpecRulesBackendRefsPatchArgs) ToUDPRouteSpecRulesBackendRefsPatchOutputWithContext(ctx context.Context) UDPRouteSpecRulesBackendRefsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecRulesBackendRefsPatchOutput)
}

// UDPRouteSpecRulesBackendRefsPatchArrayInput is an input type that accepts UDPRouteSpecRulesBackendRefsPatchArray and UDPRouteSpecRulesBackendRefsPatchArrayOutput values.
// You can construct a concrete instance of `UDPRouteSpecRulesBackendRefsPatchArrayInput` via:
//
//	UDPRouteSpecRulesBackendRefsPatchArray{ UDPRouteSpecRulesBackendRefsPatchArgs{...} }
type UDPRouteSpecRulesBackendRefsPatchArrayInput interface {
	pulumi.Input

	ToUDPRouteSpecRulesBackendRefsPatchArrayOutput() UDPRouteSpecRulesBackendRefsPatchArrayOutput
	ToUDPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(context.Context) UDPRouteSpecRulesBackendRefsPatchArrayOutput
}

type UDPRouteSpecRulesBackendRefsPatchArray []UDPRouteSpecRulesBackendRefsPatchInput

func (UDPRouteSpecRulesBackendRefsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (i UDPRouteSpecRulesBackendRefsPatchArray) ToUDPRouteSpecRulesBackendRefsPatchArrayOutput() UDPRouteSpecRulesBackendRefsPatchArrayOutput {
	return i.ToUDPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(context.Background())
}

func (i UDPRouteSpecRulesBackendRefsPatchArray) ToUDPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(ctx context.Context) UDPRouteSpecRulesBackendRefsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecRulesBackendRefsPatchArrayOutput)
}

// BackendRef defines how a Route should forward a request to a Kubernetes
// resource.
//
// Note that when a namespace different than the local namespace is specified, a
// ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// When the BackendRef points to a Kubernetes Service, implementations SHOULD
// honor the appProtocol field if it is set for the target Service Port.
//
// Implementations supporting appProtocol SHOULD recognize the Kubernetes
// Standard Application Protocols defined in KEP-3726.
//
// If a Service appProtocol isn't specified, an implementation MAY infer the
// backend protocol through its own means. Implementations MAY infer the
// protocol from the Route type referring to the backend Service.
//
// If a Route is not able to send traffic to the backend using the specified
// protocol then the backend is considered invalid. Implementations MUST set the
// "ResolvedRefs" condition to "False" with the "UnsupportedProtocol" reason.
//
// Note that when the BackendTLSPolicy object is enabled by the implementation,
// there are some extra rules about validity to consider here. See the fields
// where this struct is used for more information about the exact behavior.
type UDPRouteSpecRulesBackendRefsPatchOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecRulesBackendRefsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (o UDPRouteSpecRulesBackendRefsPatchOutput) ToUDPRouteSpecRulesBackendRefsPatchOutput() UDPRouteSpecRulesBackendRefsPatchOutput {
	return o
}

func (o UDPRouteSpecRulesBackendRefsPatchOutput) ToUDPRouteSpecRulesBackendRefsPatchOutputWithContext(ctx context.Context) UDPRouteSpecRulesBackendRefsPatchOutput {
	return o
}

// Group is the group of the referent. For example, "gateway.networking.k8s.io".
// When unspecified or empty string, core API group is inferred.
func (o UDPRouteSpecRulesBackendRefsPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefsPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is the Kubernetes resource kind of the referent. For example
// "Service".
//
// Defaults to "Service" when not specified.
//
// ExternalName services can refer to CNAME DNS records that may live
// outside of the cluster and as such are difficult to reason about in
// terms of conformance. They also may not be safe to forward to (see
// CVE-2021-25740 for more information). Implementations SHOULD NOT
// support ExternalName Services.
//
// Support: Core (Services with a type other than ExternalName)
//
// Support: Implementation-specific (Services with type ExternalName)
func (o UDPRouteSpecRulesBackendRefsPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefsPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
func (o UDPRouteSpecRulesBackendRefsPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefsPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the backend. When unspecified, the local
// namespace is inferred.
//
// Note that when a namespace different than the local namespace is specified,
// a ReferenceGrant object is required in the referent namespace to allow that
// namespace's owner to accept the reference. See the ReferenceGrant
// documentation for details.
//
// Support: Core
func (o UDPRouteSpecRulesBackendRefsPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefsPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port specifies the destination port number to use for this resource.
// Port is required when the referent is a Kubernetes Service. In this
// case, the port number is the service port number, not the target port.
// For other resources, destination port might be derived from the referent
// resource or this field.
func (o UDPRouteSpecRulesBackendRefsPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefsPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// Weight specifies the proportion of requests forwarded to the referenced
// backend. This is computed as weight/(sum of all weights in this
// BackendRefs list). For non-zero values, there may be some epsilon from
// the exact proportion defined here depending on the precision an
// implementation supports. Weight is not a percentage and the sum of
// weights does not need to equal 100.
//
// If only one backend is specified and it has a weight greater than 0, 100%
// of the traffic is forwarded to that backend. If weight is set to 0, no
// traffic should be forwarded for this entry. If unspecified, weight
// defaults to 1.
//
// Support for this field varies based on the context where used.
func (o UDPRouteSpecRulesBackendRefsPatchOutput) Weight() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesBackendRefsPatch) *int { return v.Weight }).(pulumi.IntPtrOutput)
}

type UDPRouteSpecRulesBackendRefsPatchArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecRulesBackendRefsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecRulesBackendRefsPatch)(nil)).Elem()
}

func (o UDPRouteSpecRulesBackendRefsPatchArrayOutput) ToUDPRouteSpecRulesBackendRefsPatchArrayOutput() UDPRouteSpecRulesBackendRefsPatchArrayOutput {
	return o
}

func (o UDPRouteSpecRulesBackendRefsPatchArrayOutput) ToUDPRouteSpecRulesBackendRefsPatchArrayOutputWithContext(ctx context.Context) UDPRouteSpecRulesBackendRefsPatchArrayOutput {
	return o
}

func (o UDPRouteSpecRulesBackendRefsPatchArrayOutput) Index(i pulumi.IntInput) UDPRouteSpecRulesBackendRefsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteSpecRulesBackendRefsPatch {
		return vs[0].([]UDPRouteSpecRulesBackendRefsPatch)[vs[1].(int)]
	}).(UDPRouteSpecRulesBackendRefsPatchOutput)
}

// UDPRouteRule is the configuration for a given rule.
type UDPRouteSpecRulesPatch struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent. If unspecified or invalid (refers to a nonexistent resource or a
	// Service with no endpoints), the underlying implementation MUST actively
	// reject connection attempts to this backend. Packet drops must
	// respect weight; if an invalid backend is requested to have 80% of
	// the packets, then 80% of packets must be dropped instead.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Extended
	BackendRefs []UDPRouteSpecRulesBackendRefsPatch `pulumi:"backendRefs"`
	// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
	//
	// Support: Extended
	Name *string `pulumi:"name"`
}

// UDPRouteSpecRulesPatchInput is an input type that accepts UDPRouteSpecRulesPatchArgs and UDPRouteSpecRulesPatchOutput values.
// You can construct a concrete instance of `UDPRouteSpecRulesPatchInput` via:
//
//	UDPRouteSpecRulesPatchArgs{...}
type UDPRouteSpecRulesPatchInput interface {
	pulumi.Input

	ToUDPRouteSpecRulesPatchOutput() UDPRouteSpecRulesPatchOutput
	ToUDPRouteSpecRulesPatchOutputWithContext(context.Context) UDPRouteSpecRulesPatchOutput
}

// UDPRouteRule is the configuration for a given rule.
type UDPRouteSpecRulesPatchArgs struct {
	// BackendRefs defines the backend(s) where matching requests should be
	// sent. If unspecified or invalid (refers to a nonexistent resource or a
	// Service with no endpoints), the underlying implementation MUST actively
	// reject connection attempts to this backend. Packet drops must
	// respect weight; if an invalid backend is requested to have 80% of
	// the packets, then 80% of packets must be dropped instead.
	//
	// Support: Core for Kubernetes Service
	//
	// Support: Extended for Kubernetes ServiceImport
	//
	// Support: Implementation-specific for any other resource
	//
	// Support for weight: Extended
	BackendRefs UDPRouteSpecRulesBackendRefsPatchArrayInput `pulumi:"backendRefs"`
	// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
	//
	// Support: Extended
	Name pulumi.StringPtrInput `pulumi:"name"`
}

func (UDPRouteSpecRulesPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecRulesPatch)(nil)).Elem()
}

func (i UDPRouteSpecRulesPatchArgs) ToUDPRouteSpecRulesPatchOutput() UDPRouteSpecRulesPatchOutput {
	return i.ToUDPRouteSpecRulesPatchOutputWithContext(context.Background())
}

func (i UDPRouteSpecRulesPatchArgs) ToUDPRouteSpecRulesPatchOutputWithContext(ctx context.Context) UDPRouteSpecRulesPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecRulesPatchOutput)
}

// UDPRouteSpecRulesPatchArrayInput is an input type that accepts UDPRouteSpecRulesPatchArray and UDPRouteSpecRulesPatchArrayOutput values.
// You can construct a concrete instance of `UDPRouteSpecRulesPatchArrayInput` via:
//
//	UDPRouteSpecRulesPatchArray{ UDPRouteSpecRulesPatchArgs{...} }
type UDPRouteSpecRulesPatchArrayInput interface {
	pulumi.Input

	ToUDPRouteSpecRulesPatchArrayOutput() UDPRouteSpecRulesPatchArrayOutput
	ToUDPRouteSpecRulesPatchArrayOutputWithContext(context.Context) UDPRouteSpecRulesPatchArrayOutput
}

type UDPRouteSpecRulesPatchArray []UDPRouteSpecRulesPatchInput

func (UDPRouteSpecRulesPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecRulesPatch)(nil)).Elem()
}

func (i UDPRouteSpecRulesPatchArray) ToUDPRouteSpecRulesPatchArrayOutput() UDPRouteSpecRulesPatchArrayOutput {
	return i.ToUDPRouteSpecRulesPatchArrayOutputWithContext(context.Background())
}

func (i UDPRouteSpecRulesPatchArray) ToUDPRouteSpecRulesPatchArrayOutputWithContext(ctx context.Context) UDPRouteSpecRulesPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteSpecRulesPatchArrayOutput)
}

// UDPRouteRule is the configuration for a given rule.
type UDPRouteSpecRulesPatchOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecRulesPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteSpecRulesPatch)(nil)).Elem()
}

func (o UDPRouteSpecRulesPatchOutput) ToUDPRouteSpecRulesPatchOutput() UDPRouteSpecRulesPatchOutput {
	return o
}

func (o UDPRouteSpecRulesPatchOutput) ToUDPRouteSpecRulesPatchOutputWithContext(ctx context.Context) UDPRouteSpecRulesPatchOutput {
	return o
}

// BackendRefs defines the backend(s) where matching requests should be
// sent. If unspecified or invalid (refers to a nonexistent resource or a
// Service with no endpoints), the underlying implementation MUST actively
// reject connection attempts to this backend. Packet drops must
// respect weight; if an invalid backend is requested to have 80% of
// the packets, then 80% of packets must be dropped instead.
//
// Support: Core for Kubernetes Service
//
// Support: Extended for Kubernetes ServiceImport
//
// Support: Implementation-specific for any other resource
//
// Support for weight: Extended
func (o UDPRouteSpecRulesPatchOutput) BackendRefs() UDPRouteSpecRulesBackendRefsPatchArrayOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesPatch) []UDPRouteSpecRulesBackendRefsPatch { return v.BackendRefs }).(UDPRouteSpecRulesBackendRefsPatchArrayOutput)
}

// Name is the name of the route rule. This name MUST be unique within a Route if it is set.
//
// Support: Extended
func (o UDPRouteSpecRulesPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteSpecRulesPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

type UDPRouteSpecRulesPatchArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteSpecRulesPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteSpecRulesPatch)(nil)).Elem()
}

func (o UDPRouteSpecRulesPatchArrayOutput) ToUDPRouteSpecRulesPatchArrayOutput() UDPRouteSpecRulesPatchArrayOutput {
	return o
}

func (o UDPRouteSpecRulesPatchArrayOutput) ToUDPRouteSpecRulesPatchArrayOutputWithContext(ctx context.Context) UDPRouteSpecRulesPatchArrayOutput {
	return o
}

func (o UDPRouteSpecRulesPatchArrayOutput) Index(i pulumi.IntInput) UDPRouteSpecRulesPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteSpecRulesPatch {
		return vs[0].([]UDPRouteSpecRulesPatch)[vs[1].(int)]
	}).(UDPRouteSpecRulesPatchOutput)
}

// Status defines the current state of UDPRoute.
type UDPRouteStatus struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents []UDPRouteStatusParents `pulumi:"parents"`
}

// UDPRouteStatusInput is an input type that accepts UDPRouteStatusArgs and UDPRouteStatusOutput values.
// You can construct a concrete instance of `UDPRouteStatusInput` via:
//
//	UDPRouteStatusArgs{...}
type UDPRouteStatusInput interface {
	pulumi.Input

	ToUDPRouteStatusOutput() UDPRouteStatusOutput
	ToUDPRouteStatusOutputWithContext(context.Context) UDPRouteStatusOutput
}

// Status defines the current state of UDPRoute.
type UDPRouteStatusArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents UDPRouteStatusParentsArrayInput `pulumi:"parents"`
}

func (UDPRouteStatusArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatus)(nil)).Elem()
}

func (i UDPRouteStatusArgs) ToUDPRouteStatusOutput() UDPRouteStatusOutput {
	return i.ToUDPRouteStatusOutputWithContext(context.Background())
}

func (i UDPRouteStatusArgs) ToUDPRouteStatusOutputWithContext(ctx context.Context) UDPRouteStatusOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusOutput)
}

func (i UDPRouteStatusArgs) ToUDPRouteStatusPtrOutput() UDPRouteStatusPtrOutput {
	return i.ToUDPRouteStatusPtrOutputWithContext(context.Background())
}

func (i UDPRouteStatusArgs) ToUDPRouteStatusPtrOutputWithContext(ctx context.Context) UDPRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusOutput).ToUDPRouteStatusPtrOutputWithContext(ctx)
}

// UDPRouteStatusPtrInput is an input type that accepts UDPRouteStatusArgs, UDPRouteStatusPtr and UDPRouteStatusPtrOutput values.
// You can construct a concrete instance of `UDPRouteStatusPtrInput` via:
//
//	        UDPRouteStatusArgs{...}
//
//	or:
//
//	        nil
type UDPRouteStatusPtrInput interface {
	pulumi.Input

	ToUDPRouteStatusPtrOutput() UDPRouteStatusPtrOutput
	ToUDPRouteStatusPtrOutputWithContext(context.Context) UDPRouteStatusPtrOutput
}

type udprouteStatusPtrType UDPRouteStatusArgs

func UDPRouteStatusPtr(v *UDPRouteStatusArgs) UDPRouteStatusPtrInput {
	return (*udprouteStatusPtrType)(v)
}

func (*udprouteStatusPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteStatus)(nil)).Elem()
}

func (i *udprouteStatusPtrType) ToUDPRouteStatusPtrOutput() UDPRouteStatusPtrOutput {
	return i.ToUDPRouteStatusPtrOutputWithContext(context.Background())
}

func (i *udprouteStatusPtrType) ToUDPRouteStatusPtrOutputWithContext(ctx context.Context) UDPRouteStatusPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusPtrOutput)
}

// Status defines the current state of UDPRoute.
type UDPRouteStatusOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatus)(nil)).Elem()
}

func (o UDPRouteStatusOutput) ToUDPRouteStatusOutput() UDPRouteStatusOutput {
	return o
}

func (o UDPRouteStatusOutput) ToUDPRouteStatusOutputWithContext(ctx context.Context) UDPRouteStatusOutput {
	return o
}

func (o UDPRouteStatusOutput) ToUDPRouteStatusPtrOutput() UDPRouteStatusPtrOutput {
	return o.ToUDPRouteStatusPtrOutputWithContext(context.Background())
}

func (o UDPRouteStatusOutput) ToUDPRouteStatusPtrOutputWithContext(ctx context.Context) UDPRouteStatusPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UDPRouteStatus) *UDPRouteStatus {
		return &v
	}).(UDPRouteStatusPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o UDPRouteStatusOutput) Parents() UDPRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v UDPRouteStatus) []UDPRouteStatusParents { return v.Parents }).(UDPRouteStatusParentsArrayOutput)
}

type UDPRouteStatusPtrOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteStatus)(nil)).Elem()
}

func (o UDPRouteStatusPtrOutput) ToUDPRouteStatusPtrOutput() UDPRouteStatusPtrOutput {
	return o
}

func (o UDPRouteStatusPtrOutput) ToUDPRouteStatusPtrOutputWithContext(ctx context.Context) UDPRouteStatusPtrOutput {
	return o
}

func (o UDPRouteStatusPtrOutput) Elem() UDPRouteStatusOutput {
	return o.ApplyT(func(v *UDPRouteStatus) UDPRouteStatus {
		if v != nil {
			return *v
		}
		var ret UDPRouteStatus
		return ret
	}).(UDPRouteStatusOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o UDPRouteStatusPtrOutput) Parents() UDPRouteStatusParentsArrayOutput {
	return o.ApplyT(func(v *UDPRouteStatus) []UDPRouteStatusParents {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(UDPRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type UDPRouteStatusParents struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a nonexistent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions []UDPRouteStatusParentsConditions `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName *string                         `pulumi:"controllerName"`
	ParentRef      *UDPRouteStatusParentsParentRef `pulumi:"parentRef"`
}

// UDPRouteStatusParentsInput is an input type that accepts UDPRouteStatusParentsArgs and UDPRouteStatusParentsOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsInput` via:
//
//	UDPRouteStatusParentsArgs{...}
type UDPRouteStatusParentsInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsOutput() UDPRouteStatusParentsOutput
	ToUDPRouteStatusParentsOutputWithContext(context.Context) UDPRouteStatusParentsOutput
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type UDPRouteStatusParentsArgs struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a nonexistent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions UDPRouteStatusParentsConditionsArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringPtrInput                  `pulumi:"controllerName"`
	ParentRef      UDPRouteStatusParentsParentRefPtrInput `pulumi:"parentRef"`
}

func (UDPRouteStatusParentsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParents)(nil)).Elem()
}

func (i UDPRouteStatusParentsArgs) ToUDPRouteStatusParentsOutput() UDPRouteStatusParentsOutput {
	return i.ToUDPRouteStatusParentsOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsArgs) ToUDPRouteStatusParentsOutputWithContext(ctx context.Context) UDPRouteStatusParentsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsOutput)
}

// UDPRouteStatusParentsArrayInput is an input type that accepts UDPRouteStatusParentsArray and UDPRouteStatusParentsArrayOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsArrayInput` via:
//
//	UDPRouteStatusParentsArray{ UDPRouteStatusParentsArgs{...} }
type UDPRouteStatusParentsArrayInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsArrayOutput() UDPRouteStatusParentsArrayOutput
	ToUDPRouteStatusParentsArrayOutputWithContext(context.Context) UDPRouteStatusParentsArrayOutput
}

type UDPRouteStatusParentsArray []UDPRouteStatusParentsInput

func (UDPRouteStatusParentsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteStatusParents)(nil)).Elem()
}

func (i UDPRouteStatusParentsArray) ToUDPRouteStatusParentsArrayOutput() UDPRouteStatusParentsArrayOutput {
	return i.ToUDPRouteStatusParentsArrayOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsArray) ToUDPRouteStatusParentsArrayOutputWithContext(ctx context.Context) UDPRouteStatusParentsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type UDPRouteStatusParentsOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParents)(nil)).Elem()
}

func (o UDPRouteStatusParentsOutput) ToUDPRouteStatusParentsOutput() UDPRouteStatusParentsOutput {
	return o
}

func (o UDPRouteStatusParentsOutput) ToUDPRouteStatusParentsOutputWithContext(ctx context.Context) UDPRouteStatusParentsOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway.
// Note that the route's availability is also subject to the Gateway's own
// status conditions and listener status.
//
// If the Route's ParentRef specifies an existing Gateway that supports
// Routes of this kind AND that Gateway's controller has sufficient access,
// then that Gateway's controller MUST set the "Accepted" condition on the
// Route, to indicate whether the route has been accepted or rejected by the
// Gateway, and why.
//
// A Route MUST be considered "Accepted" if at least one of the Route's
// rules is implemented by the Gateway.
//
// There are a number of cases where the "Accepted" condition may not be set
// due to lack of controller visibility, that includes when:
//
// * The Route refers to a nonexistent parent.
// * The Route is of a type that the controller does not support.
// * The Route is in a namespace the controller does not have access to.
func (o UDPRouteStatusParentsOutput) Conditions() UDPRouteStatusParentsConditionsArrayOutput {
	return o.ApplyT(func(v UDPRouteStatusParents) []UDPRouteStatusParentsConditions { return v.Conditions }).(UDPRouteStatusParentsConditionsArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o UDPRouteStatusParentsOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParents) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

func (o UDPRouteStatusParentsOutput) ParentRef() UDPRouteStatusParentsParentRefPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParents) *UDPRouteStatusParentsParentRef { return v.ParentRef }).(UDPRouteStatusParentsParentRefPtrOutput)
}

type UDPRouteStatusParentsArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteStatusParents)(nil)).Elem()
}

func (o UDPRouteStatusParentsArrayOutput) ToUDPRouteStatusParentsArrayOutput() UDPRouteStatusParentsArrayOutput {
	return o
}

func (o UDPRouteStatusParentsArrayOutput) ToUDPRouteStatusParentsArrayOutputWithContext(ctx context.Context) UDPRouteStatusParentsArrayOutput {
	return o
}

func (o UDPRouteStatusParentsArrayOutput) Index(i pulumi.IntInput) UDPRouteStatusParentsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteStatusParents {
		return vs[0].([]UDPRouteStatusParents)[vs[1].(int)]
	}).(UDPRouteStatusParentsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type UDPRouteStatusParentsConditions struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type *string `pulumi:"type"`
}

// UDPRouteStatusParentsConditionsInput is an input type that accepts UDPRouteStatusParentsConditionsArgs and UDPRouteStatusParentsConditionsOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsConditionsInput` via:
//
//	UDPRouteStatusParentsConditionsArgs{...}
type UDPRouteStatusParentsConditionsInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsConditionsOutput() UDPRouteStatusParentsConditionsOutput
	ToUDPRouteStatusParentsConditionsOutputWithContext(context.Context) UDPRouteStatusParentsConditionsOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
type UDPRouteStatusParentsConditionsArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (UDPRouteStatusParentsConditionsArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParentsConditions)(nil)).Elem()
}

func (i UDPRouteStatusParentsConditionsArgs) ToUDPRouteStatusParentsConditionsOutput() UDPRouteStatusParentsConditionsOutput {
	return i.ToUDPRouteStatusParentsConditionsOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsConditionsArgs) ToUDPRouteStatusParentsConditionsOutputWithContext(ctx context.Context) UDPRouteStatusParentsConditionsOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsConditionsOutput)
}

// UDPRouteStatusParentsConditionsArrayInput is an input type that accepts UDPRouteStatusParentsConditionsArray and UDPRouteStatusParentsConditionsArrayOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsConditionsArrayInput` via:
//
//	UDPRouteStatusParentsConditionsArray{ UDPRouteStatusParentsConditionsArgs{...} }
type UDPRouteStatusParentsConditionsArrayInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsConditionsArrayOutput() UDPRouteStatusParentsConditionsArrayOutput
	ToUDPRouteStatusParentsConditionsArrayOutputWithContext(context.Context) UDPRouteStatusParentsConditionsArrayOutput
}

type UDPRouteStatusParentsConditionsArray []UDPRouteStatusParentsConditionsInput

func (UDPRouteStatusParentsConditionsArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteStatusParentsConditions)(nil)).Elem()
}

func (i UDPRouteStatusParentsConditionsArray) ToUDPRouteStatusParentsConditionsArrayOutput() UDPRouteStatusParentsConditionsArrayOutput {
	return i.ToUDPRouteStatusParentsConditionsArrayOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsConditionsArray) ToUDPRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) UDPRouteStatusParentsConditionsArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsConditionsArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type UDPRouteStatusParentsConditionsOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsConditionsOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParentsConditions)(nil)).Elem()
}

func (o UDPRouteStatusParentsConditionsOutput) ToUDPRouteStatusParentsConditionsOutput() UDPRouteStatusParentsConditionsOutput {
	return o
}

func (o UDPRouteStatusParentsConditionsOutput) ToUDPRouteStatusParentsConditionsOutputWithContext(ctx context.Context) UDPRouteStatusParentsConditionsOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o UDPRouteStatusParentsConditionsOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditions) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o UDPRouteStatusParentsConditionsOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditions) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o UDPRouteStatusParentsConditionsOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditions) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o UDPRouteStatusParentsConditionsOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditions) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o UDPRouteStatusParentsConditionsOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditions) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
func (o UDPRouteStatusParentsConditionsOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditions) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type UDPRouteStatusParentsConditionsArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsConditionsArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteStatusParentsConditions)(nil)).Elem()
}

func (o UDPRouteStatusParentsConditionsArrayOutput) ToUDPRouteStatusParentsConditionsArrayOutput() UDPRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o UDPRouteStatusParentsConditionsArrayOutput) ToUDPRouteStatusParentsConditionsArrayOutputWithContext(ctx context.Context) UDPRouteStatusParentsConditionsArrayOutput {
	return o
}

func (o UDPRouteStatusParentsConditionsArrayOutput) Index(i pulumi.IntInput) UDPRouteStatusParentsConditionsOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteStatusParentsConditions {
		return vs[0].([]UDPRouteStatusParentsConditions)[vs[1].(int)]
	}).(UDPRouteStatusParentsConditionsOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type UDPRouteStatusParentsConditionsPatch struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime *string `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration *int `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason *string `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status *string `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type *string `pulumi:"type"`
}

// UDPRouteStatusParentsConditionsPatchInput is an input type that accepts UDPRouteStatusParentsConditionsPatchArgs and UDPRouteStatusParentsConditionsPatchOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsConditionsPatchInput` via:
//
//	UDPRouteStatusParentsConditionsPatchArgs{...}
type UDPRouteStatusParentsConditionsPatchInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsConditionsPatchOutput() UDPRouteStatusParentsConditionsPatchOutput
	ToUDPRouteStatusParentsConditionsPatchOutputWithContext(context.Context) UDPRouteStatusParentsConditionsPatchOutput
}

// Condition contains details for one aspect of the current state of this API Resource.
type UDPRouteStatusParentsConditionsPatchArgs struct {
	// lastTransitionTime is the last time the condition transitioned from one status to another.
	// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
	LastTransitionTime pulumi.StringPtrInput `pulumi:"lastTransitionTime"`
	// message is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message pulumi.StringPtrInput `pulumi:"message"`
	// observedGeneration represents the .metadata.generation that the condition was set based upon.
	// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
	// with respect to the current state of the instance.
	ObservedGeneration pulumi.IntPtrInput `pulumi:"observedGeneration"`
	// reason contains a programmatic identifier indicating the reason for the condition's last transition.
	// Producers of specific condition types may define expected values and meanings for this field,
	// and whether the values are considered a guaranteed API.
	// The value should be a CamelCase string.
	// This field may not be empty.
	Reason pulumi.StringPtrInput `pulumi:"reason"`
	// status of the condition, one of True, False, Unknown.
	Status pulumi.StringPtrInput `pulumi:"status"`
	// type of condition in CamelCase or in foo.example.com/CamelCase.
	Type pulumi.StringPtrInput `pulumi:"type"`
}

func (UDPRouteStatusParentsConditionsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (i UDPRouteStatusParentsConditionsPatchArgs) ToUDPRouteStatusParentsConditionsPatchOutput() UDPRouteStatusParentsConditionsPatchOutput {
	return i.ToUDPRouteStatusParentsConditionsPatchOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsConditionsPatchArgs) ToUDPRouteStatusParentsConditionsPatchOutputWithContext(ctx context.Context) UDPRouteStatusParentsConditionsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsConditionsPatchOutput)
}

// UDPRouteStatusParentsConditionsPatchArrayInput is an input type that accepts UDPRouteStatusParentsConditionsPatchArray and UDPRouteStatusParentsConditionsPatchArrayOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsConditionsPatchArrayInput` via:
//
//	UDPRouteStatusParentsConditionsPatchArray{ UDPRouteStatusParentsConditionsPatchArgs{...} }
type UDPRouteStatusParentsConditionsPatchArrayInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsConditionsPatchArrayOutput() UDPRouteStatusParentsConditionsPatchArrayOutput
	ToUDPRouteStatusParentsConditionsPatchArrayOutputWithContext(context.Context) UDPRouteStatusParentsConditionsPatchArrayOutput
}

type UDPRouteStatusParentsConditionsPatchArray []UDPRouteStatusParentsConditionsPatchInput

func (UDPRouteStatusParentsConditionsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (i UDPRouteStatusParentsConditionsPatchArray) ToUDPRouteStatusParentsConditionsPatchArrayOutput() UDPRouteStatusParentsConditionsPatchArrayOutput {
	return i.ToUDPRouteStatusParentsConditionsPatchArrayOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsConditionsPatchArray) ToUDPRouteStatusParentsConditionsPatchArrayOutputWithContext(ctx context.Context) UDPRouteStatusParentsConditionsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsConditionsPatchArrayOutput)
}

// Condition contains details for one aspect of the current state of this API Resource.
type UDPRouteStatusParentsConditionsPatchOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsConditionsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (o UDPRouteStatusParentsConditionsPatchOutput) ToUDPRouteStatusParentsConditionsPatchOutput() UDPRouteStatusParentsConditionsPatchOutput {
	return o
}

func (o UDPRouteStatusParentsConditionsPatchOutput) ToUDPRouteStatusParentsConditionsPatchOutputWithContext(ctx context.Context) UDPRouteStatusParentsConditionsPatchOutput {
	return o
}

// lastTransitionTime is the last time the condition transitioned from one status to another.
// This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
func (o UDPRouteStatusParentsConditionsPatchOutput) LastTransitionTime() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditionsPatch) *string { return v.LastTransitionTime }).(pulumi.StringPtrOutput)
}

// message is a human readable message indicating details about the transition.
// This may be an empty string.
func (o UDPRouteStatusParentsConditionsPatchOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditionsPatch) *string { return v.Message }).(pulumi.StringPtrOutput)
}

// observedGeneration represents the .metadata.generation that the condition was set based upon.
// For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
// with respect to the current state of the instance.
func (o UDPRouteStatusParentsConditionsPatchOutput) ObservedGeneration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditionsPatch) *int { return v.ObservedGeneration }).(pulumi.IntPtrOutput)
}

// reason contains a programmatic identifier indicating the reason for the condition's last transition.
// Producers of specific condition types may define expected values and meanings for this field,
// and whether the values are considered a guaranteed API.
// The value should be a CamelCase string.
// This field may not be empty.
func (o UDPRouteStatusParentsConditionsPatchOutput) Reason() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditionsPatch) *string { return v.Reason }).(pulumi.StringPtrOutput)
}

// status of the condition, one of True, False, Unknown.
func (o UDPRouteStatusParentsConditionsPatchOutput) Status() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditionsPatch) *string { return v.Status }).(pulumi.StringPtrOutput)
}

// type of condition in CamelCase or in foo.example.com/CamelCase.
func (o UDPRouteStatusParentsConditionsPatchOutput) Type() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsConditionsPatch) *string { return v.Type }).(pulumi.StringPtrOutput)
}

type UDPRouteStatusParentsConditionsPatchArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsConditionsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteStatusParentsConditionsPatch)(nil)).Elem()
}

func (o UDPRouteStatusParentsConditionsPatchArrayOutput) ToUDPRouteStatusParentsConditionsPatchArrayOutput() UDPRouteStatusParentsConditionsPatchArrayOutput {
	return o
}

func (o UDPRouteStatusParentsConditionsPatchArrayOutput) ToUDPRouteStatusParentsConditionsPatchArrayOutputWithContext(ctx context.Context) UDPRouteStatusParentsConditionsPatchArrayOutput {
	return o
}

func (o UDPRouteStatusParentsConditionsPatchArrayOutput) Index(i pulumi.IntInput) UDPRouteStatusParentsConditionsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteStatusParentsConditionsPatch {
		return vs[0].([]UDPRouteStatusParentsConditionsPatch)[vs[1].(int)]
	}).(UDPRouteStatusParentsConditionsPatchOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type UDPRouteStatusParentsParentRef struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// UDPRouteStatusParentsParentRefInput is an input type that accepts UDPRouteStatusParentsParentRefArgs and UDPRouteStatusParentsParentRefOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsParentRefInput` via:
//
//	UDPRouteStatusParentsParentRefArgs{...}
type UDPRouteStatusParentsParentRefInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsParentRefOutput() UDPRouteStatusParentsParentRefOutput
	ToUDPRouteStatusParentsParentRefOutputWithContext(context.Context) UDPRouteStatusParentsParentRefOutput
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type UDPRouteStatusParentsParentRefArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (UDPRouteStatusParentsParentRefArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParentsParentRef)(nil)).Elem()
}

func (i UDPRouteStatusParentsParentRefArgs) ToUDPRouteStatusParentsParentRefOutput() UDPRouteStatusParentsParentRefOutput {
	return i.ToUDPRouteStatusParentsParentRefOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsParentRefArgs) ToUDPRouteStatusParentsParentRefOutputWithContext(ctx context.Context) UDPRouteStatusParentsParentRefOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsParentRefOutput)
}

func (i UDPRouteStatusParentsParentRefArgs) ToUDPRouteStatusParentsParentRefPtrOutput() UDPRouteStatusParentsParentRefPtrOutput {
	return i.ToUDPRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsParentRefArgs) ToUDPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) UDPRouteStatusParentsParentRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsParentRefOutput).ToUDPRouteStatusParentsParentRefPtrOutputWithContext(ctx)
}

// UDPRouteStatusParentsParentRefPtrInput is an input type that accepts UDPRouteStatusParentsParentRefArgs, UDPRouteStatusParentsParentRefPtr and UDPRouteStatusParentsParentRefPtrOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsParentRefPtrInput` via:
//
//	        UDPRouteStatusParentsParentRefArgs{...}
//
//	or:
//
//	        nil
type UDPRouteStatusParentsParentRefPtrInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsParentRefPtrOutput() UDPRouteStatusParentsParentRefPtrOutput
	ToUDPRouteStatusParentsParentRefPtrOutputWithContext(context.Context) UDPRouteStatusParentsParentRefPtrOutput
}

type udprouteStatusParentsParentRefPtrType UDPRouteStatusParentsParentRefArgs

func UDPRouteStatusParentsParentRefPtr(v *UDPRouteStatusParentsParentRefArgs) UDPRouteStatusParentsParentRefPtrInput {
	return (*udprouteStatusParentsParentRefPtrType)(v)
}

func (*udprouteStatusParentsParentRefPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteStatusParentsParentRef)(nil)).Elem()
}

func (i *udprouteStatusParentsParentRefPtrType) ToUDPRouteStatusParentsParentRefPtrOutput() UDPRouteStatusParentsParentRefPtrOutput {
	return i.ToUDPRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (i *udprouteStatusParentsParentRefPtrType) ToUDPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) UDPRouteStatusParentsParentRefPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsParentRefPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type UDPRouteStatusParentsParentRefOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsParentRefOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParentsParentRef)(nil)).Elem()
}

func (o UDPRouteStatusParentsParentRefOutput) ToUDPRouteStatusParentsParentRefOutput() UDPRouteStatusParentsParentRefOutput {
	return o
}

func (o UDPRouteStatusParentsParentRefOutput) ToUDPRouteStatusParentsParentRefOutputWithContext(ctx context.Context) UDPRouteStatusParentsParentRefOutput {
	return o
}

func (o UDPRouteStatusParentsParentRefOutput) ToUDPRouteStatusParentsParentRefPtrOutput() UDPRouteStatusParentsParentRefPtrOutput {
	return o.ToUDPRouteStatusParentsParentRefPtrOutputWithContext(context.Background())
}

func (o UDPRouteStatusParentsParentRefOutput) ToUDPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) UDPRouteStatusParentsParentRefPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UDPRouteStatusParentsParentRef) *UDPRouteStatusParentsParentRef {
		return &v
	}).(UDPRouteStatusParentsParentRefPtrOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o UDPRouteStatusParentsParentRefOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRef) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o UDPRouteStatusParentsParentRefOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRef) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o UDPRouteStatusParentsParentRefOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRef) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o UDPRouteStatusParentsParentRefOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRef) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o UDPRouteStatusParentsParentRefOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRef) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o UDPRouteStatusParentsParentRefOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRef) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type UDPRouteStatusParentsParentRefPtrOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsParentRefPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteStatusParentsParentRef)(nil)).Elem()
}

func (o UDPRouteStatusParentsParentRefPtrOutput) ToUDPRouteStatusParentsParentRefPtrOutput() UDPRouteStatusParentsParentRefPtrOutput {
	return o
}

func (o UDPRouteStatusParentsParentRefPtrOutput) ToUDPRouteStatusParentsParentRefPtrOutputWithContext(ctx context.Context) UDPRouteStatusParentsParentRefPtrOutput {
	return o
}

func (o UDPRouteStatusParentsParentRefPtrOutput) Elem() UDPRouteStatusParentsParentRefOutput {
	return o.ApplyT(func(v *UDPRouteStatusParentsParentRef) UDPRouteStatusParentsParentRef {
		if v != nil {
			return *v
		}
		var ret UDPRouteStatusParentsParentRef
		return ret
	}).(UDPRouteStatusParentsParentRefOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o UDPRouteStatusParentsParentRefPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UDPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o UDPRouteStatusParentsParentRefPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UDPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o UDPRouteStatusParentsParentRefPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UDPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o UDPRouteStatusParentsParentRefPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UDPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o UDPRouteStatusParentsParentRefPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *UDPRouteStatusParentsParentRef) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o UDPRouteStatusParentsParentRefPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UDPRouteStatusParentsParentRef) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type UDPRouteStatusParentsParentRefPatch struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group *string `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind *string `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name *string `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace *string `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port *int `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName *string `pulumi:"sectionName"`
}

// UDPRouteStatusParentsParentRefPatchInput is an input type that accepts UDPRouteStatusParentsParentRefPatchArgs and UDPRouteStatusParentsParentRefPatchOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsParentRefPatchInput` via:
//
//	UDPRouteStatusParentsParentRefPatchArgs{...}
type UDPRouteStatusParentsParentRefPatchInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsParentRefPatchOutput() UDPRouteStatusParentsParentRefPatchOutput
	ToUDPRouteStatusParentsParentRefPatchOutputWithContext(context.Context) UDPRouteStatusParentsParentRefPatchOutput
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type UDPRouteStatusParentsParentRefPatchArgs struct {
	// Group is the group of the referent.
	// When unspecified, "gateway.networking.k8s.io" is inferred.
	// To set the core API group (such as for a "Service" kind referent),
	// Group must be explicitly set to "" (empty string).
	//
	// Support: Core
	Group pulumi.StringPtrInput `pulumi:"group"`
	// Kind is kind of the referent.
	//
	// There are two kinds of parent resources with "Core" support:
	//
	// * Gateway (Gateway conformance profile)
	// * Service (Mesh conformance profile, ClusterIP Services only)
	//
	// Support for other resources is Implementation-Specific.
	Kind pulumi.StringPtrInput `pulumi:"kind"`
	// Name is the name of the referent.
	//
	// Support: Core
	Name pulumi.StringPtrInput `pulumi:"name"`
	// Namespace is the namespace of the referent. When unspecified, this refers
	// to the local namespace of the Route.
	//
	// Note that there are specific rules for ParentRefs which cross namespace
	// boundaries. Cross-namespace references are only valid if they are explicitly
	// allowed by something in the namespace they are referring to. For example:
	// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
	// generic way to enable any other kind of cross-namespace reference.
	//
	// ParentRefs from a Route to a Service in the same namespace are "producer"
	// routes, which apply default routing rules to inbound connections from
	// any namespace to the Service.
	//
	// ParentRefs from a Route to a Service in a different namespace are
	// "consumer" routes, and these routing rules are only applied to outbound
	// connections originating from the same namespace as the Route, for which
	// the intended destination of the connections are a Service targeted as a
	// ParentRef of the Route.
	//
	// Support: Core
	Namespace pulumi.StringPtrInput `pulumi:"namespace"`
	// Port is the network port this Route targets. It can be interpreted
	// differently based on the type of parent resource.
	//
	// When the parent resource is a Gateway, this targets all listeners
	// listening on the specified port that also support this kind of Route(and
	// select this Route). It's not recommended to set `Port` unless the
	// networking behaviors specified in a Route must apply to a specific port
	// as opposed to a listener(s) whose port(s) may be changed. When both Port
	// and SectionName are specified, the name and port of the selected listener
	// must match both specified values.
	//
	// When the parent resource is a Service, this targets a specific port in the
	// Service spec. When both Port (experimental) and SectionName are specified,
	// the name and port of the selected port must match both specified values.
	//
	// Implementations MAY choose to support other parent resources.
	// Implementations supporting other types of parent resources MUST clearly
	// document how/if Port is interpreted.
	//
	// For the purpose of status, an attachment is considered successful as
	// long as the parent resource accepts it partially. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
	// from the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route,
	// the Route MUST be considered detached from the Gateway.
	//
	// Support: Extended
	Port pulumi.IntPtrInput `pulumi:"port"`
	// SectionName is the name of a section within the target resource. In the
	// following resources, SectionName is interpreted as the following:
	//
	// * Gateway: Listener name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	// * Service: Port name. When both Port (experimental) and SectionName
	//   are specified, the name and port of the selected listener must match
	//   both specified values.
	//
	// Implementations MAY choose to support attaching Routes to other resources.
	// If that is the case, they MUST clearly document how SectionName is
	// interpreted.
	//
	// When unspecified (empty string), this will reference the entire resource.
	// For the purpose of status, an attachment is considered successful if at
	// least one section in the parent resource accepts it. For example, Gateway
	// listeners can restrict which Routes can attach to them by Route kind,
	// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
	// the referencing Route, the Route MUST be considered successfully
	// attached. If no Gateway listeners accept attachment from this Route, the
	// Route MUST be considered detached from the Gateway.
	//
	// Support: Core
	SectionName pulumi.StringPtrInput `pulumi:"sectionName"`
}

func (UDPRouteStatusParentsParentRefPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (i UDPRouteStatusParentsParentRefPatchArgs) ToUDPRouteStatusParentsParentRefPatchOutput() UDPRouteStatusParentsParentRefPatchOutput {
	return i.ToUDPRouteStatusParentsParentRefPatchOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsParentRefPatchArgs) ToUDPRouteStatusParentsParentRefPatchOutputWithContext(ctx context.Context) UDPRouteStatusParentsParentRefPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsParentRefPatchOutput)
}

func (i UDPRouteStatusParentsParentRefPatchArgs) ToUDPRouteStatusParentsParentRefPatchPtrOutput() UDPRouteStatusParentsParentRefPatchPtrOutput {
	return i.ToUDPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsParentRefPatchArgs) ToUDPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) UDPRouteStatusParentsParentRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsParentRefPatchOutput).ToUDPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx)
}

// UDPRouteStatusParentsParentRefPatchPtrInput is an input type that accepts UDPRouteStatusParentsParentRefPatchArgs, UDPRouteStatusParentsParentRefPatchPtr and UDPRouteStatusParentsParentRefPatchPtrOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsParentRefPatchPtrInput` via:
//
//	        UDPRouteStatusParentsParentRefPatchArgs{...}
//
//	or:
//
//	        nil
type UDPRouteStatusParentsParentRefPatchPtrInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsParentRefPatchPtrOutput() UDPRouteStatusParentsParentRefPatchPtrOutput
	ToUDPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Context) UDPRouteStatusParentsParentRefPatchPtrOutput
}

type udprouteStatusParentsParentRefPatchPtrType UDPRouteStatusParentsParentRefPatchArgs

func UDPRouteStatusParentsParentRefPatchPtr(v *UDPRouteStatusParentsParentRefPatchArgs) UDPRouteStatusParentsParentRefPatchPtrInput {
	return (*udprouteStatusParentsParentRefPatchPtrType)(v)
}

func (*udprouteStatusParentsParentRefPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (i *udprouteStatusParentsParentRefPatchPtrType) ToUDPRouteStatusParentsParentRefPatchPtrOutput() UDPRouteStatusParentsParentRefPatchPtrOutput {
	return i.ToUDPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (i *udprouteStatusParentsParentRefPatchPtrType) ToUDPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) UDPRouteStatusParentsParentRefPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsParentRefPatchPtrOutput)
}

// ParentRef corresponds with a ParentRef in the spec that this
// RouteParentStatus struct describes the status of.
type UDPRouteStatusParentsParentRefPatchOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsParentRefPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (o UDPRouteStatusParentsParentRefPatchOutput) ToUDPRouteStatusParentsParentRefPatchOutput() UDPRouteStatusParentsParentRefPatchOutput {
	return o
}

func (o UDPRouteStatusParentsParentRefPatchOutput) ToUDPRouteStatusParentsParentRefPatchOutputWithContext(ctx context.Context) UDPRouteStatusParentsParentRefPatchOutput {
	return o
}

func (o UDPRouteStatusParentsParentRefPatchOutput) ToUDPRouteStatusParentsParentRefPatchPtrOutput() UDPRouteStatusParentsParentRefPatchPtrOutput {
	return o.ToUDPRouteStatusParentsParentRefPatchPtrOutputWithContext(context.Background())
}

func (o UDPRouteStatusParentsParentRefPatchOutput) ToUDPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) UDPRouteStatusParentsParentRefPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UDPRouteStatusParentsParentRefPatch) *UDPRouteStatusParentsParentRefPatch {
		return &v
	}).(UDPRouteStatusParentsParentRefPatchPtrOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o UDPRouteStatusParentsParentRefPatchOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRefPatch) *string { return v.Group }).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o UDPRouteStatusParentsParentRefPatchOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRefPatch) *string { return v.Kind }).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o UDPRouteStatusParentsParentRefPatchOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRefPatch) *string { return v.Name }).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o UDPRouteStatusParentsParentRefPatchOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRefPatch) *string { return v.Namespace }).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o UDPRouteStatusParentsParentRefPatchOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRefPatch) *int { return v.Port }).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o UDPRouteStatusParentsParentRefPatchOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsParentRefPatch) *string { return v.SectionName }).(pulumi.StringPtrOutput)
}

type UDPRouteStatusParentsParentRefPatchPtrOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsParentRefPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteStatusParentsParentRefPatch)(nil)).Elem()
}

func (o UDPRouteStatusParentsParentRefPatchPtrOutput) ToUDPRouteStatusParentsParentRefPatchPtrOutput() UDPRouteStatusParentsParentRefPatchPtrOutput {
	return o
}

func (o UDPRouteStatusParentsParentRefPatchPtrOutput) ToUDPRouteStatusParentsParentRefPatchPtrOutputWithContext(ctx context.Context) UDPRouteStatusParentsParentRefPatchPtrOutput {
	return o
}

func (o UDPRouteStatusParentsParentRefPatchPtrOutput) Elem() UDPRouteStatusParentsParentRefPatchOutput {
	return o.ApplyT(func(v *UDPRouteStatusParentsParentRefPatch) UDPRouteStatusParentsParentRefPatch {
		if v != nil {
			return *v
		}
		var ret UDPRouteStatusParentsParentRefPatch
		return ret
	}).(UDPRouteStatusParentsParentRefPatchOutput)
}

// Group is the group of the referent.
// When unspecified, "gateway.networking.k8s.io" is inferred.
// To set the core API group (such as for a "Service" kind referent),
// Group must be explicitly set to "" (empty string).
//
// Support: Core
func (o UDPRouteStatusParentsParentRefPatchPtrOutput) Group() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UDPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Group
	}).(pulumi.StringPtrOutput)
}

// Kind is kind of the referent.
//
// There are two kinds of parent resources with "Core" support:
//
// * Gateway (Gateway conformance profile)
// * Service (Mesh conformance profile, ClusterIP Services only)
//
// Support for other resources is Implementation-Specific.
func (o UDPRouteStatusParentsParentRefPatchPtrOutput) Kind() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UDPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Kind
	}).(pulumi.StringPtrOutput)
}

// Name is the name of the referent.
//
// Support: Core
func (o UDPRouteStatusParentsParentRefPatchPtrOutput) Name() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UDPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Name
	}).(pulumi.StringPtrOutput)
}

// Namespace is the namespace of the referent. When unspecified, this refers
// to the local namespace of the Route.
//
// Note that there are specific rules for ParentRefs which cross namespace
// boundaries. Cross-namespace references are only valid if they are explicitly
// allowed by something in the namespace they are referring to. For example:
// Gateway has the AllowedRoutes field, and ReferenceGrant provides a
// generic way to enable any other kind of cross-namespace reference.
//
// ParentRefs from a Route to a Service in the same namespace are "producer"
// routes, which apply default routing rules to inbound connections from
// any namespace to the Service.
//
// ParentRefs from a Route to a Service in a different namespace are
// "consumer" routes, and these routing rules are only applied to outbound
// connections originating from the same namespace as the Route, for which
// the intended destination of the connections are a Service targeted as a
// ParentRef of the Route.
//
// Support: Core
func (o UDPRouteStatusParentsParentRefPatchPtrOutput) Namespace() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UDPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.Namespace
	}).(pulumi.StringPtrOutput)
}

// Port is the network port this Route targets. It can be interpreted
// differently based on the type of parent resource.
//
// When the parent resource is a Gateway, this targets all listeners
// listening on the specified port that also support this kind of Route(and
// select this Route). It's not recommended to set `Port` unless the
// networking behaviors specified in a Route must apply to a specific port
// as opposed to a listener(s) whose port(s) may be changed. When both Port
// and SectionName are specified, the name and port of the selected listener
// must match both specified values.
//
// When the parent resource is a Service, this targets a specific port in the
// Service spec. When both Port (experimental) and SectionName are specified,
// the name and port of the selected port must match both specified values.
//
// Implementations MAY choose to support other parent resources.
// Implementations supporting other types of parent resources MUST clearly
// document how/if Port is interpreted.
//
// For the purpose of status, an attachment is considered successful as
// long as the parent resource accepts it partially. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
// from the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route,
// the Route MUST be considered detached from the Gateway.
//
// Support: Extended
func (o UDPRouteStatusParentsParentRefPatchPtrOutput) Port() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *UDPRouteStatusParentsParentRefPatch) *int {
		if v == nil {
			return nil
		}
		return v.Port
	}).(pulumi.IntPtrOutput)
}

// SectionName is the name of a section within the target resource. In the
// following resources, SectionName is interpreted as the following:
//
//   - Gateway: Listener name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//   - Service: Port name. When both Port (experimental) and SectionName
//     are specified, the name and port of the selected listener must match
//     both specified values.
//
// Implementations MAY choose to support attaching Routes to other resources.
// If that is the case, they MUST clearly document how SectionName is
// interpreted.
//
// When unspecified (empty string), this will reference the entire resource.
// For the purpose of status, an attachment is considered successful if at
// least one section in the parent resource accepts it. For example, Gateway
// listeners can restrict which Routes can attach to them by Route kind,
// namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
// the referencing Route, the Route MUST be considered successfully
// attached. If no Gateway listeners accept attachment from this Route, the
// Route MUST be considered detached from the Gateway.
//
// Support: Core
func (o UDPRouteStatusParentsParentRefPatchPtrOutput) SectionName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *UDPRouteStatusParentsParentRefPatch) *string {
		if v == nil {
			return nil
		}
		return v.SectionName
	}).(pulumi.StringPtrOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type UDPRouteStatusParentsPatch struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a nonexistent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions []UDPRouteStatusParentsConditionsPatch `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName *string                              `pulumi:"controllerName"`
	ParentRef      *UDPRouteStatusParentsParentRefPatch `pulumi:"parentRef"`
}

// UDPRouteStatusParentsPatchInput is an input type that accepts UDPRouteStatusParentsPatchArgs and UDPRouteStatusParentsPatchOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsPatchInput` via:
//
//	UDPRouteStatusParentsPatchArgs{...}
type UDPRouteStatusParentsPatchInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsPatchOutput() UDPRouteStatusParentsPatchOutput
	ToUDPRouteStatusParentsPatchOutputWithContext(context.Context) UDPRouteStatusParentsPatchOutput
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type UDPRouteStatusParentsPatchArgs struct {
	// Conditions describes the status of the route with respect to the Gateway.
	// Note that the route's availability is also subject to the Gateway's own
	// status conditions and listener status.
	//
	// If the Route's ParentRef specifies an existing Gateway that supports
	// Routes of this kind AND that Gateway's controller has sufficient access,
	// then that Gateway's controller MUST set the "Accepted" condition on the
	// Route, to indicate whether the route has been accepted or rejected by the
	// Gateway, and why.
	//
	// A Route MUST be considered "Accepted" if at least one of the Route's
	// rules is implemented by the Gateway.
	//
	// There are a number of cases where the "Accepted" condition may not be set
	// due to lack of controller visibility, that includes when:
	//
	// * The Route refers to a nonexistent parent.
	// * The Route is of a type that the controller does not support.
	// * The Route is in a namespace the controller does not have access to.
	Conditions UDPRouteStatusParentsConditionsPatchArrayInput `pulumi:"conditions"`
	// ControllerName is a domain/path string that indicates the name of the
	// controller that wrote this status. This corresponds with the
	// controllerName field on GatewayClass.
	//
	// Example: "example.net/gateway-controller".
	//
	// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
	// valid Kubernetes names
	// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
	//
	// Controllers MUST populate this field when writing status. Controllers should ensure that
	// entries to status populated with their ControllerName are cleaned up when they are no
	// longer necessary.
	ControllerName pulumi.StringPtrInput                       `pulumi:"controllerName"`
	ParentRef      UDPRouteStatusParentsParentRefPatchPtrInput `pulumi:"parentRef"`
}

func (UDPRouteStatusParentsPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParentsPatch)(nil)).Elem()
}

func (i UDPRouteStatusParentsPatchArgs) ToUDPRouteStatusParentsPatchOutput() UDPRouteStatusParentsPatchOutput {
	return i.ToUDPRouteStatusParentsPatchOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsPatchArgs) ToUDPRouteStatusParentsPatchOutputWithContext(ctx context.Context) UDPRouteStatusParentsPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsPatchOutput)
}

// UDPRouteStatusParentsPatchArrayInput is an input type that accepts UDPRouteStatusParentsPatchArray and UDPRouteStatusParentsPatchArrayOutput values.
// You can construct a concrete instance of `UDPRouteStatusParentsPatchArrayInput` via:
//
//	UDPRouteStatusParentsPatchArray{ UDPRouteStatusParentsPatchArgs{...} }
type UDPRouteStatusParentsPatchArrayInput interface {
	pulumi.Input

	ToUDPRouteStatusParentsPatchArrayOutput() UDPRouteStatusParentsPatchArrayOutput
	ToUDPRouteStatusParentsPatchArrayOutputWithContext(context.Context) UDPRouteStatusParentsPatchArrayOutput
}

type UDPRouteStatusParentsPatchArray []UDPRouteStatusParentsPatchInput

func (UDPRouteStatusParentsPatchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteStatusParentsPatch)(nil)).Elem()
}

func (i UDPRouteStatusParentsPatchArray) ToUDPRouteStatusParentsPatchArrayOutput() UDPRouteStatusParentsPatchArrayOutput {
	return i.ToUDPRouteStatusParentsPatchArrayOutputWithContext(context.Background())
}

func (i UDPRouteStatusParentsPatchArray) ToUDPRouteStatusParentsPatchArrayOutputWithContext(ctx context.Context) UDPRouteStatusParentsPatchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusParentsPatchArrayOutput)
}

// RouteParentStatus describes the status of a route with respect to an
// associated Parent.
type UDPRouteStatusParentsPatchOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusParentsPatch)(nil)).Elem()
}

func (o UDPRouteStatusParentsPatchOutput) ToUDPRouteStatusParentsPatchOutput() UDPRouteStatusParentsPatchOutput {
	return o
}

func (o UDPRouteStatusParentsPatchOutput) ToUDPRouteStatusParentsPatchOutputWithContext(ctx context.Context) UDPRouteStatusParentsPatchOutput {
	return o
}

// Conditions describes the status of the route with respect to the Gateway.
// Note that the route's availability is also subject to the Gateway's own
// status conditions and listener status.
//
// If the Route's ParentRef specifies an existing Gateway that supports
// Routes of this kind AND that Gateway's controller has sufficient access,
// then that Gateway's controller MUST set the "Accepted" condition on the
// Route, to indicate whether the route has been accepted or rejected by the
// Gateway, and why.
//
// A Route MUST be considered "Accepted" if at least one of the Route's
// rules is implemented by the Gateway.
//
// There are a number of cases where the "Accepted" condition may not be set
// due to lack of controller visibility, that includes when:
//
// * The Route refers to a nonexistent parent.
// * The Route is of a type that the controller does not support.
// * The Route is in a namespace the controller does not have access to.
func (o UDPRouteStatusParentsPatchOutput) Conditions() UDPRouteStatusParentsConditionsPatchArrayOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsPatch) []UDPRouteStatusParentsConditionsPatch { return v.Conditions }).(UDPRouteStatusParentsConditionsPatchArrayOutput)
}

// ControllerName is a domain/path string that indicates the name of the
// controller that wrote this status. This corresponds with the
// controllerName field on GatewayClass.
//
// Example: "example.net/gateway-controller".
//
// The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
// valid Kubernetes names
// (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
//
// Controllers MUST populate this field when writing status. Controllers should ensure that
// entries to status populated with their ControllerName are cleaned up when they are no
// longer necessary.
func (o UDPRouteStatusParentsPatchOutput) ControllerName() pulumi.StringPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsPatch) *string { return v.ControllerName }).(pulumi.StringPtrOutput)
}

func (o UDPRouteStatusParentsPatchOutput) ParentRef() UDPRouteStatusParentsParentRefPatchPtrOutput {
	return o.ApplyT(func(v UDPRouteStatusParentsPatch) *UDPRouteStatusParentsParentRefPatch { return v.ParentRef }).(UDPRouteStatusParentsParentRefPatchPtrOutput)
}

type UDPRouteStatusParentsPatchArrayOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusParentsPatchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]UDPRouteStatusParentsPatch)(nil)).Elem()
}

func (o UDPRouteStatusParentsPatchArrayOutput) ToUDPRouteStatusParentsPatchArrayOutput() UDPRouteStatusParentsPatchArrayOutput {
	return o
}

func (o UDPRouteStatusParentsPatchArrayOutput) ToUDPRouteStatusParentsPatchArrayOutputWithContext(ctx context.Context) UDPRouteStatusParentsPatchArrayOutput {
	return o
}

func (o UDPRouteStatusParentsPatchArrayOutput) Index(i pulumi.IntInput) UDPRouteStatusParentsPatchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) UDPRouteStatusParentsPatch {
		return vs[0].([]UDPRouteStatusParentsPatch)[vs[1].(int)]
	}).(UDPRouteStatusParentsPatchOutput)
}

// Status defines the current state of UDPRoute.
type UDPRouteStatusPatch struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents []UDPRouteStatusParentsPatch `pulumi:"parents"`
}

// UDPRouteStatusPatchInput is an input type that accepts UDPRouteStatusPatchArgs and UDPRouteStatusPatchOutput values.
// You can construct a concrete instance of `UDPRouteStatusPatchInput` via:
//
//	UDPRouteStatusPatchArgs{...}
type UDPRouteStatusPatchInput interface {
	pulumi.Input

	ToUDPRouteStatusPatchOutput() UDPRouteStatusPatchOutput
	ToUDPRouteStatusPatchOutputWithContext(context.Context) UDPRouteStatusPatchOutput
}

// Status defines the current state of UDPRoute.
type UDPRouteStatusPatchArgs struct {
	// Parents is a list of parent resources (usually Gateways) that are
	// associated with the route, and the status of the route with respect to
	// each parent. When this route attaches to a parent, the controller that
	// manages the parent must add an entry to this list when the controller
	// first sees the route and should update the entry as appropriate when the
	// route or gateway is modified.
	//
	// Note that parent references that cannot be resolved by an implementation
	// of this API will not be added to this list. Implementations of this API
	// can only populate Route status for the Gateways/parent resources they are
	// responsible for.
	//
	// A maximum of 32 Gateways will be represented in this list. An empty list
	// means the route has not been attached to any Gateway.
	Parents UDPRouteStatusParentsPatchArrayInput `pulumi:"parents"`
}

func (UDPRouteStatusPatchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusPatch)(nil)).Elem()
}

func (i UDPRouteStatusPatchArgs) ToUDPRouteStatusPatchOutput() UDPRouteStatusPatchOutput {
	return i.ToUDPRouteStatusPatchOutputWithContext(context.Background())
}

func (i UDPRouteStatusPatchArgs) ToUDPRouteStatusPatchOutputWithContext(ctx context.Context) UDPRouteStatusPatchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusPatchOutput)
}

func (i UDPRouteStatusPatchArgs) ToUDPRouteStatusPatchPtrOutput() UDPRouteStatusPatchPtrOutput {
	return i.ToUDPRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (i UDPRouteStatusPatchArgs) ToUDPRouteStatusPatchPtrOutputWithContext(ctx context.Context) UDPRouteStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusPatchOutput).ToUDPRouteStatusPatchPtrOutputWithContext(ctx)
}

// UDPRouteStatusPatchPtrInput is an input type that accepts UDPRouteStatusPatchArgs, UDPRouteStatusPatchPtr and UDPRouteStatusPatchPtrOutput values.
// You can construct a concrete instance of `UDPRouteStatusPatchPtrInput` via:
//
//	        UDPRouteStatusPatchArgs{...}
//
//	or:
//
//	        nil
type UDPRouteStatusPatchPtrInput interface {
	pulumi.Input

	ToUDPRouteStatusPatchPtrOutput() UDPRouteStatusPatchPtrOutput
	ToUDPRouteStatusPatchPtrOutputWithContext(context.Context) UDPRouteStatusPatchPtrOutput
}

type udprouteStatusPatchPtrType UDPRouteStatusPatchArgs

func UDPRouteStatusPatchPtr(v *UDPRouteStatusPatchArgs) UDPRouteStatusPatchPtrInput {
	return (*udprouteStatusPatchPtrType)(v)
}

func (*udprouteStatusPatchPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteStatusPatch)(nil)).Elem()
}

func (i *udprouteStatusPatchPtrType) ToUDPRouteStatusPatchPtrOutput() UDPRouteStatusPatchPtrOutput {
	return i.ToUDPRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (i *udprouteStatusPatchPtrType) ToUDPRouteStatusPatchPtrOutputWithContext(ctx context.Context) UDPRouteStatusPatchPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UDPRouteStatusPatchPtrOutput)
}

// Status defines the current state of UDPRoute.
type UDPRouteStatusPatchOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusPatchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*UDPRouteStatusPatch)(nil)).Elem()
}

func (o UDPRouteStatusPatchOutput) ToUDPRouteStatusPatchOutput() UDPRouteStatusPatchOutput {
	return o
}

func (o UDPRouteStatusPatchOutput) ToUDPRouteStatusPatchOutputWithContext(ctx context.Context) UDPRouteStatusPatchOutput {
	return o
}

func (o UDPRouteStatusPatchOutput) ToUDPRouteStatusPatchPtrOutput() UDPRouteStatusPatchPtrOutput {
	return o.ToUDPRouteStatusPatchPtrOutputWithContext(context.Background())
}

func (o UDPRouteStatusPatchOutput) ToUDPRouteStatusPatchPtrOutputWithContext(ctx context.Context) UDPRouteStatusPatchPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v UDPRouteStatusPatch) *UDPRouteStatusPatch {
		return &v
	}).(UDPRouteStatusPatchPtrOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o UDPRouteStatusPatchOutput) Parents() UDPRouteStatusParentsPatchArrayOutput {
	return o.ApplyT(func(v UDPRouteStatusPatch) []UDPRouteStatusParentsPatch { return v.Parents }).(UDPRouteStatusParentsPatchArrayOutput)
}

type UDPRouteStatusPatchPtrOutput struct{ *pulumi.OutputState }

func (UDPRouteStatusPatchPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**UDPRouteStatusPatch)(nil)).Elem()
}

func (o UDPRouteStatusPatchPtrOutput) ToUDPRouteStatusPatchPtrOutput() UDPRouteStatusPatchPtrOutput {
	return o
}

func (o UDPRouteStatusPatchPtrOutput) ToUDPRouteStatusPatchPtrOutputWithContext(ctx context.Context) UDPRouteStatusPatchPtrOutput {
	return o
}

func (o UDPRouteStatusPatchPtrOutput) Elem() UDPRouteStatusPatchOutput {
	return o.ApplyT(func(v *UDPRouteStatusPatch) UDPRouteStatusPatch {
		if v != nil {
			return *v
		}
		var ret UDPRouteStatusPatch
		return ret
	}).(UDPRouteStatusPatchOutput)
}

// Parents is a list of parent resources (usually Gateways) that are
// associated with the route, and the status of the route with respect to
// each parent. When this route attaches to a parent, the controller that
// manages the parent must add an entry to this list when the controller
// first sees the route and should update the entry as appropriate when the
// route or gateway is modified.
//
// Note that parent references that cannot be resolved by an implementation
// of this API will not be added to this list. Implementations of this API
// can only populate Route status for the Gateways/parent resources they are
// responsible for.
//
// A maximum of 32 Gateways will be represented in this list. An empty list
// means the route has not been attached to any Gateway.
func (o UDPRouteStatusPatchPtrOutput) Parents() UDPRouteStatusParentsPatchArrayOutput {
	return o.ApplyT(func(v *UDPRouteStatusPatch) []UDPRouteStatusParentsPatch {
		if v == nil {
			return nil
		}
		return v.Parents
	}).(UDPRouteStatusParentsPatchArrayOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteTypeInput)(nil)).Elem(), TCPRouteTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteTypeArrayInput)(nil)).Elem(), TCPRouteTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteListTypeInput)(nil)).Elem(), TCPRouteListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRoutePatchTypeInput)(nil)).Elem(), TCPRoutePatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecInput)(nil)).Elem(), TCPRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecPtrInput)(nil)).Elem(), TCPRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecParentRefsInput)(nil)).Elem(), TCPRouteSpecParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecParentRefsArrayInput)(nil)).Elem(), TCPRouteSpecParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecParentRefsPatchInput)(nil)).Elem(), TCPRouteSpecParentRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecParentRefsPatchArrayInput)(nil)).Elem(), TCPRouteSpecParentRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecPatchInput)(nil)).Elem(), TCPRouteSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecPatchPtrInput)(nil)).Elem(), TCPRouteSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecRulesInput)(nil)).Elem(), TCPRouteSpecRulesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecRulesArrayInput)(nil)).Elem(), TCPRouteSpecRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecRulesBackendRefsInput)(nil)).Elem(), TCPRouteSpecRulesBackendRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecRulesBackendRefsArrayInput)(nil)).Elem(), TCPRouteSpecRulesBackendRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecRulesBackendRefsPatchInput)(nil)).Elem(), TCPRouteSpecRulesBackendRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecRulesBackendRefsPatchArrayInput)(nil)).Elem(), TCPRouteSpecRulesBackendRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecRulesPatchInput)(nil)).Elem(), TCPRouteSpecRulesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteSpecRulesPatchArrayInput)(nil)).Elem(), TCPRouteSpecRulesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusInput)(nil)).Elem(), TCPRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusPtrInput)(nil)).Elem(), TCPRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsInput)(nil)).Elem(), TCPRouteStatusParentsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsArrayInput)(nil)).Elem(), TCPRouteStatusParentsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsConditionsInput)(nil)).Elem(), TCPRouteStatusParentsConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsConditionsArrayInput)(nil)).Elem(), TCPRouteStatusParentsConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsConditionsPatchInput)(nil)).Elem(), TCPRouteStatusParentsConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsConditionsPatchArrayInput)(nil)).Elem(), TCPRouteStatusParentsConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsParentRefInput)(nil)).Elem(), TCPRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsParentRefPtrInput)(nil)).Elem(), TCPRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsParentRefPatchInput)(nil)).Elem(), TCPRouteStatusParentsParentRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsParentRefPatchPtrInput)(nil)).Elem(), TCPRouteStatusParentsParentRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsPatchInput)(nil)).Elem(), TCPRouteStatusParentsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusParentsPatchArrayInput)(nil)).Elem(), TCPRouteStatusParentsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusPatchInput)(nil)).Elem(), TCPRouteStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TCPRouteStatusPatchPtrInput)(nil)).Elem(), TCPRouteStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteTypeInput)(nil)).Elem(), TLSRouteTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteTypeArrayInput)(nil)).Elem(), TLSRouteTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteListTypeInput)(nil)).Elem(), TLSRouteListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRoutePatchTypeInput)(nil)).Elem(), TLSRoutePatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecInput)(nil)).Elem(), TLSRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecPtrInput)(nil)).Elem(), TLSRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecParentRefsInput)(nil)).Elem(), TLSRouteSpecParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecParentRefsArrayInput)(nil)).Elem(), TLSRouteSpecParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecParentRefsPatchInput)(nil)).Elem(), TLSRouteSpecParentRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecParentRefsPatchArrayInput)(nil)).Elem(), TLSRouteSpecParentRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecPatchInput)(nil)).Elem(), TLSRouteSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecPatchPtrInput)(nil)).Elem(), TLSRouteSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecRulesInput)(nil)).Elem(), TLSRouteSpecRulesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecRulesArrayInput)(nil)).Elem(), TLSRouteSpecRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecRulesBackendRefsInput)(nil)).Elem(), TLSRouteSpecRulesBackendRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecRulesBackendRefsArrayInput)(nil)).Elem(), TLSRouteSpecRulesBackendRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecRulesBackendRefsPatchInput)(nil)).Elem(), TLSRouteSpecRulesBackendRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecRulesBackendRefsPatchArrayInput)(nil)).Elem(), TLSRouteSpecRulesBackendRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecRulesPatchInput)(nil)).Elem(), TLSRouteSpecRulesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteSpecRulesPatchArrayInput)(nil)).Elem(), TLSRouteSpecRulesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusInput)(nil)).Elem(), TLSRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusPtrInput)(nil)).Elem(), TLSRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsInput)(nil)).Elem(), TLSRouteStatusParentsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsArrayInput)(nil)).Elem(), TLSRouteStatusParentsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsConditionsInput)(nil)).Elem(), TLSRouteStatusParentsConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsConditionsArrayInput)(nil)).Elem(), TLSRouteStatusParentsConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsConditionsPatchInput)(nil)).Elem(), TLSRouteStatusParentsConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsConditionsPatchArrayInput)(nil)).Elem(), TLSRouteStatusParentsConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsParentRefInput)(nil)).Elem(), TLSRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsParentRefPtrInput)(nil)).Elem(), TLSRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsParentRefPatchInput)(nil)).Elem(), TLSRouteStatusParentsParentRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsParentRefPatchPtrInput)(nil)).Elem(), TLSRouteStatusParentsParentRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsPatchInput)(nil)).Elem(), TLSRouteStatusParentsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusParentsPatchArrayInput)(nil)).Elem(), TLSRouteStatusParentsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusPatchInput)(nil)).Elem(), TLSRouteStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*TLSRouteStatusPatchPtrInput)(nil)).Elem(), TLSRouteStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteTypeInput)(nil)).Elem(), UDPRouteTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteTypeArrayInput)(nil)).Elem(), UDPRouteTypeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteListTypeInput)(nil)).Elem(), UDPRouteListTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRoutePatchTypeInput)(nil)).Elem(), UDPRoutePatchTypeArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecInput)(nil)).Elem(), UDPRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecPtrInput)(nil)).Elem(), UDPRouteSpecArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecParentRefsInput)(nil)).Elem(), UDPRouteSpecParentRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecParentRefsArrayInput)(nil)).Elem(), UDPRouteSpecParentRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecParentRefsPatchInput)(nil)).Elem(), UDPRouteSpecParentRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecParentRefsPatchArrayInput)(nil)).Elem(), UDPRouteSpecParentRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecPatchInput)(nil)).Elem(), UDPRouteSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecPatchPtrInput)(nil)).Elem(), UDPRouteSpecPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecRulesInput)(nil)).Elem(), UDPRouteSpecRulesArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecRulesArrayInput)(nil)).Elem(), UDPRouteSpecRulesArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecRulesBackendRefsInput)(nil)).Elem(), UDPRouteSpecRulesBackendRefsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecRulesBackendRefsArrayInput)(nil)).Elem(), UDPRouteSpecRulesBackendRefsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecRulesBackendRefsPatchInput)(nil)).Elem(), UDPRouteSpecRulesBackendRefsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecRulesBackendRefsPatchArrayInput)(nil)).Elem(), UDPRouteSpecRulesBackendRefsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecRulesPatchInput)(nil)).Elem(), UDPRouteSpecRulesPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteSpecRulesPatchArrayInput)(nil)).Elem(), UDPRouteSpecRulesPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusInput)(nil)).Elem(), UDPRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusPtrInput)(nil)).Elem(), UDPRouteStatusArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsInput)(nil)).Elem(), UDPRouteStatusParentsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsArrayInput)(nil)).Elem(), UDPRouteStatusParentsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsConditionsInput)(nil)).Elem(), UDPRouteStatusParentsConditionsArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsConditionsArrayInput)(nil)).Elem(), UDPRouteStatusParentsConditionsArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsConditionsPatchInput)(nil)).Elem(), UDPRouteStatusParentsConditionsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsConditionsPatchArrayInput)(nil)).Elem(), UDPRouteStatusParentsConditionsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsParentRefInput)(nil)).Elem(), UDPRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsParentRefPtrInput)(nil)).Elem(), UDPRouteStatusParentsParentRefArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsParentRefPatchInput)(nil)).Elem(), UDPRouteStatusParentsParentRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsParentRefPatchPtrInput)(nil)).Elem(), UDPRouteStatusParentsParentRefPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsPatchInput)(nil)).Elem(), UDPRouteStatusParentsPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusParentsPatchArrayInput)(nil)).Elem(), UDPRouteStatusParentsPatchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusPatchInput)(nil)).Elem(), UDPRouteStatusPatchArgs{})
	pulumi.RegisterInputType(reflect.TypeOf((*UDPRouteStatusPatchPtrInput)(nil)).Elem(), UDPRouteStatusPatchArgs{})
	pulumi.RegisterOutputType(TCPRouteTypeOutput{})
	pulumi.RegisterOutputType(TCPRouteTypeArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteListTypeOutput{})
	pulumi.RegisterOutputType(TCPRoutePatchTypeOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecPtrOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecParentRefsOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecParentRefsArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecParentRefsPatchOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecParentRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecPatchOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecRulesOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecRulesArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecRulesBackendRefsOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecRulesBackendRefsArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecRulesBackendRefsPatchOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecRulesBackendRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecRulesPatchOutput{})
	pulumi.RegisterOutputType(TCPRouteSpecRulesPatchArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusPtrOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsConditionsOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsConditionsArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsConditionsPatchOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsParentRefOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsParentRefPtrOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsParentRefPatchOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsParentRefPatchPtrOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsPatchOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusParentsPatchArrayOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusPatchOutput{})
	pulumi.RegisterOutputType(TCPRouteStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(TLSRouteTypeOutput{})
	pulumi.RegisterOutputType(TLSRouteTypeArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteListTypeOutput{})
	pulumi.RegisterOutputType(TLSRoutePatchTypeOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecPtrOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecParentRefsOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecParentRefsArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecParentRefsPatchOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecParentRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecPatchOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecRulesOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecRulesArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecRulesBackendRefsOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecRulesBackendRefsArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecRulesBackendRefsPatchOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecRulesBackendRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecRulesPatchOutput{})
	pulumi.RegisterOutputType(TLSRouteSpecRulesPatchArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusPtrOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsConditionsOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsConditionsArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsConditionsPatchOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsParentRefOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsParentRefPtrOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsParentRefPatchOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsParentRefPatchPtrOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsPatchOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusParentsPatchArrayOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusPatchOutput{})
	pulumi.RegisterOutputType(TLSRouteStatusPatchPtrOutput{})
	pulumi.RegisterOutputType(UDPRouteTypeOutput{})
	pulumi.RegisterOutputType(UDPRouteTypeArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteListTypeOutput{})
	pulumi.RegisterOutputType(UDPRoutePatchTypeOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecPtrOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecParentRefsOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecParentRefsArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecParentRefsPatchOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecParentRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecPatchOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecPatchPtrOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecRulesOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecRulesArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecRulesBackendRefsOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecRulesBackendRefsArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecRulesBackendRefsPatchOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecRulesBackendRefsPatchArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecRulesPatchOutput{})
	pulumi.RegisterOutputType(UDPRouteSpecRulesPatchArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusPtrOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsConditionsOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsConditionsArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsConditionsPatchOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsConditionsPatchArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsParentRefOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsParentRefPtrOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsParentRefPatchOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsParentRefPatchPtrOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsPatchOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusParentsPatchArrayOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusPatchOutput{})
	pulumi.RegisterOutputType(UDPRouteStatusPatchPtrOutput{})
}
